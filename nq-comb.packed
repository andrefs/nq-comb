#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Data/Validate/Domain.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATA_VALIDATE_DOMAIN';
  package Data::Validate::Domain;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.15';
  
  use Net::Domain::TLD 1.74 qw(tld_exists);
  
  use Exporter qw( import );
  
  ## no critic (Modules::ProhibitAutomaticExportation)
  our @EXPORT = qw(
      is_domain
      is_hostname
      is_domain_label
  );
  
  sub new {
      my $class = shift;
  
      return bless {@_}, ref($class) || $class;
  }
  
  # -------------------------------------------------------------------------------
  
  sub is_domain {
      my ( $value, $opt ) = _maybe_oo(@_);
  
      my ( $hostname, $bits ) = _domain_labels( $value, $opt );
  
      return unless $bits;
  
      my $tld = $bits->[-1];
  
      # domain_allow_single_label set to true disables this check
      unless ( $opt->{domain_allow_single_label} ) {
  
          # All domains have more then 1 label (neely.cx good, com not good)
          return if @{$bits} < 2;
      }
  
      return $hostname if $opt->{domain_disable_tld_validation};
  
      # If the option to enable domain_private_tld is enabled
      # and a private domain is specified, then we return if that matches
      if ( exists $opt->{domain_private_tld}
          && ref( $opt->{domain_private_tld} ) ) {
          my $lc_tld = lc($tld);
          if ( ref( $opt->{domain_private_tld} ) eq 'HASH' ) {
              if ( exists $opt->{domain_private_tld}->{$lc_tld} ) {
                  return $hostname;
              }
          }
          else {
              if ( $tld =~ $opt->{domain_private_tld} ) {
                  return $hostname;
              }
          }
      }
  
      # Verify domain has a valid TLD
      return unless tld_exists($tld);
  
      return $hostname;
  }
  
  # -------------------------------------------------------------------------------
  
  sub is_hostname {
      my ( $value, $opt ) = _maybe_oo(@_);
  
      my ($hostname) = _domain_labels( $value, $opt );
  
      # We do not verify TLD for hostnames, as hostname.subhost is a valid hostname
  
      return $hostname;
  }
  
  sub _domain_labels {
      my ( $value, $opt ) = @_;
  
      return unless defined($value);
  
      # FYI: DNS limits names to 255 octets, encoded to RDATA. Each label
      # includes a length-octet prefix; those length octets count against the
      # 255-octet maximum. The number of labels exceeds the number of dots by 1
      # (assuming no trailing dot), and the number of length octets exceeds
      # number of labels by 1 (since thereâ€™s always a trailing NUL octet). The
      # effective limit is thus 255 - 1 - 1, or 253. See
      # https://devblogs.microsoft.com/oldnewthing/20120412-00/?p=7873 for a
      # more detailed explanation of this.
  
      my $trailing_dot = $value =~ s/\.\z// ? q{.} : q{};
  
      my $encoded_length = ( $trailing_dot ? 1 : 2 ) + length($value);
  
      return if $encoded_length > 255;
  
      my @bits;
      foreach my $label ( split /\./, $value, -1 ) {
          my $bit = is_domain_label( $label, $opt );
          return unless defined $bit;
          push( @bits, $bit );
      }
  
      return unless @bits;
  
      return ( join( '.', @bits ) . $trailing_dot, \@bits );
  }
  
  sub is_domain_label {
      my ( $value, $opt ) = _maybe_oo(@_);
  
      return unless defined($value);
  
      # Fix Bug: 41033
      return if ( $value =~ /\n/ );
  
      # bail if we are dealing with more then just a hostname
      return if ( $value =~ /\./ );
      my $length = length($value);
      my $hostname;
      if ( $length == 1 ) {
          if ( $opt->{domain_allow_underscore} ) {
              ($hostname) = $value =~ /^([0-9A-Za-z\_])$/;
          }
          else {
              ($hostname) = $value =~ /^([0-9A-Za-z])$/;
          }
      }
      elsif ( $length > 1 && $length <= 63 ) {
          if ( $opt->{domain_allow_underscore} ) {
              ($hostname)
                  = $value =~ /^([0-9A-Za-z\_][0-9A-Za-z\-\_]*[0-9A-Za-z])$/;
          }
          else {
              ($hostname)
                  = $value =~ /^([0-9A-Za-z][0-9A-Za-z\-]*[0-9A-Za-z])$/;
          }
      }
      else {
          return;
      }
      return $hostname;
  }
  
  sub _maybe_oo {
      if ( ref $_[0] ) {
          return @_[ 1, 0 ];
      }
      else {
          return ( $_[0], ( defined $_[1] ? $_[1] : {} ) );
      }
  }
  
  1;
  
  # ABSTRACT: Domain and host name validation
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Data::Validate::Domain - Domain and host name validation
  
  =head1 VERSION
  
  version 0.15
  
  =head1 SYNOPSIS
  
    use Data::Validate::Domain qw(is_domain);
  
    # as a function
    my $test = is_domain($suspect);
    die "$test is not a domain" unless $test;
  
    # or
  
    die "$test is not a domain" unless is_domain($suspect, \%options);
  
    # or as an object
    my $v = Data::Validate::Domain->new(%options);
  
    die "$test is not a domain" unless $v->is_domain($suspect);
  
  =head1 DESCRIPTION
  
  This module offers a few subroutines for validating domain and host names.
  
  =for test_synopsis my ($suspect, %options);
  
  =head1 FUNCTIONS
  
  All of the functions below are exported by default.
  
  All of the functions return an untainted value on success and a false value
  (C<undef> or an empty list) on failure. In scalar context, you should check
  that the return value is defined, because something like
  C<is_domain_label('0')> will return a defined but false value.
  
  The value to test is always the first (and often only) argument.
  
  Note that none of these functions test whether a domain or hostname is actually
  resolvable or reachable.
  
  =head2 Data::Validate::Domain->new()
  
  This method constructs a validation object. It accepts the following arguments:
  
  =over 4
  
  =item * domain_allow_underscore
  
  According to RFC underscores are forbidden in hostnames but not domain names.
  By default C<is_domain()>, C<is_domain_label()>, and C<is_hostname()> will fail
  if the value to be checked includes underscores. Setting this to a true value
  will allow the use of underscores in all functions.
  
  =item * domain_allow_single_label
  
  By default C<is_domain()> will fail if you ask it to verify a domain that only
  has a single label i.e. "neely.cx" is good, but "com" would fail. If you set
  this option to a true value then C<is_domain()> will allow single label domains
  through. This is most likely to be useful in combination with the
  C<domain_private_tld> argument.
  
  =item * domain_disable_tld_validation
  
  Disables TLD validation for C<is_domain()>. This may be useful if you need to
  check domains with new gTLDs that have not yet been added to
  L<Net::Domain::TLD>.
  
  =item * domain_private_tld
  
  By default C<is_domain()> requires all domains to have a valid public TLD (i.e.
  com, net, org, uk, etc). This is verified using the L<Net::Domain::TLD> module.
  This behavior can be extended in two different ways. You can provide either a
  hash reference where additional TLDs are keys or you can supply a regular
  expression.
  
  NOTE: The TLD is normalized to the lower case form prior to the check being
  done. This is done only for the TLD check, and does not alter the output in any
  way.
  
  Hashref example:
  
    domain_private_tld => {
        privatetld1 => 1,
        privatetld2 => 1,
    }
  
  Regular expression example:
  
   domain_private_tld => qr /^(?:privatetld1|privatetld2)$/,
  
  =back
  
  =head2 is_domain($domain, \%options)
  
  This can be called as either a subroutine or a method. If called as a sub, you
  can pass any of the arguments accepted by the constructor as options. If called
  as a method, any additional options are ignored.
  
  This returns the untainted domain name if the given C<$domain> is a valid
  domain.
  
  A dotted quad (such as 127.0.0.1) is not considered a domain and will return
  false. See L<Data::Validate::IP> for IP Validation.
  
  Per RFC 1035, this sub does accept a value ending in a single period (i.e.
  "domain.com.") to be a valid domain. This is called an absolute domain name,
  and should be properly resolved by any DNS tool (tested with C<dig>, C<ssh>,
  and L<Net::DNS>).
  
  =over 4
  
  =item I<From RFC 952>
  
     A "name" (Net, Host, Gateway, or Domain name) is a text string up
     to 24 characters drawn from the alphabet (A-Z), digits (0-9), minus
     sign (-), and period (.). Note that periods are only allowed when
     they serve to delimit components of "domain style names".
  
     No blank or space characters are permitted as part of a
     name. No distinction is made between upper and lower case. The first
     character must be an alpha character [Relaxed in RFC 1123] . The last
     character must not be a minus sign or period.
  
  =item I<From RFC 1035>
  
      labels          63 octets or less
      names           255 octets or less
  
      [snip] limit the label to 63 octets or less.
  
      To simplify implementations, the total length of a domain name (i.e.,
      label octets and label length octets) is restricted to 255 octets or
      less.
  
  =item I<From RFC 1123>
  
      One aspect of host name syntax is hereby changed: the
      restriction on the first character is relaxed to allow either a
      letter or a digit. Host software MUST support this more liberal
      syntax.
  
      Host software MUST handle host names of up to 63 characters and
      SHOULD handle host names of up to 255 characters.
  
  =back
  
  =head2 is_hostname($hostname, \%options)
  
  This can be called as either a subroutine or a method. If called as a sub, you
  can pass any of the arguments accepted by the constructor as options. If called
  as a method, any additional options are ignored.
  
  This returns the untainted hostname if the given C<$hostname> is a valid
  hostname.
  
  Hostnames are not required to end in a valid TLD.
  
  =head2 is_domain_label($label, \%options)
  
  This can be called as either a subroutine or a method. If called as a sub, you
  can pass any of the arguments accepted by the constructor as options. If called
  as a method, any additional options are ignored.
  
  This returns the untainted label if the given C<$label> is a valid label.
  
  A domain label is simply a single piece of a domain or hostname. For example,
  the "www.foo.com" hostname contains the labels "www", "foo", and "com".
  
  =head1 SEE ALSO
  
  B<[RFC 1034] [RFC 1035] [RFC 2181] [RFC 1123]>
  
  =over 4
  
  =item L<Data::Validate>
  
  =item L<Data::Validate::IP>
  
  =back
  
  =head1 ACKNOWLEDGEMENTS
  
  Thanks to Richard Sonnen <F<sonnen@richardsonnen.com>> for writing the
  Data::Validate module.
  
  Thanks to Len Reed <F<lreed@levanta.com>> for helping develop the options
  mechanism for Data::Validate modules.
  
  =head1 SUPPORT
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Data-Validate-Domain/issues>.
  
  I am also usually active on IRC as 'autarch' on C<irc://irc.perl.org>.
  
  =head1 SOURCE
  
  The source code repository for Data-Validate-Domain can be found at L<https://github.com/houseabsolute/Data-Validate-Domain>.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Neil Neely <neil@neely.cx>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Anirvan Chatterjee David Steinbrunner Felipe Gasper Gregory Oschwald
  
  =over 4
  
  =item *
  
  Anirvan Chatterjee <anirvan@users.noreply.github.com>
  
  =item *
  
  David Steinbrunner <dsteinbrunner@pobox.com>
  
  =item *
  
  Felipe Gasper <felipe@felipegasper.com>
  
  =item *
  
  Gregory Oschwald <goschwald@maxmind.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2021 by Neil Neely.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
DATA_VALIDATE_DOMAIN

$fatpacked{"Data/Validate/IP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATA_VALIDATE_IP';
  package Data::Validate::IP;
  
  use strict;
  use warnings;
  
  use 5.008;
  
  our $VERSION = '0.31';
  
  use NetAddr::IP 4;
  use Scalar::Util qw( blessed );
  
  use base 'Exporter';
  
  ## no critic (Modules::ProhibitAutomaticExportation)
  our @EXPORT = qw(
      is_ip
      is_ipv4
      is_ipv6
      is_innet_ipv4
  );
  ## use critic
  
  our $HAS_SOCKET;
  
  BEGIN {
      local $@ = undef;
      $HAS_SOCKET = ( !$ENV{DVI_NO_SOCKET} )
          && eval {
          require Socket;
          Socket->import(qw( AF_INET AF_INET6 inet_pton ));
  
          # On some platforms, Socket.pm exports an inet_pton that just dies
          # when it is called. On others, inet_pton accepts various forms of
          # invalid input.
          defined &Socket::inet_pton
              && !defined inet_pton( Socket::AF_INET(),  '016.17.184.1' )
              && !defined inet_pton( Socket::AF_INET6(), '2067::1:' )
  
              # Some old versions of Socket are hopelessly broken
              && length( inet_pton( Socket::AF_INET(), '1.1.1.1' ) ) == 4;
          };
  
      if ($HAS_SOCKET) {
          *is_ipv4             = \&_fast_is_ipv4;
          *is_ipv6             = \&_fast_is_ipv6;
          *is_ip               = \&_fast_is_ip;
          *_build_is_X_ip_subs = \&_build_fast_is_X_ip_subs;
      }
      else {
          *is_ipv4             = \&_slow_is_ipv4;
          *is_ipv6             = \&_slow_is_ipv6;
          *is_ip               = \&_slow_is_ip;
          *_build_is_X_ip_subs = \&_build_slow_is_X_ip_subs;
      }
  }
  
  sub new {
      my $class = shift;
  
      return bless {}, $class;
  }
  
  sub _fast_is_ip {
      shift if ref $_[0];
      my $value = shift;
  
      return undef unless defined $value;
      return $value =~ /:/ ? _fast_is_ipv6($value) : _fast_is_ipv4($value);
  }
  
  sub _fast_is_ipv4 {
      shift if ref $_[0];
      my $value = shift;
  
      return undef unless _fast_is_ipv4_packed($value);
  
      ## no critic (RegularExpressions::ProhibitCaptureWithoutTest)
      $value =~ /(.+)/;
      return $1;
  }
  
  sub _fast_is_ipv4_packed {
      my $value = shift;
  
      return undef unless defined $value;
      return undef if $value =~ /\0/;
      return inet_pton( Socket::AF_INET(), $value );
  }
  
  sub _slow_is_ip {
      shift if ref $_[0];
      my $value = shift;
  
      return _slow_is_ipv4($value) || _slow_is_ipv6($value);
  }
  
  sub _slow_is_ipv4 {
      shift if ref $_[0];
      my $value = shift;
  
      return undef unless defined($value);
  
      my (@octets) = $value =~ /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
      return undef unless ( @octets == 4 );
      foreach (@octets) {
          return undef if $_ < 0 || $_ > 255;
          return undef if $_ =~ /^0\d{1,2}$/;
      }
  
      return join( '.', @octets );
  }
  
  sub _fast_is_ipv6 {
      shift if ref $_[0];
      my $value = shift;
  
      return undef unless _fast_is_ipv6_packed($value);
  
      ## no critic (RegularExpressions::ProhibitCaptureWithoutTest)
      $value =~ /(.+)/;
      return $1;
  }
  
  sub _fast_is_ipv6_packed {
      my $value = shift;
  
      return undef unless defined $value;
      return undef if $value =~ /\0/;
      return undef if $value =~ /0[[:xdigit:]]{4}/;
      return inet_pton( Socket::AF_INET6(), $value );
  }
  
  {
      # This comes from Regexp::IPv6
      ## no critic (RegularExpressions::ProhibitComplexRegexes)
      my $ipv6_re
          = qr/(?-xism::(?::[0-9a-fA-F]{1,4}){0,5}(?:(?::[0-9a-fA-F]{1,4}){1,2}|:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})))|[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}:(?:[0-9a-fA-F]{1,4}|:)|(?::(?:[0-9a-fA-F]{1,4})?|(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))))|:(?:(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|[0-9a-fA-F]{1,4}(?::[0-9a-fA-F]{1,4})?|))|(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|:[0-9a-fA-F]{1,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){0,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,2}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,3}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:))|(?:(?::[0-9a-fA-F]{1,4}){0,4}(?::(?:(?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))|(?::[0-9a-fA-F]{1,4}){1,2})|:)))/;
  
      sub _slow_is_ipv6 {
          shift if ref $_[0];
          my $value = shift;
  
          return undef unless defined($value);
  
          return '::' if $value eq '::';
          return undef unless $value =~ /^$ipv6_re$/;
  
          ## no critic (RegularExpressions::ProhibitCaptureWithoutTest)
          $value =~ /(.+)/;
          return $1;
      }
  }
  
  # This is just a quick test - we'll let NetAddr::IP decide if the address is
  # valid.
  my $ip_re         = qr/\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/;
  my $partial_ip_re = qr/\d{1,3}(?:\.\d{1,3}){0,2}/;
  
  ## no critic (Subroutines::ProhibitExcessComplexity, ControlStructures::ProhibitCascadingIfElse)
  sub is_innet_ipv4 {
      shift if ref $_[0];
      my $value   = shift;
      my $network = shift;
  
      return undef unless defined($value);
  
      my $ip = is_ipv4($value);
      return undef unless defined $ip;
  
      # Backwards compatibility hacks to make it accept things that Net::Netmask
      # accepts.
      if (   $network eq 'default'
          || $network =~ /^$ip_re$/
          || $network =~ m{^$ip_re/\d\d?$} ) {
  
          $network = NetAddr::IP->new($network) or return undef;
      }
      elsif ( !( blessed $network && $network->isa('NetAddr::IP') ) ) {
          my $orig = $network;
          if ( $network =~ /^($ip_re)[:\-]($ip_re)$/ ) {
              my ( $net, $netmask ) = ( $1, $2 );
  
              my $bits = _netmask_to_bits($netmask)
                  or return undef;
  
              $network = "$net/$bits";
          }
          elsif ( $network =~ /^($ip_re)\#($ip_re)$/ ) {
              my ( $net, $hostmask ) = ( $1, $2 );
  
              my $bits = _hostmask_to_bits($hostmask)
                  or return undef;
  
              $network = "$net/$bits";
          }
          elsif ( $network =~ m{^($partial_ip_re)/(\d\d?)$} ) {
              my ( $net, $bits ) = ( $1, $2 );
  
              # This is a hack to avoid a deprecation warning (Use of implicit
              # split to @_ is deprecated) that shows up on 5.10.1 but not on
              # newer Perls.
              #
              ## no critic(Variables::ProhibitUnusedVarsStricter)
              my $octets = scalar( my @tmp = split /\./, $net );
              $network = $net;
              $network .= '.0' x ( 4 - $octets );
              $network .= "/$bits";
          }
          elsif ( $network =~ /^$partial_ip_re$/ ) {
  
              ## no critic(Variables::ProhibitUnusedVarsStricter)
              my $octets = scalar( my @tmp = split /\./, $network );
              if ( $octets < 4 ) {
                  $network .= '.0' x ( 4 - $octets );
                  $network .= '/' . $octets * 8;
              }
          }
  
          if ( $orig ne $network ) {
              _deprecation_warn(
                  'Use of non-CIDR notation for networks with is_innet_ipv4() is deprecated'
              );
          }
  
          $network = NetAddr::IP->new($network) or return undef;
      }
  
      my $netaddr_ip = NetAddr::IP->new($ip) or return undef;
  
      return $ip if $network->contains($netaddr_ip);
      return undef;
  }
  ## use critic;
  
  {
      my %netmasks = (
          '128.0.0.0'       => '1',
          '192.0.0.0'       => '2',
          '224.0.0.0'       => '3',
          '240.0.0.0'       => '4',
          '248.0.0.0'       => '5',
          '252.0.0.0'       => '6',
          '254.0.0.0'       => '7',
          '255.0.0.0'       => '8',
          '255.128.0.0'     => '9',
          '255.192.0.0'     => '10',
          '255.224.0.0'     => '11',
          '255.240.0.0'     => '12',
          '255.248.0.0'     => '13',
          '255.252.0.0'     => '14',
          '255.254.0.0'     => '15',
          '255.255.0.0'     => '16',
          '255.255.128.0'   => '17',
          '255.255.192.0'   => '18',
          '255.255.224.0'   => '19',
          '255.255.240.0'   => '20',
          '255.255.248.0'   => '21',
          '255.255.252.0'   => '22',
          '255.255.254.0'   => '23',
          '255.255.255.0'   => '24',
          '255.255.255.128' => '25',
          '255.255.255.192' => '26',
          '255.255.255.224' => '27',
          '255.255.255.240' => '28',
          '255.255.255.248' => '29',
          '255.255.255.252' => '30',
          '255.255.255.254' => '31',
          '255.255.255.255' => '32',
      );
  
      sub _netmask_to_bits {
          return $netmasks{ $_[0] };
      }
  }
  
  {
      my %hostmasks = (
          '255.255.255.255' => 0,
          '127.255.255.255' => 1,
          '63.255.255.255'  => 2,
          '31.255.255.255'  => 3,
          '15.255.255.255'  => 4,
          '7.255.255.255'   => 5,
          '3.255.255.255'   => 6,
          '1.255.255.255'   => 7,
          '0.255.255.255'   => 8,
          '0.127.255.255'   => 9,
          '0.63.255.255'    => 10,
          '0.31.255.255'    => 11,
          '0.15.255.255'    => 12,
          '0.7.255.255'     => 13,
          '0.3.255.255'     => 14,
          '0.1.255.255'     => 15,
          '0.0.255.255'     => 16,
          '0.0.127.255'     => 17,
          '0.0.63.255'      => 18,
          '0.0.31.255'      => 19,
          '0.0.15.255'      => 20,
          '0.0.7.255'       => 21,
          '0.0.3.255'       => 22,
          '0.0.1.255'       => 23,
          '0.0.0.255'       => 24,
          '0.0.0.127'       => 25,
          '0.0.0.63'        => 26,
          '0.0.0.31'        => 27,
          '0.0.0.15'        => 28,
          '0.0.0.7'         => 29,
          '0.0.0.3'         => 30,
          '0.0.0.1'         => 31,
          '0.0.0.0'         => 32,
      );
  
      sub _hostmask_to_bits {
          return $hostmasks{ $_[0] };
      }
  }
  
  {
      my %warned_at;
  
      sub _deprecation_warn {
          my $warning = shift;
          my @caller  = caller(2);
  
          my $caller_info
              = "at line $caller[2] of $caller[0] in sub $caller[3]";
  
          return undef if $warned_at{$warning}{$caller_info}++;
  
          warn "$warning $caller_info\n";
      }
  }
  
  {
      my %ipv4_networks = (
          loopback => { networks => '127.0.0.0/8' },
          private  => {
              networks => [
                  qw(
                      10.0.0.0/8
                      172.16.0.0/12
                      192.168.0.0/16
                  )
              ],
          },
          testnet => {
              networks => [
                  qw(
                      192.0.2.0/24
                      198.51.100.0/24
                      203.0.113.0/24
                  )
              ],
          },
          anycast    => { networks => '192.88.99.0/24' },
          multicast  => { networks => '224.0.0.0/4' },
          linklocal  => { networks => '169.254.0.0/16' },
          unroutable => {
              networks => [
                  qw(
                      0.0.0.0/8
                      100.64.0.0/10
                      192.0.0.0/29
                      198.18.0.0/15
                      240.0.0.0/4
                  )
              ],
          },
      );
  
      _build_is_X_ip_subs( \%ipv4_networks, 4 );
  }
  
  {
      my %ipv6_networks = (
          loopback    => { networks => '::1/128' },
          ipv4_mapped => { networks => '::ffff:0:0/96' },
          discard     => { networks => '100::/64' },
          special     => { networks => '2001::/23' },
          teredo      => {
              networks  => '2001::/32',
              subnet_of => 'special',
          },
          orchid => {
              networks  => '2001:10::/28',
              subnet_of => 'special',
          },
          documentation => { networks => '2001:db8::/32' },
          private       => { networks => 'fc00::/7' },
          linklocal     => { networks => 'fe80::/10' },
          multicast     => { networks => 'ff00::/8' },
          unspecified   => { networks => '::/128' },
      );
  
      _build_is_X_ip_subs( \%ipv6_networks, 6 );
  
      # This exists for the benefit of the test code.
      ## no critic (Subroutines::ProhibitUnusedPrivateSubroutines)
      sub _network_is_subnet_of {
          my $network = shift;
          my $other   = shift;
  
          return ( $ipv6_networks{$network}{subnet_of} || q{} ) eq $other;
      }
  }
  
  ## no critic (TestingAndDebugging::ProhibitNoStrict, BuiltinFunctions::ProhibitStringyEval)
  sub _build_slow_is_X_ip_subs {
      my $networks  = shift;
      my $ip_number = shift;
  
      my $is_ip_sub   = $ip_number == 4 ? 'is_ipv4' : 'is_ipv6';
      my $netaddr_new = $ip_number == 4 ? 'new'     : 'new6';
  
      my @all_nets;
  
      local $@ = undef;
      for my $type ( keys %{$networks} ) {
          my @nets
              = map { NetAddr::IP->$netaddr_new($_) }
              ref $networks->{$type}{networks}
              ? @{ $networks->{$type}{networks} }
              : $networks->{$type}{networks};
  
          # Some IPv6 networks (like TEREDO) are a subset of the special block
          # so there's no point in checking for them in the is_public_ipv6()
          # sub.
          unless ( $networks->{$type}{subnet_of} ) {
              push @all_nets, @nets;
          }
  
          # We're using code gen rather than just making an anon sub outright so
          # we don't have to pay the cost of derefencing the $is_ip_sub and the
          # dynamic dispatch cost for $netaddr_new
          my $sub = eval sprintf( <<'EOF', $is_ip_sub, $netaddr_new );
  sub {
      shift if ref $_[0];
      my $value = shift;
  
      return undef unless defined $value;
  
      my $ip = %s($value);
      return undef unless defined $ip;
  
      my $netaddr_ip = NetAddr::IP->%s($ip);
      for my $net (@nets) {
          return $ip if $net->contains($netaddr_ip);
      }
      return undef;
  }
  EOF
          die $@ if $@;
  
          my $sub_name = 'is_' . $type . '_ipv' . $ip_number;
          {
              no strict 'refs';
              *{$sub_name} = $sub;
          }
          push @EXPORT, $sub_name;
      }
  
      my $sub = eval sprintf( <<'EOF', $is_ip_sub, $netaddr_new );
  sub {
      shift if ref $_[0];
      my $value = shift;
  
      return undef unless defined($value);
  
      my $ip = %s($value);
      return undef unless defined $ip;
  
      my $netaddr_ip = NetAddr::IP->%s($ip);
      for my $net (@all_nets) {
          return undef if $net->contains($netaddr_ip);
      }
  
      return $ip;
  }
  EOF
      die $@ if $@;
  
      my $sub_name = 'is_public_ipv' . $ip_number;
      {
          no strict 'refs';
          *{$sub_name} = $sub;
      }
      push @EXPORT, $sub_name;
  }
  
  sub _build_fast_is_X_ip_subs {
      my $networks  = shift;
      my $ip_number = shift;
  
      my $family = $ip_number == 4 ? Socket::AF_INET() : Socket::AF_INET6();
  
      my @all_nets;
  
      local $@ = undef;
      for my $type ( keys %{$networks} ) {
          my @nets
              = map { _packed_network_and_netmask( $family, $_ ) }
              ref $networks->{$type}{networks}
              ? @{ $networks->{$type}{networks} }
              : $networks->{$type}{networks};
  
          # Some IPv6 networks (like TEREDO) are a subset of the special block
          # so there's no point in checking for them in the is_public_ipv6()
          # sub.
          unless ( $networks->{$type}{subnet_of} ) {
              push @all_nets, @nets;
          }
  
          # We're using code gen rather than just making an anon sub outright so
          # we don't have to pay the cost of derefencing the $is_ip_sub and the
          # dynamic dispatch cost for $netaddr_new
          my $sub = eval sprintf( <<'EOF', $ip_number );
  sub {
      shift if ref $_[0];
      my $value = shift;
  
      my $ip = _fast_is_ipv%u_packed($value);
  
      return undef unless defined $ip;
  
      for my $net (@nets) {
          if (($net->[1] & $ip) eq $net->[0]) {
              $value =~ /(.+)/;
              return $1;
          }
      }
      return undef;
  }
  EOF
          die $@ if $@;
  
          my $sub_name = 'is_' . $type . '_ipv' . $ip_number;
          {
              no strict 'refs';
              *{$sub_name} = $sub;
          }
          push @EXPORT, $sub_name;
      }
  
      my $sub = eval sprintf( <<'EOF', $ip_number );
  sub {
      shift if ref $_[0];
      my $value = shift;
  
      my $ip = _fast_is_ipv%u_packed($value);
  
      return undef unless defined $ip;
  
      for my $net (@all_nets) {
          return undef if ($net->[1] & $ip) eq $net->[0];
      }
  
      $value =~ /(.+)/;
      return $1;
  }
  EOF
      die $@ if $@;
  
      my $sub_name = 'is_public_ipv' . $ip_number;
      {
          no strict 'refs';
          *{$sub_name} = $sub;
      }
      push @EXPORT, $sub_name;
  }
  
  sub _packed_network_and_netmask {
      my $family  = shift;
      my $network = shift;
  
      my ( $ip, $bits ) = split qr{/}, $network, 2;
  
      return [
          inet_pton( $family, $ip ),
          _packed_netmask( $family, $bits )
      ];
  }
  
  sub _packed_netmask {
      my $family = shift;
      my $bits   = shift;
  
      my $bit_length = $family == Socket::AF_INET() ? 32 : 128;
  
      my $bit_string
          = join( q{}, (1) x $bits, (0) x ( $bit_length - $bits ) );
      return pack( 'B' . $bit_length, $bit_string );
  }
  
  for my $sub (qw( linklocal loopback multicast private public )) {
      my $sub_name = "is_${sub}_ip";
  
      {
          no strict 'refs';
          *{$sub_name}
              = eval "sub { ${sub_name}v4(\@_) || ${sub_name}v6(\@_) }";
          die $@ if $@;
      }
  
      push @EXPORT, $sub_name;
  }
  ## use critic
  
  1;
  
  # ABSTRACT: IPv4 and IPv6 validation methods
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Data::Validate::IP - IPv4 and IPv6 validation methods
  
  =head1 VERSION
  
  version 0.31
  
  =head1 SYNOPSIS
  
    use Data::Validate::IP qw(is_ipv4 is_ipv6);
  
    my $suspect = '1.2.3.4';
    if (is_ipv4($suspect)) {
        print "Looks like an IPv4 address";
    }
    else {
        print "Not an IPv4 address\n";
    }
  
    $suspect = '::1234';
    if (is_ipv6($suspect)) {
        print "Looks like an IPv6 address";
    }
    else {
        print "Not an IPv6 address\n";
    }
  
  =head1 DESCRIPTION
  
  This module provides a number IP address validation subs that both validate and
  untaint their input. This includes both basic validation (C<is_ipv4()> and
  C<is_ipv6()>) and special cases like checking whether an address belongs to a
  specific network or whether an address is public or private (reserved).
  
  =head1 USAGE AND SECURITY RECOMMENDATIONS
  
  It's important to understand that if C<is_ipv4($ip)>, C<is_ipv6($ip)>, or
  C<is_ip($ip)> return false, then all other validation functions for that IP
  address family will I<also> return false. So for example, if C<is_ipv4($ip)>
  returns false, then C<is_private_ipv4($ip)> I<and> C<is_public_ipv4($ip)> will
  both also return false.
  
  This means that simply calling C<is_private_ipv4($ip)> by itself is not
  sufficient if you are dealing with untrusted input. You should always check
  C<is_ipv4($ip)> as well. This applies as well when using IPv6 functions or
  generic functions like C<is_private_ip($ip)>.
  
  There are security implications to this around certain oddly formed addresses.
  Notably, an address like "010.0.0.1" is technically valid, but the operating
  system will treat "010" as an octal number. That means that "010.0.0.1" is
  equivalent to "8.0.0.1", I<not> "10.0.0.1".
  
  However, this module's C<is_ipv4($ip)> and C<is_ip($ip)> functions will return
  false for addresses like "010.0.0.1" which have octal components. And of course
  that means that it also returns false for C<is_private_ipv4($ip)> I<and>
  C<is_public_ipv4($ip)>.
  
  =head1 FUNCTIONS
  
  All of the functions below are exported by default.
  
  All functions return an untainted value if the test passes and undef if it
  fails. In theory, this means that you should always check for a defined status
  explicitly but in practice there are no valid IP addresses where the string
  form evaluates to false in Perl.
  
  Note that none of these functions actually attempt to test whether the given IP
  address is routable from your device; they are purely semantic checks.
  
  =head2 is_ipv4($ip), is_ipv6($ip), is_ip($ip)
  
  These functions simply check whether the address is a valid IPv4 or IPv6
  address.
  
  =head2 is_innet_ipv4($ip, $network)
  
  This subroutine checks whether the address belongs to the given IPv4 network.
  The C<$network> argument can either be a string in CIDR notation like
  "15.0.15.0/24" or a L<NetAddr::IP> object.
  
  This subroutine used to accept many more forms of network specifications
  (anything L<Net::Netmask> accepts) but this has been deprecated.
  
  =head2 is_unroutable_ipv4($ip)
  
  This subroutine checks whether the address belongs to any of several special
  use IPv4 networks - C<0.0.0.0/8>, C<100.64.0.0/10>, C<192.0.0.0/29>,
  C<198.18.0.0/15>, C<240.0.0.0/4> - as defined by L<RFC
  5735|http://tools.ietf.org/html/rfc5735>, L<RFC
  6333|http://tools.ietf.org/html/rfc6333>, and L<RFC
  6958|http://tools.ietf.org/html/rfc6598>.
  
  Arguably, these should be broken down further but this subroutine will always
  exist for backwards compatibility.
  
  =head2 is_private_ipv4($ip)
  
  This subroutine checks whether the address belongs to any of the private IPv4
  networks - C<10.0.0.0/8>, C<172.16.0.0/12>, C<192.168.0.0/16> - as defined by
  L<RFC 5735|http://tools.ietf.org/html/rfc5735>.
  
  =head2 is_loopback_ipv4($ip)
  
  This subroutine checks whether the address belongs to the IPv4 loopback network
  - C<127.0.0.0/8> - as defined by L<RFC
  5735|http://tools.ietf.org/html/rfc5735>.
  
  =head2 is_linklocal_ipv4($ip)
  
  This subroutine checks whether the address belongs to the IPv4 link local
  network - C<169.254.0.0/16> - as defined by L<RFC
  5735|http://tools.ietf.org/html/rfc5735>.
  
  =head2 is_testnet_ipv4($ip)
  
  This subroutine checks whether the address belongs to any of the IPv4 TEST-NET
  networks for use in documentation and example code - C<192.0.2.0/24>,
  C<198.51.100.0/24>, and C<203.0.113.0/24> - as defined by L<RFC
  5735|http://tools.ietf.org/html/rfc5735>.
  
  =head2 is_anycast_ipv4($ip)
  
  This subroutine checks whether the address belongs to the 6to4 relay anycast
  network - C<192.88.99.0/24> - as defined by L<RFC
  5735|http://tools.ietf.org/html/rfc5735>.
  
  =head2 is_multicast_ipv4($ip)
  
  This subroutine checks whether the address belongs to the IPv4 multicast
  network - C<224.0.0.0/4> - as defined by L<RFC
  5735|http://tools.ietf.org/html/rfc5735>.
  
  =head2 is_loopback_ipv6($ip)
  
  This subroutine checks whether the address is the IPv6 loopback address -
  C<::1/128> - as defined by L<RFC 4291|http://tools.ietf.org/html/rfc4291>.
  
  =head2 is_ipv4_mapped_ipv6($ip)
  
  This subroutine checks whether the address belongs to the IPv6 IPv4-mapped
  address network - C<::ffff:0:0/96> - as defined by L<RFC
  4291|http://tools.ietf.org/html/rfc4291>.
  
  =head2 is_discard_ipv6($ip)
  
  This subroutine checks whether the address belongs to the IPv6 discard prefix
  network - C<100::/64> - as defined by L<RFC
  6666|http://tools.ietf.org/html/rfc6666>.
  
  =head2 is_special_ipv6($ip)
  
  This subroutine checks whether the address belongs to the IPv6 special network
  - C<2001::/23> - as defined by L<RFC 2928|http://tools.ietf.org/html/rfc2928>.
  
  =head2 is_teredo_ipv6($ip)
  
  This subroutine checks whether the address belongs to the IPv6 TEREDO network -
  C<2001::/32> - as defined by L<RFC 4380|http://tools.ietf.org/html/rfc4380>.
  
  Note that this network is a subnet of the larger special network at
  C<2001::/23>.
  
  =head2 is_orchid_ipv6($ip)
  
  This subroutine checks whether the address belongs to the IPv6 ORCHID network -
  C<2001::/32> - as defined by L<RFC 4380|http://tools.ietf.org/html/rfc4380>.
  
  Note that this network is a subnet of the larger special network at
  C<2001::/23>.
  
  This network is currently scheduled to be returned to the special pool in March
  of 2014 unless the IETF extends its use. If that happens this subroutine will
  continue to exist but will always return false.
  
  =head2 is_documentation_ipv6($ip)
  
  This subroutine checks whether the address belongs to the IPv6 documentation
  network - C<2001:DB8::/32> - as defined by L<RFC
  3849|http://tools.ietf.org/html/rfc3849>.
  
  =head2 is_unspecified_ipv6($ip)
  
  This subroutine checks whether the address belongs to the IPv6 unspecified
  network - C<::0/128> - as defined by L<RFC
  4291|http://tools.ietf.org/html/rfc4291>.. Note that the address in this subnet
  is neither private nor public.
  
  =head2 is_private_ipv6($ip)
  
  This subroutine checks whether the address belongs to the IPv6 private network
  - C<FC00::/7> - as defined by L<RFC 4193|http://tools.ietf.org/html/rfc4193>.
  
  =head2 is_linklocal_ipv6($ip)
  
  This subroutine checks whether the address belongs to the IPv6 link-local
  unicast network - C<FE80::/10> - as defined by L<RFC
  4291|http://tools.ietf.org/html/rfc4291>.
  
  =head2 is_multicast_ipv6($ip)
  
  This subroutine checks whether the address belongs to the IPv6 multicast
  network - C<FF00::/8> - as defined by L<RFC
  4291|http://tools.ietf.org/html/rfc4291>.
  
  =head2 is_public_ipv4($ip), is_public_ipv6($ip), is_public_ip($ip)
  
  These subroutines check whether the given IP address belongs to any of the
  special case networks defined previously. Note that this is B<not> simply the
  opposite of checking C<is_private_ipv4()> or C<is_private_ipv6()>. The private
  networks are a subset of all the special case networks.
  
  =head2 is_linklocal_ip($ip)
  
  This subroutine checks whether the address belongs to the IPv4 or IPv6
  link-local unicast network.
  
  =head2 is_loopback_ip($ip)
  
  This subroutine checks whether the address is the IPv4 or IPv6 loopback
  address.
  
  =head2 is_multicast_ip($ip)
  
  This subroutine checks whether the address belongs to the IPv4 or IPv6
  multicast network.
  
  =head2 is_private_ip($ip)
  
  This subroutine checks whether the address belongs to the IPv4 or IPv6 private
  network.
  
  =for Pod::Coverage new
  
  =head1 OBJECT-ORIENTED INTERFACE
  
  This module can also be used as a class. You can call C<<
  Data::Validate::IP->new() >> to get an object and then call any of the
  validation subroutines as methods on that object. This is somewhat pointless
  since the object will never contain any state but this interface is kept for
  backwards compatibility.
  
  =head1 SEE ALSO
  
  IPv4
  
  B<[RFC 5735] [RFC 1918]>
  
  IPv6
  
  B<[RFC 2460] [RFC 4193] [RFC 4291] [RFC 6434]>
  
  =head1 ACKNOWLEDGEMENTS
  
  Thanks to Richard Sonnen <F<sonnen@richardsonnen.com>> for writing the
  Data::Validate module.
  
  Thanks to Matt Dainty <F<matt@bodgit-n-scarper.com>> for adding the
  C<is_multicast_ipv4()> and C<is_linklocal_ipv4()> code.
  
  =head1 BUGS
  
  Please report any bugs or feature requests to
  C<bug-data-validate-ip@rt.cpan.org>, or through the web interface at
  L<http://rt.cpan.org>. I will be notified, and then you'll automatically be
  notified of progress on your bug as I make changes.
  
  Bugs may be submitted at L<https://github.com/houseabsolute/Data-Validate-IP/issues>.
  
  =head1 SOURCE
  
  The source code repository for Data-Validate-IP can be found at L<https://github.com/houseabsolute/Data-Validate-IP>.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Neil Neely <neil@neely.cx>
  
  =item *
  
  Dave Rolsky <autarch@urth.org>
  
  =back
  
  =head1 CONTRIBUTOR
  
  =for stopwords Gregory Oschwald
  
  Gregory Oschwald <goschwald@maxmind.com>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2022 by Neil Neely.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  The full text of the license can be found in the
  F<LICENSE> file included with this distribution.
  
  =cut
DATA_VALIDATE_IP

$fatpacked{"Data/Validate/URI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DATA_VALIDATE_URI';
  package Data::Validate::URI;
  
  use strict;
  use vars qw($VERSION @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS);
  
  require Exporter;
  use AutoLoader 'AUTOLOAD';
  
  use Data::Validate::Domain;
  use Data::Validate::IP;
  
  @ISA = qw(Exporter);
  
  
  
  # no functions are exported by default.  See EXPORT_OK
  @EXPORT = qw();
  
  @EXPORT_OK = qw(
  		is_uri
  		is_http_uri
  		is_https_uri
  		is_web_uri
  		is_tel_uri
  );
  
  %EXPORT_TAGS = ();
  
  $VERSION = '0.07';
  
  
  # No preloads
  
  1;
  __END__
  
  =head1 NAME
  
  Data::Validate::URI - common url validation methods
  
  =head1 SYNOPSIS
  
    use Data::Validate::URI qw(is_uri);
    
    if(is_uri($suspect)){
    	print "Looks like an URI\n";
    } else {
    	print "Not a URI\n";
    }
  
    # or as an object
    my $v = Data::Validate::URI->new();
    
    die "not a URI" unless ($v->is_uri('foo'));
  
  =head1 DESCRIPTION
  
  This module collects common URI validation routines to make input validation,
  and untainting easier and more readable. 
  
  All functions return an untainted value if the test passes, and undef if
  it fails.  This means that you should always check for a defined status explicitly.
  Don't assume the return will be true.
  
  The value to test is always the first (and often only) argument.
  
  There are a number of other URI validation modules out there as well (see below.)
  This one focuses on being fast, lightweight, and relatively 'real-world'.  i.e.
  it's good if you want to check user input, and don't need to parse out the URI/URL
  into chunks.
  
  Right now the module focuses on HTTP URIs, since they're arguably the most common.
  If you have a specialized scheme you'd like to have supported, let me know.
  
  =head1 FUNCTIONS
  
  =cut
  
  # -------------------------------------------------------------------------------
  
  =pod
  
  =over 4
  
  =item B<new> - constructor for OO usage
  
    new(%options);
  
  =over 4
  
  =item I<Description>
  
  Returns a Data::Validator::URI object.  This lets you access all the validator function
  calls as methods without importing them into your namespace or using the clumsy
  Data::Validate::URI::function_name() format.
  
  =item I<Arguments>
  
  =over 4
  
  =item %options
  
  Options to be passed into the underlying Data::Validate::Domain module
  
  =back
  
  =item I<Returns>
  
  Returns a Data::Validate::URI object
  
  =back
  
  =cut
  
  sub new{
  	my $class = shift;
  	
  	return bless {@_}, $class;
  }
  
  # -------------------------------------------------------------------------------
  
  =pod
  
  =item B<is_uri> - is the value a well-formed uri?
  
    is_uri($value);
  
  =over 4
  
  =item I<Description>
  
  Returns the untainted URI if the test value appears to be well-formed.  Note that
  you may really want one of the more practical methods like is_http_uri or is_https_uri,
  since the URI standard (RFC 3986) allows a lot of things you probably don't want.
  
  =item I<Arguments>
  
  =over 4
  
  =item $value
  
  The potential URI to test.
  
  =back
  
  =item I<Returns>
  
  Returns the untainted URI on success, undef on failure.
  
  =item I<Notes, Exceptions, & Bugs>
  
  This function does not make any attempt to check whether the URI is accessible
  or 'makes sense' in any meaningful way.  It just checks that it is formatted
  correctly.
  
  =back
  
  =cut
  
  sub is_uri{
  	my $self = shift if ref($_[0]); 
  	my $value = shift;
  	
  	return unless defined($value);
  	
  	# check for illegal characters
  	return if $value =~ /[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i;
  	
  	# check for hex escapes that aren't complete
  	return if $value =~ /%[^0-9a-f]/i;
  	return if $value =~ /%[0-9a-f](:?[^0-9a-f]|$)/i;
  	
  	# from RFC 3986
  	my($scheme, $authority, $path, $query, $fragment) = _split_uri($value);
  	
  	# scheme and path are required, though the path can be empty
  	return unless (defined($scheme) && length($scheme) && defined($path));
  	
  	# if authority is present, the path must be empty or begin with a /
  	if(defined($authority) && length($authority)){
  		return unless(length($path) == 0 || $path =~ m!^/!);
  	
  	} else {
  		# if authority is not present, the path must not start with //
  		return if $path =~ m!^//!;
  	}
  	
  	# scheme must begin with a letter, then consist of letters, digits, +, ., or -
  	return unless lc($scheme) =~ m!^[a-z][a-z0-9\+\-\.]*$!;
  	
  	# re-assemble the URL per section 5.3 in RFC 3986
  	my $out = $scheme . ':';
  	if(defined $authority && length($authority)){
  		$out .= '//' . $authority;
  	}
  	$out .= $path;
  	if(defined $query && length($query)){
  		$out .= '?' . $query;
  	}
  	if(defined $fragment && length($fragment)){
  		$out .= '#' . $fragment;
  	}
  	
  	return $out;
  	
  }
  
  # -------------------------------------------------------------------------------
  
  sub _test_uri {
  	# 1 = HTTP only
  	# 2 = HTTPS only
  	# 3 = both HTTP and HTTPS are allowed
  	my $allowed_scheme = shift;
  	my $value = shift;
  	my $options = shift // {};
  	
  	return unless is_uri($value);
  	
  	my($scheme, $authority, $path, $query, $fragment) = _split_uri($value);
  	
  	return unless $scheme;
  	
  	if($allowed_scheme == 1) {
  		return unless lc($scheme) eq 'http';
  	} elsif ($allowed_scheme == 2) {
  		return unless lc($scheme) eq 'https'
  	} elsif ($allowed_scheme == 3) {
  		return unless lc($scheme) =~ m/^https?$/;
  	} else {
  		return;
  	}
  	
  	# fully-qualified URIs must have an authority section that is
  	# a valid host
  	return unless($authority);
  	
  	# allow a port component
  	my($port) = $authority =~ /:(\d+)$/;
  	$authority =~ s/:\d+$//;
  	
  	# modifying this to allow the (discouraged, but still legal) use of IP addresses
  	unless(Data::Validate::Domain::is_domain($authority, $options) || Data::Validate::IP::is_ipv4($authority)){
  		return;
  	}
  	
  	# re-assemble the URL per section 5.3 in RFC 3986
  	my $out = $scheme . ':';
  	$out .= '//' . $authority;
  	
  	$out .= ':' . $port if $port;
  	
  	$out .= $path;
  	
  	if(defined $query && length($query)){
  		$out .= '?' . $query;
  	}
  	if(defined $fragment && length($fragment)){
  		$out .= '#' . $fragment;
  	}
  	
  	return $out;
  }
  
  =pod
  
  =item B<is_http_uri> - is the value a well-formed HTTP uri?
  
    is_http_uri($value, \%options);
  
  =over 4
  
  =item I<Description>
  
  Specialized version of is_uri() that only likes http:// urls.  As a result, it can
  also do a much more thorough job validating.  Also, unlike is_uri() it is more
  concerned with only allowing real-world URIs through.  Things like relative
  hostnames are allowed by the standards, but probably aren't wise.  Conversely,
  null paths aren't allowed per RFC 2616 (should be '/' instead), but are allowed
  by this function.
  
  This function only works for fully-qualified URIs.  /bob.html won't work.  
  See RFC 3986 for the appropriate method to turn a relative URI into an absolute 
  one given its context.
  
  Returns the untainted URI if the test value appears to be well-formed.
  
  Note that you probably want to either call this in combo with is_https_uri(). i.e.
  
  print "Good" if(is_http_uri($uri) || is_https_uri($uri));
  
  or use the convenience method is_web_uri which is equivalent and faster, because
  it does the work only once.
  
  =item I<Arguments>
  
  =over 4
  
  =item $value
  
  The potential URI to test.
  
  =item \%options
  
  Options to be passed into the underlying Data::Validate::Domain module. If
  called as a method, the options are ignored.
  
  =back
  
  =item I<Returns>
  
  Returns the untainted URI on success, undef on failure.
  
  =item I<Notes, Exceptions, & Bugs>
  
  This function does not make any attempt to check whether the URI is accessible
  or 'makes sense' in any meaningful way.  It just checks that it is formatted
  correctly.
  
  =back
  
  =cut
  
  sub is_http_uri{
  	my $self = shift if ref($_[0]);
  	my $value = shift;
  	$self //= shift;
  
  	return _test_uri(1, $value, $self);
  }
  
  
  # -------------------------------------------------------------------------------
  
  =pod
  
  =item B<is_https_uri> - is the value a well-formed HTTPS uri?
  
    is_https_uri($value. \%options);
  
  =over 4
  
  =item I<Description>
  
  See is_http_uri() for details.  This version only likes the https URI scheme.
  Otherwise it's identical to is_http_uri()
  
  =item I<Arguments>
  
  =over 4
  
  =item $value
  
  The potential URI to test.
  
  =item \%options
  
  Options to be passed into the underlying Data::Validate::Domain module. If
  called as a method, the options are ignored.
  
  =back
  
  =item I<Returns>
  
  Returns the untainted URI on success, undef on failure.
  
  =item I<Notes, Exceptions, & Bugs>
  
  This function does not make any attempt to check whether the URI is accessible
  or 'makes sense' in any meaningful way.  It just checks that it is formatted
  correctly.
  
  =back
  
  =cut
  
  sub is_https_uri{
  	my $self = shift if ref($_[0]); 
  	my $value = shift;
  	$self //= shift;
  	
  	return _test_uri(2, $value, $self);
  }
  
  
  # -------------------------------------------------------------------------------
  
  =pod
  
  =item B<is_web_uri> - is the value a well-formed HTTP or HTTPS uri?
  
    is_web_uri($value, \%options);
  
  =over 4
  
  =item I<Description>
  
  This is just a convinience method that combines is_http_uri and is_https_uri
  to accept most common real-world URLs. But it's faster, because it does the
  work only once.
  
  =item I<Arguments>
  
  =over 4
  
  =item $value
  
  The potential URI to test.
  
  =item \%options
  
  Options to be passed into the underlying Data::Validate::Domain module. If
  called as a method, the options are ignored.
  
  =back
  
  =item I<Returns>
  
  Returns the untainted URI on success, undef on failure.
  
  =item I<Notes, Exceptions, & Bugs>
  
  This function does not make any attempt to check whether the URI is accessible
  or 'makes sense' in any meaningful way.  It just checks that it is formatted
  correctly.
  
  =back
  
  =cut
  
  sub is_web_uri{
  	my $self = shift if ref($_[0]); 
  	my $value = shift;
  	$self //= shift;
  
  	return _test_uri(3, $value, $self);
  }
  
  # -------------------------------------------------------------------------------
  
  =pod
  
  =item B<is_tel_uri> - is the value a well-formed telephone uri?
  
    is_tel_uri($value);
  
  =over 4
  
  =item I<Description>
  
  Specialized version of is_uri() that only likes tel: urls.  As a result, it can
  also do a much more thorough job validating according to RFC 3966.
  
  Returns the untainted URI if the test value appears to be well-formed.
  
  =item I<Arguments>
  
  =over 4
  
  =item $value
  
  The potential URI to test.
  
  =back
  
  =item I<Returns>
  
  Returns the untainted URI on success, undef on failure.
  
  =item I<Notes, Exceptions, & Bugs>
  
  This function does not make any attempt to check whether the URI is accessible
  or 'makes sense' in any meaningful way.  It just checks that it is formatted
  correctly.
  
  =back
  
  =cut
  
  sub is_tel_uri{
  	my $self = shift if ref($_[0]); 
  	my $value = shift;
  	
  	# extracted from http://tools.ietf.org/html/rfc3966#section-3
  
  	my $hex_digit = '[a-fA-F0-9]'; # strictly hex digit does not allow lower case letters according to http://tools.ietf.org/html/rfc2234#section-6.1
  	my $reserved = '[;/?:@&=+$,]';
  	my $alphanum = '[A-Za-z0-9]';
  	my $visual_separator = '[\-\.\(\)]';
  	my $phonedigit_hex = '(?:' . $hex_digit . '|\*|\#|' . $visual_separator . ')';
  	my $phonedigit = '(?:' . '\d' . '|' . $visual_separator . ')';
  	my $param_unreserved = '[\[\]\/:&+$]';
  	my $pct_encoded = '\\%' . $hex_digit . $hex_digit;
  	my $mark = "[\-_\.!~*'()]";
  	my $unreserved = '(?:' . $alphanum . '|' . $mark . ')';
  	my $paramchar = '(?:' . $param_unreserved . '|' . $unreserved . '|' . $pct_encoded . ')';
  	my $pvalue = $paramchar . '{1,}';
  	my $pname = '(?:' . $alphanum . '|\\-){1,}';
  	my $uric = '(?:' . $reserved . '|' . $unreserved . '|' . $pct_encoded . ')';
  	my $alpha = '[A-Za-z]';
  	my $toplabel = '(?:' . $alpha . '|' . $alpha . '(?:' . $alphanum . '|' . '\\-){0,}' . $alpha . ')';
  	my $domainlabel = '(?:' . $alphanum . '|' . $alphanum . '(?:' . $alphanum . '|\\-){0,}' . $alphanum . ')';
  	my $domainname = '(?:' . $domainlabel . '\\.){0,}' . $toplabel . '\\.{0,1}';
  
  	# extracted from http://tools.ietf.org/html/rfc4694#section-4
  	my $npdi = ';npdi';
  	my $hex_phonedigit = '(?:' . $hex_digit . '|' . $visual_separator . ')';
  	my $global_hex_digits = '\\+' . '\\d{1,3}' . $hex_phonedigit . '{0,}';
  	my $global_rn = $global_hex_digits;
  	my $rn_descriptor = '(?:' . $domainname . '|' . $global_hex_digits . ')';
  	my $rn_context = ';rn-context=' . $rn_descriptor;
  	my $local_rn = $hex_phonedigit . '{1,}' . $rn_context;
  	my $global_cic = $global_hex_digits;
  	my $cic_context = ';cic-context=' . $rn_descriptor;
  	my $local_cic = $hex_phonedigit . '{1,}' . $cic_context;
  	my $cic = ';cic=' . '(?:' . $global_cic . '|' . $local_cic . '){0,1}';
  	my $rn = ';rn=' . '(?:' . $global_rn . '|' . $local_rn . '){0,1}';
  
  	if ($value =~ /$rn.*$rn/xsm) {
  		return;
  	}
  	if ($value =~ /$npdi.*$npdi/xsm) {
  		return;
  	}
  	if ($value =~ /$cic.*$cic/xsm) {
  		return;
  	}
  	my $parameter = '(?:;' . $pname . '(?:=' . $pvalue . ')|' . $rn . '|' . $cic . '|' . $npdi . ')';
  
  	# end of http://tools.ietf.org/html/rfc4694#section-4
  
  	my $local_number_digits = '(?:' . $phonedigit_hex . '{0,}' . '(?:' . $hex_digit . '|\*|\#)' . $phonedigit_hex . '{0,})';
  	my $global_number_digits = '\+' . $phonedigit . '{0,}' . '[0-9]' . $phonedigit . '{0,}';
  	my $descriptor = '(?:' . $domainname . '|' . $global_number_digits . ')';
  	my $context = ';phone\-context=' . $descriptor;
  	my $extension = ';ext=' . $phonedigit . '{1,}';
  	my $isdn_subaddress = ';isub=' . $uric . '{1,}';
  
  	# extracted from http://tools.ietf.org/html/rfc4759
  	my $enum_dip_indicator = ';enumdi';
  	if ($value =~ /$enum_dip_indicator.*$enum_dip_indicator/xsm) { # http://tools.ietf.org/html/rfc4759#section-3
  		return;
  	}
  
  	# extracted from http://tools.ietf.org/html/rfc4904#section-5
  	my $trunk_group_unreserved = '[/&+$]';
  	my $escaped = '\\%' . $hex_digit . $hex_digit; # according to http://tools.ietf.org/html/rfc3261#section-25.1
  	my $trunk_group_label = '(?:' . $unreserved . '|' . $escaped . '|' . $trunk_group_unreserved . '){1,}';
  	my $trunk_group = ';tgrp=' . $trunk_group_label; 
  	my $trunk_context = ';trunk\-context=' . $descriptor;
  
  
  	my $par = '(?:' . $parameter . '|' . $extension . '|' . $isdn_subaddress . '|' . $enum_dip_indicator . '|' . $trunk_context . '|' . $trunk_group . ')';
  	my $local_number = $local_number_digits . $par . '{0,}' . $context . $par . '{0,}';
  	my $global_number = $global_number_digits . $par . '{0,}';
  	my $telephone_subscriber = '(?:' . $global_number . '|' . $local_number . ')';
  	my $telephone_uri = 'tel:' . $telephone_subscriber;
  
  	if ($value =~ /^($telephone_uri)$/xsm) {
  		my ($untainted) = ($1);
  		return $untainted;
  	} else {
  		return;
  	}
  }
  
  # internal URI spitter method - direct from RFC 3986
  sub _split_uri{
  	my $value = shift;
  	
  	my @bits = $value =~ m|(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?|;
  	
  	return @bits;
  }
  	
  
  =pod
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, RFC 3986, RFC 3966, RFC 4694, RFC 4759, RFC 4904
  
  =head1 AUTHOR
  
  Richard Sonnen <F<sonnen@richardsonnen.com>>.
  
  is_tel_uri by David Dick <F<ddick@cpan.org>>.
  
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005 Richard Sonnen. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
DATA_VALIDATE_URI

$fatpacked{"Net/Domain/TLD.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'NET_DOMAIN_TLD';
  package Net::Domain::TLD;
  use strict;
  use base qw( Exporter );
  use 5.006;
  our @EXPORT_OK = qw( tlds tld_exists %tld_profile );
  our $VERSION = '1.75';
  
  use warnings;
  use Carp;
  use Storable qw ( dclone );
  
  use constant TLD_TYPES => qw ( new_open new_restricted gtld_open gtld_restricted gtld_new cc ccidn );
  
  =head1 NAME
  
    Net::Domain::TLD - Work with TLD names 
  
  =head1 SYNOPSIS
  
    use Net::Domain::TLD qw(tlds tld_exists);
    my @ccTLDs = tlds('cc');
    print "TLD ok\n" if tld_exists('ac','cc');
  
  =head1 DESCRIPTION
  
    The purpose of this module is to provide user with current list of 
    available top level domain names including new ICANN additions and ccTLDs
    Currently TLD definitions have been acquired from the following sources:
  
    http://www.icann.org/tlds/
    http://www.dnso.org/constituency/gtld/gtld.html
    http://www.iana.org/cctld/cctld-whois.htm
    https://www.iana.org/domains/root/db
  
  =cut
  
  my %tld_profile = (
    reserved => {
      test => q{DNS testing names},
      example => q{Documentation names},
      invalid => q{Invalid names},
      localhost => q{Loopback names}
    },
    new_open => {
      info => q{Unrestricted use},
      xxx => q{sponsored top-level domain}
    },
    new_restricted => { 
      aero => q{Air-transport industry},
      asia => q{Companies, organisations and individuals in the Asia-Pacific region},
      arpa => q{Address and Routing Parameter Area},
      biz => q{Businesses},
      cat => q{Catalan linguistic and cultural community},
      coop => q{Cooperatives},
      jobs => q{Human Resource Management},
      mobi => q{Mobile},
      museum => q{Museums},
      name => q{For registration by individuals},
      post => q{Universal Postal Union},
      pro => q{Accountants, lawyers, and physicians},
      travel => q{Travel industry},
      tel => q{For businesses and individuals to publish contact data}
    },
    gtld_open => {
      com => q{Commercial organization},
      net => q{Network connection services provider},
      org => q{Non-profit organizations and industry standard groups}
    },
    gtld_restricted => {
      gov => q{United States Government},
      mil => q{United States Military},
      edu => q{Educational institution},
      int => q{International treaties/databases},
    },
    cc => {
      ac => q{Ascension Island},
      ad => q{Andorra},
      ae => q{United Arab Emirates},
      af => q{Afghanistan},
      ag => q{Antigua and Barbuda},
      ai => q{Anguilla},
      al => q{Albania},
      am => q{Armenia},
      an => q{Netherlands Antilles},
      ao => q{Angola},
      aq => q{Antartica},
      ar => q{Argentina},
      as => q{American Samoa},
      at => q{Austria},
      au => q{Australia},
      aw => q{Aruba},
      ax => q(Aland Islands),
      az => q{Azerbaijan},
      ba => q{Bosnia and Herzegovina},
      bb => q{Barbados},
      bd => q{Bangladesh},
      be => q{Belgium},
      bf => q{Burkina Faso},
      bg => q{Bulgaria},
      bh => q{Bahrain},
      bi => q{Burundi},
      bj => q{Benin},
      bl => q(Saint Barthelemy),
      bm => q{Bermuda},
      bn => q{Brunei Darussalam},
      bo => q{Bolivia},
      bq => q{Not assigned},
      br => q{Brazil},
      bs => q{Bahamas},
      bt => q{Bhutan},
      bv => q{Bouvet Island},
      bw => q{Botswana},
      by => q{Belarus},
      bz => q{Belize},
      ca => q{Canada},
      cc => q{Cocos (Keeling) Islands},
      cd => q{Congo, Democratic Republic of the},
      cf => q{Central African Republic},
      cg => q{Congo, Republic of},
      ch => q{Switzerland},
      ci => q{Cote d'Ivoire},
      ck => q{Cook Islands},
      cl => q{Chile},
      cm => q{Cameroon},
      cn => q{China},
      co => q{Colombia},
      cr => q{Costa Rica},
      cu => q{Cuba},
      cv => q{Cap Verde},
      cw => q{University of the Netherlands Antilles},
      cx => q{Christmas Island},
      cy => q{Cyprus},
      cz => q{Czech Republic},
      de => q{Germany},
      dj => q{Djibouti},
      dk => q{Denmark},
      dm => q{Dominica},
      do => q{Dominican Republic},
      dz => q{Algeria},
      ec => q{Ecuador},
      ee => q{Estonia},
      eg => q{Egypt},
      eh => q{Western Sahara},
      er => q{Eritrea},
      es => q{Spain},
      et => q{Ethiopia},
      eu => q{European Union},
      fi => q{Finland},
      fj => q{Fiji},
      fk => q{Falkland Islands (Malvina)},
      fm => q{Micronesia, Federal State of},
      fo => q{Faroe Islands},
      fr => q{France},
      ga => q{Gabon},
      gb => q{United Kingdom},
      gd => q{Grenada},
      ge => q{Georgia},
      gf => q{French Guiana},
      gg => q{Guernsey},
      gh => q{Ghana},
      gi => q{Gibraltar},
      gl => q{Greenland},
      gm => q{Gambia},
      gn => q{Guinea},
      gp => q{Guadeloupe},
      gq => q{Equatorial Guinea},
      gr => q{Greece},
      gs => q{South Georgia and the South Sandwich Islands},
      gt => q{Guatemala},
      gu => q{Guam},
      gw => q{Guinea-Bissau},
      gy => q{Guyana},
      hk => q{Hong Kong},
      hm => q{Heard and McDonald Islands},
      hn => q{Honduras},
      hr => q{Croatia/Hrvatska},
      ht => q{Haiti},
      hu => q{Hungary},
      id => q{Indonesia},
      ie => q{Ireland},
      il => q{Israel},
      im => q{Isle of Man},
      in => q{India},
      io => q{British Indian Ocean Territory},
      iq => q{Iraq},
      ir => q{Iran (Islamic Republic of)},
      is => q{Iceland},
      it => q{Italy},
      je => q{Jersey},
      jm => q{Jamaica},
      jo => q{Jordan},
      jp => q{Japan},
      ke => q{Kenya},
      kg => q{Kyrgyzstan},
      kh => q{Cambodia},
      ki => q{Kiribati},
      km => q{Comoros},
      kn => q{Saint Kitts and Nevis},
      kp => q{Korea, Democratic People's Republic},
      kr => q{Korea, Republic of},
      kw => q{Kuwait},
      ky => q{Cayman Islands},
      kz => q{Kazakhstan},
      la => q{Lao People's Democratic Republic},
      lb => q{Lebanon},
      lc => q{Saint Lucia},
      li => q{Liechtenstein},
      lk => q{Sri Lanka},
      lr => q{Liberia},
      ls => q{Lesotho},
      lt => q{Lithuania},
      lu => q{Luxembourg},
      lv => q{Latvia},
      ly => q{Libyan Arab Jamahiriya},
      ma => q{Morocco},
      mc => q{Monaco},
      md => q{Moldova, Republic of},
      me => q(Montenegro),
      mf => q{Saint Martin (French part)},
      mg => q{Madagascar},
      mh => q{Marshall Islands},
      mk => q{Macedonia, Former Yugoslav Republic},
      ml => q{Mali},
      mm => q{Myanmar},
      mn => q{Mongolia},
      mo => q{Macau},
      mp => q{Northern Mariana Islands},
      mq => q{Martinique},
      mr => q{Mauritania},
      ms => q{Montserrat},
      mt => q{Malta},
      mu => q{Mauritius},
      mv => q{Maldives},
      mw => q{Malawi},
      mx => q{Mexico},
      my => q{Malaysia},
      mz => q{Mozambique},
      na => q{Namibia},
      nc => q{New Caledonia},
      ne => q{Niger},
      nf => q{Norfolk Island},
      ng => q{Nigeria},
      ni => q{Nicaragua},
      nl => q{Netherlands},
      no => q{Norway},
      np => q{Nepal},
      nr => q{Nauru},
      nu => q{Niue},
      nz => q{New Zealand},
      om => q{Oman},
      pa => q{Panama},
      pe => q{Peru},
      pf => q{French Polynesia},
      pg => q{Papua New Guinea},
      ph => q{Philippines},
      pk => q{Pakistan},
      pl => q{Poland},
      pm => q{St. Pierre and Miquelon},
      pn => q{Pitcairn Island},
      pr => q{Puerto Rico},
      ps => q{Palestinian Territories},
      pt => q{Portugal},
      pw => q{Palau},
      py => q{Paraguay},
      qa => q{Qatar},
      re => q{Reunion Island},
      ro => q{Romania},
      rs => q(Serbia),
      ru => q{Russian Federation},
      rw => q{Rwanda},
      sa => q{Saudi Arabia},
      sb => q{Solomon Islands},
      sc => q{Seychelles},
      sd => q{Sudan},
      se => q{Sweden},
      sg => q{Singapore},
      sh => q{St. Helena},
      si => q{Slovenia},
      sj => q{Svalbard and Jan Mayen Islands},
      sk => q{Slovak Republic},
      sl => q{Sierra Leone},
      sm => q{San Marino},
      sn => q{Senegal},
      so => q{Somalia},
      sr => q{Suriname},
      ss => q{Not assigned},
      st => q{Sao Tome and Principe},
      su => q{Soviet Union},
      sv => q{El Salvador},
      sx => q{SX Registry SA B.V.},
      sy => q{Syrian Arab Republic},
      sz => q{Swaziland},
      tc => q{Turks and Caicos Islands},
      td => q{Chad},
      tf => q{French Southern Territories},
      tg => q{Togo},
      th => q{Thailand},
      tj => q{Tajikistan},
      tk => q{Tokelau},
      tl => q{Timor-Leste},
      tm => q{Turkmenistan},
      tn => q{Tunisia},
      to => q{Tonga},
      tp => q{East Timor},
      tr => q{Turkey},
      tt => q{Trinidad and Tobago},
      tv => q{Tuvalu},
      tw => q{Taiwan},
      tz => q{Tanzania},
      ua => q{Ukraine},
      ug => q{Uganda},
      uk => q{United Kingdom},
      um => q{US Minor Outlying Islands},
      us => q{United States},
      uy => q{Uruguay},
      uz => q{Uzbekistan},
      va => q{Holy See (City Vatican State)},
      vc => q{Saint Vincent and the Grenadines},
      ve => q{Venezuela},
      vg => q{Virgin Islands (British)},
      vi => q{Virgin Islands (USA)},
      vn => q{Vietnam},
      vu => q{Vanuatu},
      wf => q{Wallis and Futuna Islands},
      ws => q{Western Samoa},
      ye => q{Yemen},
      yt => q{Mayotte},
      yu => q{Yugoslavia},
      za => q{South Africa},
      zm => q{Zambia},
      zw => q{Zimbabwe}
    },
    ccidn => {
      'xn--0zwm56d' => q{Internet Assigned Numbers Authority},
      'xn--11b5bs3a9aj6g' => q{Internet Assigned Numbers Authority},
      'xn--1qqw23a' => q{Guangzhou YU Wei Information Technology Co., Ltd.},
      'xn--3bst00m' => q{Eagle Horizon Limited},
      'xn--3ds443g' => q{TLD REGISTRY LIMITED},
      'xn--3e0b707e' => q{KISA (Korea Internet & Security Agency)},
      'xn--45brj9c' => q{National Internet Exchange of India},
      'xn--45q11c' => q{Zodiac Scorpio Limited},
      'xn--4gbrim' => q{Suhub Electronic Establishment},
      'xn--54b7fta0cc' => q{Not assigned},
      'xn--55qw42g' => q{China Organizational Name Administration Center},
      'xn--55qx5d' => q{Computer Network Information Center of Chinese Academy of Sciences ï¼ˆChina Internet Network Information Centerï¼‰},
      'xn--6frz82g' => q{Afilias Limited},
      'xn--6qq986b3xl' => q{Tycoon Treasure Limited},
      'xn--80adxhks' => q{Foundation for Assistance for Internet Technologies and Infrastructure Development (FAITID)},
      'xn--80akhbyknj4f' => q{Internet Assigned Numbers Authority},
      'xn--80ao21a' => q{Association of IT Companies of Kazakhstan},
      'xn--80asehdb' => q{CORE Association},
      'xn--80aswg' => q{CORE Association},
      'xn--90a3ac' => q{Serbian National Internet Domain Registry (RNIDS)},
      'xn--90ais' => q{Not assigned},
      'xn--9t4b11yi5a' => q{Internet Assigned Numbers Authority},
      'xn--b4w605ferd' => q{Temasek Holdings (Private) Limited},
      'xn--c1avg' => q{Public Interest Registry},
      'xn--cg4bki' => q{SAMSUNG SDS CO., LTD},
      'xn--clchc0ea0b2g2a9gcd' => q{Singapore Network Information Centre (SGNIC) Pte Ltd},
      'xn--czr694b' => q{HU YI GLOBAL INFORMATION RESOURCES(HOLDING) COMPANY.HONGKONG LIMITED},
      'xn--czrs0t' => q{Wild Island, LLC},
      'xn--czru2d' => q{Zodiac Aquarius Limited},
      'xn--d1acj3b' => q{The Foundation for Network Initiatives â€œThe Smart Internetâ€},
      'xn--d1alf' => q{Macedonian Academic Research Network Skopje},
      'xn--deba0ad' => q{Internet Assigned Numbers Authority},
      'xn--fiq228c5hs' => q{TLD REGISTRY LIMITED},
      'xn--fiq64b' => q{CITIC Group Corporation},
      'xn--fiqs8s' => q{China Internet Network Information Center},
      'xn--fiqz9s' => q{China Internet Network Information Center},
      'xn--flw351e' => q{Charleston Road Registry Inc.},
      'xn--fpcrj9c3d' => q{National Internet Exchange of India},
      'xn--fzc2c9e2c' => q{LK Domain Registry},
      'xn--g6w251d' => q{Internet Assigned Numbers Authority},
      'xn--gecrj9c' => q{National Internet Exchange of India},
      'xn--h2brj9c' => q{National Internet Exchange of India},
      'xn--hgbk6aj7f53bba' => q{Internet Assigned Numbers Authority},
      'xn--hlcj6aya9esc7a' => q{Internet Assigned Numbers Authority},
      'xn--hxt814e' => q{Zodiac Libra Limited},
      'xn--i1b6b1a6a2e' => q{Public Interest Registry},
      'xn--io0a7i' => q{Computer Network Information Center of Chinese Academy of Sciences ï¼ˆChina Internet Network Information Centerï¼‰},
      'xn--j1amh' => q{Ukrainian Network Information Centre (UANIC), Inc.},
      'xn--j6w193g' => q{Hong Kong Internet Registration Corporation Ltd.},
      'xn--jxalpdlp' => q{Internet Assigned Numbers Authority},
      'xn--kgbechtv' => q{Internet Assigned Numbers Authority},
      'xn--kprw13d' => q{Taiwan Network Information Center (TWNIC)},
      'xn--kpry57d' => q{Taiwan Network Information Center (TWNIC)},
      'xn--kput3i' => q{Beijing RITT-Net Technology Development Co., Ltd},
      'xn--l1acc' => q{Datacom Co.,Ltd},
      'xn--lgbbat1ad8j' => q{CERIST},
      'xn--mgb9awbf' => q{Telecommunications Regulatory Authority (TRA)},
      'xn--mgba3a4f16a' => q{Institute for Research in Fundamental Sciences (IPM)},
      'xn--mgbaam7a8h' => q{Telecommunications Regulatory Authority (TRA)},
      'xn--mgbab2bd' => q{CORE Association},
      'xn--mgbai9azgqp6j' => q{Not assigned},
      'xn--mgbayh7gpa' => q{National Information Technology Center (NITC)},
      'xn--mgbbh1a71e' => q{National Internet Exchange of India},
      'xn--mgbc0a9azcg' => q{Agence Nationale de Réglementation des Télécommunications (ANRT)},
      'xn--mgberp4a5d4ar' => q{Communications and Information Technology Commission},
      'xn--mgbpl2fh' => q{Not assigned},
      'xn--mgbtx2b' => q{Not assigned},
      'xn--mgbx4cd0ab' => q{MYNIC Berhad},
      'xn--ngbc5azd' => q{International Domain Registry Pty. Ltd.},
      'xn--node' => q{Information Technologies Development Center (ITDC)},
      'xn--nqv7f' => q{Public Interest Registry},
      'xn--nqv7fs00ema' => q{Public Interest Registry},
      'xn--o3cw4h' => q{Thai Network Information Center Foundation},
      'xn--ogbpf8fl' => q{National Agency for Network Services (NANS)},
      'xn--p1acf' => q{Rusnames Limited},
      'xn--p1ai' => q{Coordination Center for TLD RU},
      'xn--pgbs0dh' => q{Agence Tunisienne d'Internet},
      'xn--q9jyb4c' => q{Charleston Road Registry Inc.},
      'xn--qcka1pmc' => q{Charleston Road Registry Inc.},
      'xn--rhqv96g' => q{Stable Tone Limited},
      'xn--s9brj9c' => q{National Internet Exchange of India},
      'xn--ses554g' => q{KNET Co., Ltd},
      'xn--unup4y' => q{Spring Fields, LLC},
      'xn--vermgensberater-ctb' => q{Deutsche Vermögensberatung Aktiengesellschaft DVAG},
      'xn--vermgensberatung-pwb' => q{Deutsche Vermögensberatung Aktiengesellschaft DVAG},
      'xn--vhquv' => q{Dash McCook, LLC},
      'xn--wgbh1c' => q{National Telecommunication Regulatory Authority - NTRA},
      'xn--wgbl6a' => q{Communications Regulatory Authority},
      'xn--xhq521b' => q{Guangzhou YU Wei Information Technology Co., Ltd.},
      'xn--xkc2al3hye2a' => q{LK Domain Registry},
      'xn--xkc2dl3a5ee0h' => q{National Internet Exchange of India},
      'xn--y9a3aq' => q{Not assigned},
      'xn--yfro4i67o' => q{Singapore Network Information Centre (SGNIC) Pte Ltd},
      'xn--ygbi2ammx' => q{Ministry of Telecom & Information Technology (MTIT)},
      'xn--zckzah' => q{Internet Assigned Numbers Authority},
      'xn--zfr164b' => q{China Organizational Name Administration Center},
    },
    gtld_new => {
      '&#x200f;×˜×¢×¡×˜&#x200e;' => q{Internet Assigned Numbers Authority},
      '&#x200f;×§×•×&#x200e;' => q{VeriSign Sarl},
      '&#x200f;Ø¢Ø²Ù…Ø§ÛŒØ´ÛŒ&#x200e;' => q{Internet Assigned Numbers Authority},
      '&#x200f;Ø¥Ø®ØªØ¨Ø§Ø±&#x200e;' => q{Internet Assigned Numbers Authority},
      '&#x200f;Ø§Ø¨ÙˆØ¸Ø¨ÙŠ&#x200e;' => q{Abu Dhabi Systems and Information Centre},
      '&#x200f;Ø§Ø±Ø§Ù…ÙƒÙˆ&#x200e;' => q{Aramco Services Company},
      '&#x200f;Ø§Ù„Ø§Ø±Ø¯Ù†&#x200e;' => q{National Information Technology Center (NITC)},
      '&#x200f;Ø§Ù„Ø¬Ø²Ø§Ø¦Ø±&#x200e;' => q{CERIST},
      '&#x200f;Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ©&#x200e;' => q{Communications and Information Technology Commission},
      '&#x200f;Ø§Ù„Ø¹Ù„ÙŠØ§Ù†&#x200e;' => q{Crescent Holding GmbH},
      '&#x200f;Ø§Ù„Ù…ØºØ±Ø¨&#x200e;' => q{Agence Nationale de RÃ©glementation des TÃ©lÃ©communications (ANRT)},
      '&#x200f;Ø§Ù…Ø§Ø±Ø§Øª&#x200e;' => q{Telecommunications Regulatory Authority (TRA)},
      '&#x200f;Ø§ÛŒØ±Ø§Ù†&#x200e;' => q{Institute for Research in Fundamental Sciences (IPM)},
      '&#x200f;Ø¨Ø§Ø±Øª&#x200e;' => q{Not assigned},
      '&#x200f;Ø¨Ø§Ø²Ø§Ø±&#x200e;' => q{CORE Association},
      '&#x200f;Ø¨ÙŠØªÙƒ&#x200e;' => q{Kuwait Finance House},
      '&#x200f;Ø¨Ú¾Ø§Ø±Øª&#x200e;' => q{National Internet Exchange of India},
      '&#x200f;ØªÙˆÙ†Ø³&#x200e;' => q{Agence Tunisienne d&#39;Internet},
      '&#x200f;Ø³ÙˆØ¯Ø§Ù†&#x200e;' => q{Sudan Internet Society},
      '&#x200f;Ø³ÙˆØ±ÙŠØ©&#x200e;' => q{National Agency for Network Services (NANS)},
      '&#x200f;Ø´Ø¨ÙƒØ©&#x200e;' => q{International Domain Registry Pty. Ltd.},
      '&#x200f;Ø¹Ø±Ø§Ù‚&#x200e;' => q{Communications and Media Commission (CMC)},
      '&#x200f;Ø¹Ù…Ø§Ù†&#x200e;' => q{Telecommunications Regulatory Authority (TRA)},
      '&#x200f;ÙÙ„Ø³Ø·ÙŠÙ†&#x200e;' => q{Ministry of Telecom &amp; Information Technology (MTIT)},
      '&#x200f;Ù‚Ø·Ø±&#x200e;' => q{Communications Regulatory Authority},
      '&#x200f;ÙƒÙˆÙ…&#x200e;' => q{VeriSign Sarl},
      '&#x200f;Ù…ØµØ±&#x200e;' => q{National Telecommunication Regulatory Authority - NTRA},
      '&#x200f;Ù…Ù„ÙŠØ³ÙŠØ§&#x200e;' => q{MYNIC Berhad},
      '&#x200f;Ù…ÙˆØ¨Ø§ÙŠÙ„ÙŠ&#x200e;' => q{GreenTech Consultancy Company W.L.L.},
      '&#x200f;Ù…ÙˆÙ‚Ø¹&#x200e;' => q{Suhub Electronic Establishment},
      '&#x200f;Ù‡Ù…Ø±Ø§Ù‡&#x200e;' => q{Asia Green IT System Bilgisayar San. ve Tic. Ltd. Sti.},
      '&#x200f;Ù¾Ø§Ú©Ø³ØªØ§Ù†&#x200e;' => q{Not assigned},
      '&#x200f;Ú€Ø§Ø±Øª&#x200e;' => q{Not assigned},
      'aaa' => q{American Automobile Association, Inc.},
      'aarp' => q{AARP},
      'abarth' => q{Fiat Chrysler Automobiles N.V.},
      'abb' => q{ABB Ltd},
      'abbott' => q{Abbott Laboratories, Inc.},
      'abbvie' => q{AbbVie Inc.},
      'abc' => q{Disney Enterprises, Inc.},
      'able' => q{Able Inc.},
      'abogado' => q{Top Level Domain Holdings Limited},
      'abudhabi' => q{Abu Dhabi Systems and Information Centre},
      'ac' => q{Network Information Center (AC Domain Registry) - c/o Cable and Wireless (Ascension Island)},
      'academy' => q{Half Oaks, LLC},
      'accenture' => q{Accenture plc},
      'accountant' => q{dot Accountant Limited},
      'accountants' => q{Knob Town, LLC},
      'aco' => q{ACO Severin Ahlmann GmbH &amp; Co. KG},
      'active' => q{The Active Network, Inc},
      'actor' => q{United TLD Holdco Ltd.},
      'ad' => q{Andorra Telecom},
      'adac' => q{Allgemeiner Deutscher Automobil-Club e.V. (ADAC)},
      'ads' => q{Charleston Road Registry Inc.},
      'adult' => q{ICM Registry AD LLC},
      'ae' => q{Telecommunication Regulatory Authority (TRA)},
      'aeg' => q{Aktiebolaget Electrolux},
      'aero' => q{Societe Internationale de Telecommunications Aeronautique (SITA INC USA)},
      'aetna' => q{Aetna Life Insurance Company},
      'af' => q{Ministry of Communications and IT},
      'afamilycompany' => q{Johnson Shareholdings, Inc.},
      'afl' => q{Australian Football League},
      'ag' => q{UHSA School of Medicine},
      'agakhan' => q{Fondation Aga Khan (Aga Khan Foundation)},
      'agency' => q{Steel Falls, LLC},
      'ai' => q{Government of Anguilla},
      'aig' => q{American International Group, Inc.},
      'aigo' => q{aigo Digital Technology Co,Ltd.},
      'airbus' => q{Airbus S.A.S.},
      'airforce' => q{United TLD Holdco Ltd.},
      'airtel' => q{Bharti Airtel Limited},
      'akdn' => q{Fondation Aga Khan (Aga Khan Foundation)},
      'al' => q{Electronic and Postal Communications Authority - AKEP},
      'alfaromeo' => q{Fiat Chrysler Automobiles N.V.},
      'alibaba' => q{Alibaba Group Holding Limited},
      'alipay' => q{Alibaba Group Holding Limited},
      'allfinanz' => q{Allfinanz Deutsche VermÃ¶gensberatung Aktiengesellschaft},
      'allstate' => q{Allstate Fire and Casualty Insurance Company},
      'ally' => q{Ally Financial Inc.},
      'alsace' => q{REGION D ALSACE},
      'alstom' => q{ALSTOM},
      'am' => q{&quot;Internet Society&quot; Non-governmental Organization},
      'americanexpress' => q{American Express Travel Related Services Company, Inc.},
      'americanfamily' => q{AmFam, Inc.},
      'amex' => q{American Express Travel Related Services Company, Inc.},
      'amfam' => q{AmFam, Inc.},
      'amica' => q{Amica Mutual Insurance Company},
      'amsterdam' => q{Gemeente Amsterdam},
      'an' => q{Retired},
      'analytics' => q{Campus IP LLC},
      'android' => q{Charleston Road Registry Inc.},
      'anquan' => q{QIHOO 360 TECHNOLOGY CO. LTD.},
      'anz' => q{Australia and New Zealand Banking Group Limited},
      'ao' => q{Faculdade de Engenharia da Universidade Agostinho Neto},
      'apartments' => q{June Maple, LLC},
      'app' => q{Charleston Road Registry Inc.},
      'apple' => q{Apple Inc.},
      'aq' => q{Antarctica Network Information Centre Limited},
      'aquarelle' => q{Aquarelle.com},
      'ar' => q{Presidencia de la NaciÃ³n â€“ SecretarÃ­a Legal y TÃ©cnica},
      'aramco' => q{Aramco Services Company},
      'archi' => q{STARTING DOT LIMITED},
      'army' => q{United TLD Holdco Ltd.},
      'arpa' => q{Internet Architecture Board (IAB)},
      'art' => q{UK Creative Ideas Limited},
      'arte' => q{Association Relative Ã  la TÃ©lÃ©vision EuropÃ©enne G.E.I.E.},
      'as' => q{AS Domain Registry},
      'asda' => q{Wal-Mart Stores, Inc.},
      'asia' => q{DotAsia Organisation Ltd.},
      'associates' => q{Baxter Hill, LLC},
      'at' => q{nic.at GmbH},
      'athleta' => q{The Gap, Inc.},
      'attorney' => q{United TLD Holdco, Ltd},
      'au' => q{.au Domain Administration (auDA)},
      'auction' => q{United TLD HoldCo, Ltd.},
      'audi' => q{AUDI Aktiengesellschaft},
      'audible' => q{Amazon Registry Services, Inc.},
      'audio' => q{Uniregistry, Corp.},
      'auspost' => q{Australian Postal Corporation},
      'author' => q{Amazon Registry Services, Inc.},
      'auto' => q{Cars Registry Limited},
      'autos' => q{DERAutos, LLC},
      'avianca' => q{Aerovias del Continente Americano S.A. Avianca},
      'aw' => q{SETAR},
      'aws' => q{Amazon Registry Services, Inc.},
      'ax' => q{Ã…lands landskapsregering},
      'axa' => q{AXA SA},
      'az' => q{IntraNS},
      'azure' => q{Microsoft Corporation},
      'ba' => q{Universtiy Telinformatic Centre (UTIC)},
      'baby' => q{Johnson &amp; Johnson Services, Inc.},
      'baidu' => q{Baidu, Inc.},
      'banamex' => q{Citigroup Inc.},
      'bananarepublic' => q{The Gap, Inc.},
      'band' => q{United TLD Holdco, Ltd},
      'bank' => q{fTLD Registry Services, LLC},
      'bar' => q{Punto 2012 Sociedad Anonima Promotora de Inversion de Capital Variable},
      'barcelona' => q{Municipi de Barcelona},
      'barclaycard' => q{Barclays Bank PLC},
      'barclays' => q{Barclays Bank PLC},
      'barefoot' => q{Gallo Vineyards, Inc.},
      'bargains' => q{Half Hallow, LLC},
      'bauhaus' => q{Werkhaus GmbH},
      'bayern' => q{Bayern Connect GmbH},
      'bb' => q{Government of Barbados - Ministry of Economic Affairs and Development
      Telecommunications Unit},
      'bbc' => q{British Broadcasting Corporation},
      'bbt' => q{BB&amp;T Corporation},
      'bbva' => q{BANCO BILBAO VIZCAYA ARGENTARIA, S.A.},
      'bcg' => q{The Boston Consulting Group, Inc.},
      'bcn' => q{Municipi de Barcelona},
      'bd' => q{Ministry of Post &amp; Telecommunications - Bangladesh Secretariat},
      'be' => q{DNS Belgium vzw/asbl},
      'beats' => q{Beats Electronics, LLC},
      'beauty' => q{L&#39;OrÃ©al},
      'beer' => q{Top Level Domain Holdings Limited},
      'bentley' => q{Bentley Motors Limited},
      'berlin' => q{dotBERLIN GmbH &amp; Co. KG},
      'best' => q{BestTLD Pty Ltd},
      'bestbuy' => q{BBY Solutions, Inc.},
      'bet' => q{Afilias plc},
      'bf' => q{ARCE-AutoritÃˆ de RÃˆgulation des Communications Electroniques},
      'bg' => q{Register.BG},
      'bh' => q{Telecommunications Regulatory Authority (TRA)},
      'bharti' => q{Bharti Enterprises (Holding) Private Limited},
      'bi' => q{Centre National de l&#39;Informatique},
      'bible' => q{American Bible Society},
      'bid' => q{dot Bid Limited},
      'bike' => q{Grand Hollow, LLC},
      'bing' => q{Microsoft Corporation},
      'bingo' => q{Sand Cedar, LLC},
      'bio' => q{STARTING DOT LIMITED},
      'biz' => q{Neustar, Inc.},
      'bj' => q{Benin Telecoms S.A.},
      'bl' => q{Not assigned},
      'black' => q{Afilias Limited},
      'blackfriday' => q{Uniregistry, Corp.},
      'blanco' => q{BLANCO GmbH + Co KG},
      'blockbuster' => q{Dish DBS Corporation},
      'blog' => q{Knock Knock WHOIS There, LLC},
      'bloomberg' => q{Bloomberg IP Holdings LLC},
      'blue' => q{Afilias Limited},
      'bm' => q{Registry General Department, Ministry of Home Affairs},
      'bms' => q{Bristol-Myers Squibb Company},
      'bmw' => q{Bayerische Motoren Werke Aktiengesellschaft},
      'bn' => q{Brunei Darussalam Network Information Centre Sdn Bhd (BNNIC)},
      'bnl' => q{Banca Nazionale del Lavoro},
      'bnpparibas' => q{BNP Paribas},
      'bo' => q{Agencia para el Desarrollo de la InformaciÃ³n de la Sociedad en Bolivia},
      'boats' => q{DERBoats, LLC},
      'boehringer' => q{Boehringer Ingelheim International GmbH},
      'bofa' => q{NMS Services, Inc.},
      'bom' => q{NÃºcleo de InformaÃ§Ã£o e CoordenaÃ§Ã£o do Ponto BR - NIC.br},
      'bond' => q{Bond University Limited},
      'boo' => q{Charleston Road Registry Inc.},
      'book' => q{Amazon Registry Services, Inc.},
      'booking' => q{Booking.com B.V.},
      'boots' => q{THE BOOTS COMPANY PLC},
      'bosch' => q{Robert Bosch GMBH},
      'bostik' => q{Bostik SA},
      'bot' => q{Amazon Registry Services, Inc.},
      'boutique' => q{Over Galley, LLC},
      'bq' => q{Not assigned},
      'br' => q{Comite Gestor da Internet no Brasil},
      'bradesco' => q{Banco Bradesco S.A.},
      'bridgestone' => q{Bridgestone Corporation},
      'broadway' => q{Celebrate Broadway, Inc.},
      'broker' => q{DOTBROKER REGISTRY LTD},
      'brother' => q{Brother Industries, Ltd.},
      'brussels' => q{DNS.be vzw},
      'bs' => q{The College of the Bahamas},
      'bt' => q{Ministry of Information and Communications},
      'budapest' => q{Top Level Domain Holdings Limited},
      'bugatti' => q{Bugatti International SA},
      'build' => q{Plan Bee LLC},
      'builders' => q{Atomic Madison, LLC},
      'business' => q{Spring Cross, LLC},
      'buy' => q{Amazon Registry Services, INC},
      'buzz' => q{DOTSTRATEGY CO.},
      'bv' => q{UNINETT Norid A/S},
      'bw' => q{Botswana Communications Regulatory Authority (BOCRA)},
      'by' => q{Reliable Software, Ltd.},
      'bz' => q{University of Belize},
      'bzh' => q{Association www.bzh},
      'ca' => q{Canadian Internet Registration Authority (CIRA) AutoritÃ© Canadienne pour les enregistrements Internet (ACEI)},
      'cab' => q{Half Sunset, LLC},
      'cafe' => q{Pioneer Canyon, LLC},
      'cal' => q{Charleston Road Registry Inc.},
      'call' => q{Amazon Registry Services, Inc.},
      'calvinklein' => q{PVH gTLD Holdings LLC},
      'cam' => q{AC Webconnecting Holding B.V.},
      'camera' => q{Atomic Maple, LLC},
      'camp' => q{Delta Dynamite, LLC},
      'cancerresearch' => q{Australian Cancer Research Foundation},
      'canon' => q{Canon Inc.},
      'capetown' => q{ZA Central Registry NPC trading as ZA Central Registry},
      'capital' => q{Delta Mill, LLC},
      'capitalone' => q{Capital One Financial Corporation},
      'car' => q{Cars Registry Limited},
      'caravan' => q{Caravan International, Inc.},
      'cards' => q{Foggy Hollow, LLC},
      'care' => q{Goose Cross, LLC},
      'career' => q{dotCareer LLC},
      'careers' => q{Wild Corner, LLC},
      'cars' => q{Cars Registry Limited},
      'cartier' => q{Richemont DNS Inc.},
      'casa' => q{Top Level Domain Holdings Limited},
      'cash' => q{Delta Lake, LLC},
      'casino' => q{Binky Sky, LLC},
      'cat' => q{Fundacio puntCAT},
      'catering' => q{New Falls. LLC},
      'cba' => q{COMMONWEALTH BANK OF AUSTRALIA},
      'cbn' => q{The Christian Broadcasting Network, Inc.},
      'cbre' => q{CBRE, Inc.},
      'cbs' => q{CBS Domains Inc.},
      'cc' => q{eNIC Cocos (Keeling) Islands Pty. - Ltd. d/b/a Island Internet Services},
      'cd' => q{Office Congolais des Postes et TÃ©lÃ©communications - OCPT},
      'ceb' => q{The Corporate Executive Board Company},
      'center' => q{Tin Mill, LLC},
      'ceo' => q{CEOTLD Pty Ltd},
      'cern' => q{European Organization for Nuclear Research (&quot;CERN&quot;)},
      'cf' => q{Societe Centrafricaine de Telecommunications (SOCATEL)},
      'cfa' => q{CFA Institute},
      'cfd' => q{DOTCFD REGISTRY LTD},
      'cg' => q{ONPT Congo and Interpoint Switzerland},
      'ch' => q{SWITCH The Swiss Education &amp; Research Network},
      'chanel' => q{Chanel International B.V.},
      'channel' => q{Charleston Road Registry Inc.},
      'chase' => q{JPMorgan Chase Bank, National Association},
      'chat' => q{Sand Fields, LLC},
      'cheap' => q{Sand Cover, LLC},
      'chintai' => q{CHINTAI Corporation},
      'chloe' => q{Richemont DNS Inc.},
      'christmas' => q{Uniregistry, Corp.},
      'chrome' => q{Charleston Road Registry Inc.},
      'chrysler' => q{FCA US LLC.},
      'church' => q{Holly Fileds, LLC},
      'ci' => q{INP-HB Institut National Polytechnique Felix Houphouet Boigny},
      'cipriani' => q{Hotel Cipriani Srl},
      'circle' => q{Amazon Registry Services, Inc.},
      'cisco' => q{Cisco Technology, Inc.},
      'citadel' => q{Citadel Domain LLC},
      'citi' => q{Citigroup Inc.},
      'citic' => q{CITIC Group Corporation},
      'city' => q{Snow Sky, LLC},
      'cityeats' => q{Lifestyle Domain Holdings, Inc.},
      'ck' => q{Telecom Cook Islands Ltd.},
      'cl' => q{NIC Chile (University of Chile)},
      'claims' => q{Black Corner, LLC},
      'cleaning' => q{Fox Shadow, LLC},
      'click' => q{Uniregistry, Corp.},
      'clinic' => q{Goose Park, LLC},
      'clinique' => q{The EstÃ©e Lauder Companies Inc.},
      'clothing' => q{Steel Lake, LLC},
      'cloud' => q{ARUBA PEC S.p.A.},
      'club' => q{.CLUB DOMAINS, LLC},
      'clubmed' => q{Club MÃ©diterranÃ©e S.A.},
      'cm' => q{Cameroon Telecommunications (CAMTEL)},
      'cn' => q{China Internet Network Information Center (CNNIC)},
      'co' => q{.CO Internet S.A.S.},
      'coach' => q{Koko Island, LLC},
      'codes' => q{Puff Willow, LLC},
      'coffee' => q{Trixy Cover, LLC},
      'college' => q{XYZ.COM LLC},
      'cologne' => q{NetCologne Gesellschaft fÃ¼r Telekommunikation mbH},
      'com' => q{VeriSign Global Registry Services},
      'comcast' => q{Comcast IP Holdings I, LLC},
      'commbank' => q{COMMONWEALTH BANK OF AUSTRALIA},
      'community' => q{Fox Orchard, LLC},
      'company' => q{Silver Avenue, LLC},
      'compare' => q{iSelect Ltd},
      'computer' => q{Pine Mill, LLC},
      'comsec' => q{VeriSign, Inc.},
      'condos' => q{Pine House, LLC},
      'construction' => q{Fox Dynamite, LLC},
      'consulting' => q{United TLD Holdco, LTD.},
      'contact' => q{Top Level Spectrum, Inc.},
      'contractors' => q{Magic Woods, LLC},
      'cooking' => q{Top Level Domain Holdings Limited},
      'cookingchannel' => q{Lifestyle Domain Holdings, Inc.},
      'cool' => q{Koko Lake, LLC},
      'coop' => q{DotCooperation LLC},
      'corsica' => q{CollectivitÃ© Territoriale de Corse},
      'country' => q{Top Level Domain Holdings Limited},
      'coupon' => q{Amazon Registry Services, Inc.},
      'coupons' => q{Black Island, LLC},
      'courses' => q{OPEN UNIVERSITIES AUSTRALIA PTY LTD},
      'cr' => q{National Academy of Sciences - Academia Nacional de Ciencias},
      'credit' => q{Snow Shadow, LLC},
      'creditcard' => q{Binky Frostbite, LLC},
      'creditunion' => q{CUNA Performance Resources, LLC},
      'cricket' => q{dot Cricket Limited},
      'crown' => q{Crown Equipment Corporation},
      'crs' => q{Federated Co-operatives Limited},
      'cruises' => q{Spring Way, LLC},
      'csc' => q{Alliance-One Services, Inc.},
      'cu' => q{CENIAInternet - Industria y San Jose
      Capitolio Nacional},
      'cuisinella' => q{SALM S.A.S.},
      'cv' => q{AgÃªncia Nacional das ComunicaÃ§Ãµes (ANAC)},
      'cw' => q{University of Curacao},
      'cx' => q{Christmas Island Domain Administration Limited},
      'cy' => q{University of Cyprus},
      'cymru' => q{Nominet UK},
      'cyou' => q{Beijing Gamease Age Digital Technology Co., Ltd.},
      'cz' => q{CZ.NIC, z.s.p.o},
      'dabur' => q{Dabur India Limited},
      'dad' => q{Charleston Road Registry Inc.},
      'dance' => q{United TLD Holdco Ltd.},
      'date' => q{dot Date Limited},
      'dating' => q{Pine Fest, LLC},
      'datsun' => q{NISSAN MOTOR CO., LTD.},
      'day' => q{Charleston Road Registry Inc.},
      'dclk' => q{Charleston Road Registry Inc.},
      'dds' => q{Minds + Machines Group Limited},
      'de' => q{DENIC eG},
      'deal' => q{Amazon Registry Services, Inc.},
      'dealer' => q{Dealer Dot Com, Inc.},
      'deals' => q{Sand Sunset, LLC},
      'degree' => q{United TLD Holdco, Ltd},
      'delivery' => q{Steel Station, LLC},
      'dell' => q{Dell Inc.},
      'deloitte' => q{Deloitte Touche Tohmatsu},
      'delta' => q{Delta Air Lines, Inc.},
      'democrat' => q{United TLD Holdco Ltd.},
      'dental' => q{Tin Birch, LLC},
      'dentist' => q{United TLD Holdco, Ltd},
      'desi' => q{Desi Networks LLC},
      'design' => q{Top Level Design, LLC},
      'dev' => q{Charleston Road Registry Inc.},
      'dhl' => q{Deutsche Post AG},
      'diamonds' => q{John Edge, LLC},
      'diet' => q{Uniregistry, Corp.},
      'digital' => q{Dash Park, LLC},
      'direct' => q{Half Trail, LLC},
      'directory' => q{Extra Madison, LLC},
      'discount' => q{Holly Hill, LLC},
      'discover' => q{Discover Financial Services},
      'dish' => q{Dish DBS Corporation},
      'diy' => q{Lifestyle Domain Holdings, Inc.},
      'dj' => q{Djibouti Telecom S.A},
      'dk' => q{Dansk Internet Forum},
      'dm' => q{DotDM Corporation},
      'dnp' => q{Dai Nippon Printing Co., Ltd.},
      'do' => q{Pontificia Universidad Catolica Madre y Maestra - Recinto Santo Tomas de Aquino},
      'docs' => q{Charleston Road Registry Inc.},
      'doctor' => q{Brice Trail, LLC},
      'dodge' => q{FCA US LLC.},
      'dog' => q{Koko Mill, LLC},
      'doha' => q{Communications Regulatory Authority (CRA)},
      'domains' => q{Sugar Cross, LLC},
      'doosan' => q{Retired},
      'dot' => q{Dish DBS Corporation},
      'download' => q{dot Support Limited},
      'drive' => q{Charleston Road Registry Inc.},
      'dtv' => q{Dish DBS Corporation},
      'dubai' => q{Dubai Smart Government Department},
      'duck' => q{Johnson Shareholdings, Inc.},
      'dunlop' => q{The Goodyear Tire &amp; Rubber Company},
      'duns' => q{The Dun &amp; Bradstreet Corporation},
      'dupont' => q{E. I. du Pont de Nemours and Company},
      'durban' => q{ZA Central Registry NPC trading as ZA Central Registry},
      'dvag' => q{Deutsche VermÃ¶gensberatung Aktiengesellschaft DVAG},
      'dz' => q{CERIST},
      'earth' => q{Interlink Co., Ltd.},
      'eat' => q{Charleston Road Registry Inc.},
      'ec' => q{NIC.EC (NICEC) S.A.},
      'eco' => q{Big Room Inc.},
      'edeka' => q{EDEKA Verband kaufmÃ¤nnischer Genossenschaften e.V.},
      'edu' => q{EDUCAUSE},
      'education' => q{Brice Way, LLC},
      'ee' => q{Eesti Interneti Sihtasutus (EIS)},
      'eg' => q{Egyptian Universities Network (EUN) - Supreme Council of Universities},
      'eh' => q{Not assigned},
      'email' => q{Spring Madison, LLC},
      'emerck' => q{Merck KGaA},
      'energy' => q{Binky Birch, LLC},
      'engineer' => q{United TLD Holdco Ltd.},
      'engineering' => q{Romeo Canyon},
      'enterprises' => q{Snow Oaks, LLC},
      'epost' => q{Deutsche Post AG},
      'epson' => q{Seiko Epson Corporation},
      'equipment' => q{Corn Station, LLC},
      'er' => q{Eritrea Telecommunication Services Corporation (EriTel)},
      'ericsson' => q{Telefonaktiebolaget L M Ericsson},
      'erni' => q{ERNI Group Holding AG},
      'es' => q{Red.es},
      'esq' => q{Charleston Road Registry Inc.},
      'estate' => q{Trixy Park, LLC},
      'esurance' => q{Esurance Insurance Company},
      'et' => q{Ethio telecom},
      'eu' => q{EURid vzw/asbl},
      'eurovision' => q{European Broadcasting Union (EBU)},
      'eus' => q{Puntueus Fundazioa},
      'events' => q{Pioneer Maple, LLC},
      'everbank' => q{EverBank},
      'exchange' => q{Spring Falls, LLC},
      'expert' => q{Magic Pass, LLC},
      'exposed' => q{Victor Beach, LLC},
      'express' => q{Sea Sunset, LLC},
      'extraspace' => q{Extra Space Storage LLC},
      'fage' => q{Fage International S.A.},
      'fail' => q{Atomic Pipe, LLC},
      'fairwinds' => q{FairWinds Partners, LLC},
      'faith' => q{dot Faith Limited},
      'family' => q{United TLD Holdco Ltd.},
      'fan' => q{Asiamix Digital Ltd},
      'fans' => q{Asiamix Digital Limited},
      'farm' => q{Just Maple, LLC},
      'farmers' => q{Farmers Insurance Exchange},
      'fashion' => q{Top Level Domain Holdings Limited},
      'fast' => q{Amazon Registry Services, Inc.},
      'fedex' => q{Federal Express Corporation},
      'feedback' => q{Top Level Spectrum, Inc.},
      'ferrari' => q{Fiat Chrysler Automobiles N.V.},
      'ferrero' => q{Ferrero Trading Lux S.A.},
      'fi' => q{Finnish Communications Regulatory Authority},
      'fiat' => q{Fiat Chrysler Automobiles N.V.},
      'fidelity' => q{Fidelity Brokerage Services LLC},
      'fido' => q{Rogers Communications Partnership},
      'film' => q{Motion Picture Domain Registry Pty Ltd},
      'final' => q{NÃºcleo de InformaÃ§Ã£o e CoordenaÃ§Ã£o do Ponto BR - NIC.br},
      'finance' => q{Cotton Cypress, LLC},
      'financial' => q{Just Cover, LLC},
      'fire' => q{Amazon Registry Services, Inc.},
      'firestone' => q{Bridgestone Licensing Services, Inc.},
      'firmdale' => q{Firmdale Holdings Limited},
      'fish' => q{Fox Woods, LLC},
      'fishing' => q{Top Level Domain Holdings Limited},
      'fit' => q{Minds + Machines Group Limited},
      'fitness' => q{Brice Orchard, LLC},
      'fj' => q{The University of the South Pacific - IT Services},
      'fk' => q{Falkland Islands Government},
      'flickr' => q{Yahoo! Domain Services Inc.},
      'flights' => q{Fox Station, LLC},
      'flir' => q{FLIR Systems, Inc.},
      'florist' => q{Half Cypress, LLC},
      'flowers' => q{Uniregistry, Corp.},
      'flsmidth' => q{Retired},
      'fly' => q{Charleston Road Registry Inc.},
      'fm' => q{FSM Telecommunications Corporation},
      'fo' => q{FO Council},
      'foo' => q{Charleston Road Registry Inc.},
      'foodnetwork' => q{Lifestyle Domain Holdings, Inc.},
      'football' => q{Foggy Farms, LLC},
      'ford' => q{Ford Motor Company},
      'forex' => q{DOTFOREX REGISTRY LTD},
      'forsale' => q{United TLD Holdco, LLC},
      'forum' => q{Fegistry, LLC},
      'foundation' => q{John Dale, LLC},
      'fox' => q{FOX Registry, LLC},
      'fr' => q{Association FranÃ§aise pour le Nommage Internet en CoopÃ©ration (A.F.N.I.C.)},
      'fresenius' => q{Fresenius Immobilien-Verwaltungs-GmbH},
      'frl' => q{FRLregistry B.V.},
      'frogans' => q{OP3FT},
      'frontdoor' => q{Lifestyle Domain Holdings, Inc.},
      'frontier' => q{Frontier Communications Corporation},
      'ftr' => q{Frontier Communications Corporation},
      'fujitsu' => q{Fujitsu Limited},
      'fujixerox' => q{Xerox DNHC LLC},
      'fund' => q{John Castle, LLC},
      'furniture' => q{Lone Fields, LLC},
      'futbol' => q{United TLD Holdco, Ltd.},
      'fyi' => q{Silver Tigers, LLC},
      'ga' => q{Agence Nationale des Infrastructures NumÃ©riques et des FrÃ©quences (ANINF)},
      'gal' => q{AsociaciÃ³n puntoGAL},
      'gallery' => q{Sugar House, LLC},
      'gallo' => q{Gallo Vineyards, Inc.},
      'gallup' => q{Gallup, Inc.},
      'game' => q{Uniregistry, Corp.},
      'games' => q{United TLD Holdco Ltd.},
      'gap' => q{The Gap, Inc.},
      'garden' => q{Top Level Domain Holdings Limited},
      'gb' => q{Reserved Domain - IANA},
      'gbiz' => q{Charleston Road Registry Inc.},
      'gd' => q{The National Telecommunications Regulatory Commission (NTRC)},
      'gdn' => q{Joint Stock Company &quot;Navigation-information systems&quot;},
      'ge' => q{Caucasus Online},
      'gea' => q{GEA Group Aktiengesellschaft},
      'gent' => q{Combell nv},
      'genting' => q{Resorts World Inc. Pte. Ltd.},
      'george' => q{Wal-Mart Stores, Inc.},
      'gf' => q{Net Plus},
      'gg' => q{Island Networks Ltd.},
      'ggee' => q{GMO Internet, Inc.},
      'gh' => q{Network Computer Systems Limited},
      'gi' => q{Sapphire Networks},
      'gift' => q{Uniregistry, Corp.},
      'gifts' => q{Goose Sky, LLC},
      'gives' => q{United TLD Holdco Ltd.},
      'giving' => q{Giving Limited},
      'gl' => q{TELE Greenland A/S},
      'glade' => q{Johnson Shareholdings, Inc.},
      'glass' => q{Black Cover, LLC},
      'gle' => q{Charleston Road Registry Inc.},
      'global' => q{Dot Global Domain Registry Limited},
      'globo' => q{Globo ComunicaÃ§Ã£o e ParticipaÃ§Ãµes S.A},
      'gm' => q{GM-NIC},
      'gmail' => q{Charleston Road Registry Inc.},
      'gmbh' => q{Extra Dynamite, LLC},
      'gmo' => q{GMO Internet, Inc.},
      'gmx' => q{1&amp;1 Mail &amp; Media GmbH},
      'gn' => q{Centre National des Sciences Halieutiques de Boussoura},
      'godaddy' => q{Go Daddy East, LLC},
      'gold' => q{June Edge, LLC},
      'goldpoint' => q{YODOBASHI CAMERA CO.,LTD.},
      'golf' => q{Lone Falls, LLC},
      'goo' => q{NTT Resonant Inc.},
      'goodhands' => q{Allstate Fire and Casualty Insurance Company},
      'goodyear' => q{The Goodyear Tire &amp; Rubber Company},
      'goog' => q{Charleston Road Registry Inc.},
      'google' => q{Charleston Road Registry Inc.},
      'gop' => q{Republican State Leadership Committee, Inc.},
      'got' => q{Amazon Registry Services, Inc.},
      'gov' => q{General Services Administration - Attn: QTDC, 2E08 (.gov Domain Registration)},
      'gp' => q{Networking Technologies Group},
      'gq' => q{GETESA},
      'gr' => q{ICS-FORTH GR},
      'grainger' => q{Grainger Registry Services, LLC},
      'graphics' => q{Over Madison, LLC},
      'gratis' => q{Pioneer Tigers, LLC},
      'green' => q{Afilias Limited},
      'gripe' => q{Corn Sunset, LLC},
      'group' => q{Romeo Town, LLC},
      'gs' => q{Government of South Georgia and South Sandwich Islands (GSGSSI)},
      'gt' => q{Universidad del Valle de Guatemala},
      'gu' => q{University of Guam - Computer Center},
      'guardian' => q{The Guardian Life Insurance Company of America},
      'gucci' => q{Guccio Gucci S.p.a.},
      'guge' => q{Charleston Road Registry Inc.},
      'guide' => q{Snow Moon, LLC},
      'guitars' => q{Uniregistry, Corp.},
      'guru' => q{Pioneer Cypress, LLC},
      'gw' => q{Autoridade Reguladora Nacional - Tecnologias de InformaÃ§Ã£o e ComunicaÃ§Ã£o da GuinÃ©-Bissau},
      'gy' => q{University of Guyana},
      'hamburg' => q{Hamburg Top-Level-Domain GmbH},
      'hangout' => q{Charleston Road Registry Inc.},
      'haus' => q{United TLD Holdco, LTD.},
      'hbo' => q{HBO Registry Services, Inc.},
      'hdfc' => q{HOUSING DEVELOPMENT FINANCE CORPORATION LIMITED},
      'hdfcbank' => q{HDFC Bank Limited},
      'health' => q{DotHealth, LLC},
      'healthcare' => q{Silver Glen, LLC},
      'help' => q{Uniregistry, Corp.},
      'helsinki' => q{City of Helsinki},
      'here' => q{Charleston Road Registry Inc.},
      'hermes' => q{Hermes International},
      'hgtv' => q{Lifestyle Domain Holdings, Inc.},
      'hiphop' => q{Uniregistry, Corp.},
      'hisamitsu' => q{Hisamitsu Pharmaceutical Co.,Inc.},
      'hitachi' => q{Hitachi, Ltd.},
      'hiv' => q{Uniregistry, Corp.},
      'hk' => q{Hong Kong Internet Registration Corporation Ltd.},
      'hkt' => q{PCCW-HKT DataCom Services Limited},
      'hm' => q{HM Domain Registry},
      'hn' => q{Red de Desarrollo Sostenible Honduras},
      'hockey' => q{Half Willow, LLC},
      'holdings' => q{John Madison, LLC},
      'holiday' => q{Goose Woods, LLC},
      'homedepot' => q{Homer TLC, Inc.},
      'homegoods' => q{The TJX Companies, Inc.},
      'homes' => q{DERHomes, LLC},
      'homesense' => q{The TJX Companies, Inc.},
      'honda' => q{Honda Motor Co., Ltd.},
      'honeywell' => q{Honeywell GTLD LLC},
      'horse' => q{Top Level Domain Holdings Limited},
      'host' => q{DotHost Inc.},
      'hosting' => q{Uniregistry, Corp.},
      'hot' => q{Amazon Registry Services, Inc.},
      'hoteles' => q{Travel Reservations SRL},
      'hotmail' => q{Microsoft Corporation},
      'house' => q{Sugar Park, LLC},
      'how' => q{Charleston Road Registry Inc.},
      'hr' => q{CARNet - Croatian Academic and Research Network},
      'hsbc' => q{HSBC Holdings PLC},
      'ht' => q{Consortium FDS/RDDH},
      'htc' => q{HTC corporation},
      'hu' => q{Council of Hungarian Internet Providers (CHIP)},
      'hughes' => q{Hughes Satellite Systems Corporation},
      'hyatt' => q{Hyatt GTLD, L.L.C.},
      'hyundai' => q{Hyundai Motor Company},
      'ibm' => q{International Business Machines Corporation},
      'icbc' => q{Industrial and Commercial Bank of China Limited},
      'ice' => q{IntercontinentalExchange, Inc.},
      'icu' => q{One.com A/S},
      'id' => q{Perkumpulan Pengelola Nama Domain Internet Indonesia (PANDI)},
      'ie' => q{University College Dublin - Computing Services
      Computer Centre},
      'ieee' => q{IEEE Global LLC},
      'ifm' => q{ifm electronic gmbh},
      'iinet' => q{Connect West Pty. Ltd.},
      'ikano' => q{Ikano S.A.},
      'il' => q{Internet Society of Israel},
      'im' => q{Isle of Man Government},
      'imamat' => q{Fondation Aga Khan (Aga Khan Foundation)},
      'imdb' => q{Amazon Registry Services, Inc.},
      'immo' => q{Auburn Bloom, LLC},
      'immobilien' => q{United TLD Holdco Ltd.},
      'in' => q{National Internet Exchange of India},
      'industries' => q{Outer House, LLC},
      'infiniti' => q{NISSAN MOTOR CO., LTD.},
      'info' => q{Afilias Limited},
      'ing' => q{Charleston Road Registry Inc.},
      'ink' => q{Top Level Design, LLC},
      'institute' => q{Outer Maple, LLC},
      'insurance' => q{fTLD Registry Services LLC},
      'insure' => q{Pioneer Willow, LLC},
      'int' => q{Internet Assigned Numbers Authority},
      'intel' => q{Intel Corporation},
      'international' => q{Wild Way, LLC},
      'intuit' => q{Intuit Administrative Services, Inc.},
      'investments' => q{Holly Glen, LLC},
      'io' => q{IO Top Level Domain Registry - Cable and Wireless},
      'ipiranga' => q{Ipiranga Produtos de Petroleo S.A.},
      'iq' => q{Communications and Media Commission (CMC)},
      'ir' => q{Institute for Research in Fundamental Sciences},
      'irish' => q{Dot-Irish LLC},
      'is' => q{ISNIC - Internet Iceland ltd.},
      'iselect' => q{iSelect Ltd},
      'ismaili' => q{Fondation Aga Khan (Aga Khan Foundation)},
      'ist' => q{Istanbul Metropolitan Municipality},
      'istanbul' => q{Istanbul Metropolitan Municipality},
      'it' => q{IIT - CNR},
      'itau' => q{Itau Unibanco Holding S.A.},
      'itv' => q{ITV Services Limited},
      'iwc' => q{Richemont DNS Inc.},
      'jaguar' => q{Jaguar Land Rover Ltd},
      'java' => q{Oracle Corporation},
      'jcb' => q{JCB Co., Ltd.},
      'jcp' => q{JCP Media, Inc.},
      'je' => q{Island Networks (Jersey) Ltd.},
      'jeep' => q{FCA US LLC.},
      'jetzt' => q{Wild Frostbite, LLC},
      'jewelry' => q{Wild Bloom, LLC},
      'jlc' => q{Richemont DNS Inc.},
      'jll' => q{Jones Lang LaSalle Incorporated},
      'jm' => q{University of West Indies},
      'jmp' => q{Matrix IP LLC},
      'jnj' => q{Johnson &amp; Johnson Services, Inc.},
      'jo' => q{National Information Technology Center (NITC)},
      'jobs' => q{Employ Media LLC},
      'joburg' => q{ZA Central Registry NPC trading as ZA Central Registry},
      'jot' => q{Amazon Registry Services, Inc.},
      'joy' => q{Amazon Registry Services, Inc.},
      'jp' => q{Japan Registry Services Co., Ltd.},
      'jpmorgan' => q{JPMorgan Chase Bank, National Association},
      'jprs' => q{Japan Registry Services Co., Ltd.},
      'juegos' => q{Uniregistry, Corp.},
      'juniper' => q{JUNIPER NETWORKS, INC.},
      'kaufen' => q{United TLD Holdco Ltd.},
      'kddi' => q{KDDI CORPORATION},
      'ke' => q{Kenya Network Information Center (KeNIC)},
      'kerryhotels' => q{Kerry Trading Co. Limited},
      'kerrylogistics' => q{Kerry Trading Co. Limited},
      'kerryproperties' => q{Kerry Trading Co. Limited},
      'kfh' => q{Kuwait Finance House},
      'kg' => q{AsiaInfo Telecommunication Enterprise},
      'kh' => q{Telecommunication Regulator of Cambodia (TRC)},
      'ki' => q{Ministry of Communications, Transport, and Tourism Development},
      'kia' => q{KIA MOTORS CORPORATION},
      'kim' => q{Afilias Limited},
      'kinder' => q{Ferrero Trading Lux S.A.},
      'kindle' => q{Amazon Registry Services, Inc.},
      'kitchen' => q{Just Goodbye, LLC},
      'kiwi' => q{DOT KIWI LIMITED},
      'km' => q{Comores Telecom},
      'kn' => q{Ministry of Finance, Sustainable Development Information &amp; Technology},
      'koeln' => q{NetCologne Gesellschaft fÃ¼r Telekommunikation mbH},
      'komatsu' => q{Komatsu Ltd.},
      'kosher' => q{Kosher Marketing Assets LLC},
      'kp' => q{Star Joint Venture Company},
      'kpmg' => q{KPMG International Cooperative (KPMG International Genossenschaft)},
      'kpn' => q{Koninklijke KPN N.V.},
      'kr' => q{Korea Internet &amp; Security Agency (KISA)},
      'krd' => q{KRG Department of Information Technology},
      'kred' => q{KredTLD Pty Ltd},
      'kuokgroup' => q{Kerry Trading Co. Limited},
      'kw' => q{Ministry of Communications},
      'ky' => q{The Information and Communications Technology Authority},
      'kyoto' => q{Academic Institution: Kyoto Jyoho Gakuen},
      'kz' => q{Association of IT Companies of Kazakhstan},
      'la' => q{Lao National Internet Committee (LANIC), Ministry of Posts and Telecommunications},
      'lacaixa' => q{CAIXA D&#39;ESTALVIS I PENSIONS DE BARCELONA},
      'ladbrokes' => q{LADBROKES INTERNATIONAL PLC},
      'lamborghini' => q{Automobili Lamborghini S.p.A.},
      'lamer' => q{The EstÃ©e Lauder Companies Inc.},
      'lancaster' => q{LANCASTER},
      'lancia' => q{Fiat Chrysler Automobiles N.V.},
      'lancome' => q{L&#39;OrÃ©al},
      'land' => q{Pine Moon, LLC},
      'landrover' => q{Jaguar Land Rover Ltd},
      'lanxess' => q{LANXESS Corporation},
      'lasalle' => q{Jones Lang LaSalle Incorporated},
      'lat' => q{ECOM-LAC FederaciÃ³n de LatinoamÃ©rica y el Caribe para Internet y el Comercio ElectrÃ³nico},
      'latino' => q{Dish DBS Corporation},
      'latrobe' => q{La Trobe University},
      'law' => q{Minds + Machines Group Limited},
      'lawyer' => q{United TLD Holdco, Ltd},
      'lb' => q{American University of Beirut - Computing and Networking Services},
      'lc' => q{University of Puerto Rico},
      'lds' => q{IRI Domain Management, LLC},
      'lease' => q{Victor Trail, LLC},
      'leclerc' => q{A.C.D. LEC Association des Centres Distributeurs Edouard Leclerc},
      'lefrak' => q{LeFrak Organization, Inc.},
      'legal' => q{Blue Falls, LLC},
      'lego' => q{LEGO Juris A/S},
      'lexus' => q{TOYOTA MOTOR CORPORATION},
      'lgbt' => q{Afilias Limited},
      'li' => q{Universitaet Liechtenstein},
      'liaison' => q{Liaison Technologies, Incorporated},
      'lidl' => q{Schwarz Domains und Services GmbH &amp; Co. KG},
      'life' => q{Trixy Oaks, LLC},
      'lifeinsurance' => q{American Council of Life Insurers},
      'lifestyle' => q{Lifestyle Domain Holdings, Inc.},
      'lighting' => q{John McCook, LLC},
      'like' => q{Amazon Registry Services, Inc.},
      'lilly' => q{Eli Lilly and Company},
      'limited' => q{Big Fest, LLC},
      'limo' => q{Hidden Frostbite, LLC},
      'lincoln' => q{Ford Motor Company},
      'linde' => q{Linde Aktiengesellschaft},
      'link' => q{Uniregistry, Corp.},
      'lipsy' => q{Lipsy Ltd},
      'live' => q{United TLD Holdco Ltd.},
      'living' => q{Lifestyle Domain Holdings, Inc.},
      'lixil' => q{LIXIL Group Corporation},
      'lk' => q{Council for Information Technology - LK Domain Registrar},
      'loan' => q{dot Loan Limited},
      'loans' => q{June Woods, LLC},
      'locker' => q{Dish DBS Corporation},
      'locus' => q{Locus Analytics LLC},
      'loft' => q{Annco, Inc.},
      'lol' => q{Uniregistry, Corp.},
      'london' => q{Dot London Domains Limited},
      'lotte' => q{Lotte Holdings Co., Ltd.},
      'lotto' => q{Afilias Limited},
      'love' => q{Merchant Law Group LLP},
      'lpl' => q{LPL Holdings, Inc.},
      'lplfinancial' => q{LPL Holdings, Inc.},
      'lr' => q{Data Technology Solutions, Inc.},
      'ls' => q{National University of Lesotho},
      'lt' => q{Kaunas University of Technology},
      'ltd' => q{Over Corner, LLC},
      'ltda' => q{InterNetX Corp.},
      'lu' => q{RESTENA},
      'lundbeck' => q{H. Lundbeck A/S},
      'lupin' => q{LUPIN LIMITED},
      'luxe' => q{Top Level Domain Holdings Limited},
      'luxury' => q{Luxury Partners LLC},
      'lv' => q{University of Latvia - Institute of Mathematics and Computer Science
      Department of Network Solutions (DNS)},
      'ly' => q{General Post and Telecommunication Company},
      'ma' => q{Agence Nationale de RÃ©glementation des TÃ©lÃ©communications (ANRT)},
      'macys' => q{Macys, Inc.},
      'madrid' => q{Comunidad de Madrid},
      'maif' => q{Mutuelle Assurance Instituteur France (MAIF)},
      'maison' => q{Victor Frostbite, LLC},
      'makeup' => q{L&#39;OrÃ©al},
      'man' => q{MAN SE},
      'management' => q{John Goodbye, LLC},
      'mango' => q{PUNTO FA S.L.},
      'market' => q{United TLD Holdco, Ltd},
      'marketing' => q{Fern Pass, LLC},
      'markets' => q{DOTMARKETS REGISTRY LTD},
      'marriott' => q{Marriott Worldwide Corporation},
      'marshalls' => q{The TJX Companies, Inc.},
      'maserati' => q{Fiat Chrysler Automobiles N.V.},
      'mattel' => q{Mattel Sites, Inc.},
      'mba' => q{Lone Hollow, LLC},
      'mc' => q{Gouvernement de Monaco - Direction des Communications Electroniques},
      'mcd' => q{McDonaldâ€™s Corporation},
      'mcdonalds' => q{McDonaldâ€™s Corporation},
      'mckinsey' => q{McKinsey Holdings, Inc.},
      'md' => q{MoldData S.E.},
      'me' => q{Government of Montenegro},
      'med' => q{Medistry LLC},
      'media' => q{Grand Glen, LLC},
      'meet' => q{Charleston Road Registry Inc.},
      'melbourne' => q{The Crown in right of the State of Victoria, represented by its Department of State Development, Business and Innovation},
      'meme' => q{Charleston Road Registry Inc.},
      'memorial' => q{Dog Beach, LLC},
      'men' => q{Exclusive Registry Limited},
      'menu' => q{Wedding TLD2, LLC},
      'meo' => q{PT Comunicacoes S.A.},
      'metlife' => q{MetLife Services and Solutions, LLC},
      'mf' => q{Not assigned},
      'mg' => q{NIC-MG (Network Information Center Madagascar)},
      'mh' => q{Office of the Cabinet},
      'miami' => q{Top Level Domain Holdings Limited},
      'microsoft' => q{Microsoft Corporation},
      'mil' => q{DoD Network Information Center},
      'mini' => q{Bayerische Motoren Werke Aktiengesellschaft},
      'mint' => q{Intuit Administrative Services, Inc.},
      'mit' => q{Massachusetts Institute of Technology},
      'mitsubishi' => q{Mitsubishi Corporation},
      'mk' => q{Macedonian Academic Research Network Skopje},
      'ml' => q{Agence des Technologies de lâ€™Information et de la Communication},
      'mlb' => q{MLB Advanced Media DH, LLC},
      'mls' => q{The Canadian Real Estate Association},
      'mm' => q{Ministry of Communications, Posts &amp; Telegraphs},
      'mma' => q{MMA IARD},
      'mn' => q{Datacom Co., Ltd.},
      'mo' => q{Bureau of Telecommunications Regulation (DSRT)},
      'mobi' => q{Afilias Technologies Limited dba dotMobi},
      'mobily' => q{GreenTech Consultancy Company W.L.L.},
      'moda' => q{United TLD Holdco Ltd.},
      'moe' => q{Interlink Co., Ltd.},
      'moi' => q{Amazon Registry Services, Inc.},
      'mom' => q{Uniregistry, Corp.},
      'monash' => q{Monash University},
      'money' => q{Outer McCook, LLC},
      'monster' => q{Monster Worldwide, Inc.},
      'montblanc' => q{Richemont DNS Inc.},
      'mopar' => q{FCA US LLC.},
      'mormon' => q{IRI Domain Management, LLC (&quot;Applicant&quot;)},
      'mortgage' => q{United TLD Holdco, Ltd},
      'moscow' => q{Foundation for Assistance for Internet Technologies and Infrastructure Development (FAITID)},
      'motorcycles' => q{DERMotorcycles, LLC},
      'mov' => q{Charleston Road Registry Inc.},
      'movie' => q{New Frostbite, LLC},
      'movistar' => q{TelefÃ³nica S.A.},
      'mp' => q{Saipan Datacom, Inc.},
      'mq' => q{MEDIASERV},
      'mr' => q{UniversitÃ© des Sciences, de Technologie et de MÃ©decine},
      'ms' => q{MNI Networks Ltd.},
      'msd' => q{MSD Registry Holdings, Inc.},
      'mt' => q{NIC (Malta)},
      'mtn' => q{MTN Dubai Limited},
      'mtpc' => q{Mitsubishi Tanabe Pharma Corporation},
      'mtr' => q{MTR Corporation Limited},
      'mu' => q{Internet Direct Ltd},
      'museum' => q{Museum Domain Management Association},
      'mutual' => q{Northwestern Mutual MU TLD Registry, LLC},
      'mutuelle' => q{FÃ©dÃ©ration Nationale de la MutualitÃ© FranÃ§aise},
      'mv' => q{Dhiraagu Pvt. Ltd. (DHIVEHINET)},
      'mw' => q{Malawi Sustainable Development Network Programme - (Malawi SDNP)},
      'mx' => q{NIC-Mexico - ITESM - Campus Monterrey},
      'my' => q{MYNIC Berhad},
      'mz' => q{Centro de Informatica de Universidade Eduardo Mondlane},
      'na' => q{Namibian Network Information Center},
      'nab' => q{National Australia Bank Limited},
      'nadex' => q{Nadex Domains, Inc},
      'nagoya' => q{GMO Registry, Inc.},
      'name' => q{VeriSign Information Services, Inc.},
      'nationwide' => q{Nationwide Mutual Insurance Company},
      'natura' => q{NATURA COSMÃ‰TICOS S.A.},
      'navy' => q{United TLD Holdco Ltd.},
      'nba' => q{NBA REGISTRY, LLC},
      'nc' => q{Office des Postes et Telecommunications},
      'ne' => q{SONITEL},
      'nec' => q{NEC Corporation},
      'net' => q{VeriSign Global Registry Services},
      'netbank' => q{COMMONWEALTH BANK OF AUSTRALIA},
      'netflix' => q{Netflix, Inc.},
      'network' => q{Trixy Manor, LLC},
      'neustar' => q{NeuStar, Inc.},
      'new' => q{Charleston Road Registry Inc.},
      'news' => q{United TLD Holdco Ltd.},
      'next' => q{Next plc},
      'nextdirect' => q{Next plc},
      'nexus' => q{Charleston Road Registry Inc.},
      'nf' => q{Norfolk Island Data Services},
      'nfl' => q{NFL Reg Ops LLC},
      'ng' => q{Nigeria Internet Registration Association},
      'ngo' => q{Public Interest Registry},
      'nhk' => q{Japan Broadcasting Corporation (NHK)},
      'ni' => q{Universidad Nacional del Ingernieria - Centro de Computo},
      'nico' => q{DWANGO Co., Ltd.},
      'nike' => q{NIKE, Inc.},
      'nikon' => q{NIKON CORPORATION},
      'ninja' => q{United TLD Holdco Ltd.},
      'nissan' => q{NISSAN MOTOR CO., LTD.},
      'nissay' => q{Nippon Life Insurance Company},
      'nl' => q{SIDN (Stichting Internet  Domeinregistratie Nederland)},
      'no' => q{UNINETT Norid A/S},
      'nokia' => q{Nokia Corporation},
      'northwesternmutual' => q{Northwestern Mutual Registry, LLC},
      'norton' => q{Symantec Corporation},
      'now' => q{Amazon Registry Services, Inc.},
      'nowruz' => q{Asia Green IT System Bilgisayar San. ve Tic. Ltd. Sti.},
      'nowtv' => q{Starbucks (HK) Limited},
      'np' => q{Mercantile Communications Pvt. Ltd.},
      'nr' => q{CENPAC NET},
      'nra' => q{NRA Holdings Company, INC.},
      'nrw' => q{Minds + Machines GmbH},
      'ntt' => q{NIPPON TELEGRAPH AND TELEPHONE CORPORATION},
      'nu' => q{The IUSN Foundation},
      'nyc' => q{The City of New York by and through the New York City Department of Information Technology &amp; Telecommunications},
      'nz' => q{InternetNZ},
      'obi' => q{OBI Group Holding SE &amp; Co. KGaA},
      'off' => q{Johnson Shareholdings, Inc.},
      'office' => q{Microsoft Corporation},
      'okinawa' => q{BRregistry, Inc.},
      'olayan' => q{Crescent Holding GmbH},
      'olayangroup' => q{Crescent Holding GmbH},
      'oldnavy' => q{The Gap, Inc.},
      'ollo' => q{Dish DBS Corporation},
      'om' => q{Telecommunications Regulatory Authority (TRA)},
      'omega' => q{The Swatch Group Ltd},
      'one' => q{One.com A/S},
      'ong' => q{Public Interest Registry},
      'onl' => q{I-REGISTRY Ltd., Niederlassung Deutschland},
      'online' => q{DotOnline Inc.},
      'onyourside' => q{Nationwide Mutual Insurance Company},
      'ooo' => q{INFIBEAM INCORPORATION LIMITED},
      'open' => q{American Express Travel Related Services Company, Inc.},
      'oracle' => q{Oracle Corporation},
      'orange' => q{Orange Brand Services Limited},
      'org' => q{Public Interest Registry (PIR)},
      'organic' => q{Afilias Limited},
      'orientexpress' => q{Orient Express},
      'origins' => q{The EstÃ©e Lauder Companies Inc.},
      'osaka' => q{Interlink Co., Ltd.},
      'otsuka' => q{Otsuka Holdings Co., Ltd.},
      'ott' => q{Dish DBS Corporation},
      'ovh' => q{OVH SAS},
      'pa' => q{Universidad Tecnologica de Panama},
      'page' => q{Charleston Road Registry Inc.},
      'pamperedchef' => q{The Pampered Chef, Ltd.},
      'panasonic' => q{Panasonic Corporation},
      'panerai' => q{Richemont DNS Inc.},
      'paris' => q{City of Paris},
      'pars' => q{Asia Green IT System Bilgisayar San. ve Tic. Ltd. Sti.},
      'partners' => q{Magic Glen, LLC},
      'parts' => q{Sea Goodbye, LLC},
      'party' => q{Blue Sky Registry Limited},
      'passagens' => q{Travel Reservations SRL},
      'pay' => q{Amazon Registry Services, Inc.},
      'pccw' => q{PCCW Enterprises Limited},
      'pe' => q{Red Cientifica Peruana},
      'pet' => q{Afilias plc},
      'pf' => q{Gouvernement de la PolynÃ©sie franÃ§aise},
      'pfizer' => q{Pfizer Inc.},
      'pg' => q{PNG DNS Administration - Vice Chancellors Office
      The Papua New Guinea University of Technology},
      'ph' => q{PH Domain Foundation},
      'pharmacy' => q{National Association of Boards of Pharmacy},
      'philips' => q{Koninklijke Philips N.V.},
      'photo' => q{Uniregistry, Corp.},
      'photography' => q{Sugar Glen, LLC},
      'photos' => q{Sea Corner, LLC},
      'physio' => q{PhysBiz Pty Ltd},
      'piaget' => q{Richemont DNS Inc.},
      'pics' => q{Uniregistry, Corp.},
      'pictet' => q{Pictet Europe S.A.},
      'pictures' => q{Foggy Sky, LLC},
      'pid' => q{Top Level Spectrum, Inc.},
      'pin' => q{Amazon Registry Services, Inc.},
      'ping' => q{Ping Registry Provider, Inc.},
      'pink' => q{Afilias Limited},
      'pioneer' => q{Pioneer Corporation},
      'pizza' => q{Foggy Moon, LLC},
      'pk' => q{PKNIC},
      'pl' => q{Research and Academic Computer Network},
      'place' => q{Snow Galley, LLC},
      'play' => q{Charleston Road Registry Inc.},
      'playstation' => q{Sony Computer Entertainment Inc.},
      'plumbing' => q{Spring Tigers, LLC},
      'plus' => q{Sugar Mill, LLC},
      'pm' => q{Association FranÃ§aise pour le Nommage Internet en CoopÃ©ration (A.F.N.I.C.)},
      'pn' => q{Pitcairn Island Administration},
      'pnc' => q{PNC Domain Co., LLC},
      'pohl' => q{Deutsche VermÃ¶gensberatung Aktiengesellschaft DVAG},
      'poker' => q{Afilias Domains No. 5 Limited},
      'politie' => q{Politie Nederland},
      'porn' => q{ICM Registry PN LLC},
      'post' => q{Universal Postal Union},
      'pr' => q{Gauss Research Laboratory Inc.},
      'pramerica' => q{Prudential Financial, Inc.},
      'praxi' => q{Praxi S.p.A.},
      'press' => q{DotPress Inc.},
      'prime' => q{Amazon Registry Services, Inc.},
      'pro' => q{Registry Services Corporation - dba RegistryPro},
      'prod' => q{Charleston Road Registry Inc.},
      'productions' => q{Magic Birch, LLC},
      'prof' => q{Charleston Road Registry Inc.},
      'progressive' => q{Progressive Casualty Insurance Company},
      'promo' => q{Afilias plc},
      'properties' => q{Big Pass, LLC},
      'property' => q{Uniregistry, Corp.},
      'protection' => q{XYZ.COM LLC},
      'pru' => q{Prudential Financial, Inc.},
      'prudential' => q{Prudential Financial, Inc.},
      'ps' => q{Ministry Of Telecommunications &amp; - Information Technology,
      Government Computer Center.},
      'pt' => q{AssociaÃ§Ã£o DNS.PT},
      'pub' => q{United TLD Holdco Ltd.},
      'pw' => q{Micronesia Investment and Development Corporation},
      'pwc' => q{PricewaterhouseCoopers LLP},
      'py' => q{NIC-PY},
      'qa' => q{Communications Regulatory Authority},
      'qpon' => q{dotCOOL, Inc.},
      'quebec' => q{PointQuÃ©bec Inc},
      'quest' => q{Quest ION Limited},
      'qvc' => q{QVC, Inc.},
      'racing' => q{Premier Registry Limited},
      'raid' => q{Johnson Shareholdings, Inc.},
      're' => q{Association FranÃ§aise pour le Nommage Internet en CoopÃ©ration (A.F.N.I.C.)},
      'read' => q{Amazon Registry Services, Inc.},
      'realestate' => q{dotRealEstate LLC},
      'realtor' => q{Real Estate Domains LLC},
      'realty' => q{Fegistry, LLC},
      'recipes' => q{Grand Island, LLC},
      'red' => q{Afilias Limited},
      'redstone' => q{Redstone Haute Couture Co., Ltd.},
      'redumbrella' => q{Travelers TLD, LLC},
      'rehab' => q{United TLD Holdco Ltd.},
      'reise' => q{Foggy Way, LLC},
      'reisen' => q{New Cypress, LLC},
      'reit' => q{National Association of Real Estate Investment Trusts, Inc.},
      'ren' => q{Beijing Qianxiang Wangjing Technology Development Co., Ltd.},
      'rent' => q{XYZ.COM LLC},
      'rentals' => q{Big Hollow,LLC},
      'repair' => q{Lone Sunset, LLC},
      'report' => q{Binky Glen, LLC},
      'republican' => q{United TLD Holdco Ltd.},
      'rest' => q{Punto 2012 Sociedad Anonima Promotora de Inversion de Capital Variable},
      'restaurant' => q{Snow Avenue, LLC},
      'review' => q{dot Review Limited},
      'reviews' => q{United TLD Holdco, Ltd.},
      'rexroth' => q{Robert Bosch GMBH},
      'rich' => q{I-REGISTRY Ltd., Niederlassung Deutschland},
      'richardli' => q{Pacific Century Asset Management (HK) Limited},
      'ricoh' => q{Ricoh Company, Ltd.},
      'rightathome' => q{Johnson Shareholdings, Inc.},
      'rio' => q{Empresa Municipal de InformÃ¡tica SA - IPLANRIO},
      'rip' => q{United TLD Holdco Ltd.},
      'ro' => q{National Institute for R&amp;D in Informatics},
      'rocher' => q{Ferrero Trading Lux S.A.},
      'rocks' => q{United TLD Holdco, LTD.},
      'rodeo' => q{Top Level Domain Holdings Limited},
      'rogers' => q{Rogers Communications Partnership},
      'room' => q{Amazon Registry Services, Inc.},
      'rs' => q{Serbian National Internet Domain Registry (RNIDS)},
      'rsvp' => q{Charleston Road Registry Inc.},
      'ru' => q{Coordination Center for TLD RU},
      'ruhr' => q{regiodot GmbH &amp; Co. KG},
      'run' => q{Snow Park, LLC},
      'rw' => q{Rwanda Information Communication and Technology Association (RICTA)},
      'rwe' => q{RWE AG},
      'ryukyu' => q{BRregistry, Inc.},
      'sa' => q{Communications and Information Technology Commission},
      'saarland' => q{dotSaarland GmbH},
      'safe' => q{Amazon Registry Services, Inc.},
      'safety' => q{Safety Registry Services, LLC.},
      'sakura' => q{SAKURA Internet Inc.},
      'sale' => q{United TLD Holdco, Ltd},
      'salon' => q{Outer Orchard, LLC},
      'samsclub' => q{Wal-Mart Stores, Inc.},
      'samsung' => q{SAMSUNG SDS CO., LTD},
      'sandvik' => q{Sandvik AB},
      'sandvikcoromant' => q{Sandvik AB},
      'sanofi' => q{Sanofi},
      'sap' => q{SAP AG},
      'sapo' => q{PT Comunicacoes S.A.},
      'sarl' => q{Delta Orchard, LLC},
      'sas' => q{Research IP LLC},
      'save' => q{Amazon Registry Services, Inc.},
      'saxo' => q{Saxo Bank A/S},
      'sb' => q{Solomon Telekom Company Limited},
      'sbi' => q{STATE BANK OF INDIA},
      'sbs' => q{SPECIAL BROADCASTING SERVICE CORPORATION},
      'sc' => q{VCS Pty Ltd},
      'sca' => q{SVENSKA CELLULOSA AKTIEBOLAGET SCA (publ)},
      'scb' => q{The Siam Commercial Bank Public Company Limited (&quot;SCB&quot;)},
      'schaeffler' => q{Schaeffler Technologies AG &amp; Co. KG},
      'schmidt' => q{SALM S.A.S.},
      'scholarships' => q{Scholarships.com, LLC},
      'school' => q{Little Galley, LLC},
      'schule' => q{Outer Moon, LLC},
      'schwarz' => q{Schwarz Domains und Services GmbH &amp; Co. KG},
      'science' => q{dot Science Limited},
      'scjohnson' => q{Johnson Shareholdings, Inc.},
      'scor' => q{SCOR SE},
      'scot' => q{Dot Scot Registry Limited},
      'sd' => q{Sudan Internet Society},
      'se' => q{The Internet Infrastructure Foundation},
      'seat' => q{SEAT, S.A. (Sociedad Unipersonal)},
      'secure' => q{Amazon Registry Services, Inc.},
      'security' => q{XYZ.COM LLC},
      'seek' => q{Seek Limited},
      'select' => q{iSelect Ltd},
      'sener' => q{Sener IngenierÃ­a y Sistemas, S.A.},
      'services' => q{Fox Castle, LLC},
      'ses' => q{SES},
      'seven' => q{Seven West Media Ltd},
      'sew' => q{SEW-EURODRIVE GmbH &amp; Co KG},
      'sex' => q{ICM Registry SX LLC},
      'sexy' => q{Uniregistry, Corp.},
      'sfr' => q{Societe Francaise du Radiotelephone - SFR},
      'sg' => q{Singapore Network Information Centre (SGNIC) Pte Ltd},
      'sh' => q{Government of St. Helena},
      'shangrila' => q{Shangriâ€La International Hotel Management Limited},
      'sharp' => q{Sharp Corporation},
      'shaw' => q{Shaw Cablesystems G.P.},
      'shell' => q{Shell Information Technology International Inc},
      'shia' => q{Asia Green IT System Bilgisayar San. ve Tic. Ltd. Sti.},
      'shiksha' => q{Afilias Limited},
      'shoes' => q{Binky Galley, LLC},
      'shop' => q{GMO Registry, Inc.},
      'shopping' => q{Over Keep, LLC},
      'shouji' => q{QIHOO 360 TECHNOLOGY CO. LTD.},
      'show' => q{Snow Beach, LLC},
      'showtime' => q{CBS Domains Inc.},
      'shriram' => q{Shriram Capital Ltd.},
      'si' => q{Academic and Research Network of Slovenia (ARNES)},
      'silk' => q{Amazon Registry Services, Inc.},
      'sina' => q{Sina Corporation},
      'singles' => q{Fern Madison, LLC},
      'site' => q{DotSite Inc.},
      'sj' => q{UNINETT Norid A/S},
      'sk' => q{SK-NIC, a.s.},
      'ski' => q{STARTING DOT LIMITED},
      'skin' => q{L&#39;OrÃ©al},
      'sky' => q{Sky International AG},
      'skype' => q{Microsoft Corporation},
      'sl' => q{Sierratel},
      'sling' => q{Hughes Satellite Systems Corporation},
      'sm' => q{Telecom Italia San Marino S.p.A.},
      'smart' => q{Smart Communications, Inc. (SMART)},
      'smile' => q{Amazon Registry Services, Inc.},
      'sn' => q{Universite Cheikh Anta Diop - NIC Senegal},
      'sncf' => q{SNCF (SociÃ©tÃ© Nationale des Chemins de fer Francais)},
      'so' => q{Ministry of Post and Telecommunications},
      'soccer' => q{Foggy Shadow, LLC},
      'social' => q{United TLD Holdco Ltd.},
      'softbank' => q{SoftBank Group Corp.},
      'software' => q{United TLD Holdco, Ltd},
      'sohu' => q{Sohu.com Limited},
      'solar' => q{Ruby Town, LLC},
      'solutions' => q{Silver Cover, LLC},
      'song' => q{Amazon Registry Services, Inc.},
      'sony' => q{Sony Corporation},
      'soy' => q{Charleston Road Registry Inc.},
      'space' => q{DotSpace Inc.},
      'spiegel' => q{SPIEGEL-Verlag Rudolf Augstein GmbH &amp; Co. KG},
      'spot' => q{Amazon Registry Services, Inc.},
      'spreadbetting' => q{DOTSPREADBETTING REGISTRY LTD},
      'sr' => q{Telesur},
      'srl' => q{InterNetX Corp.},
      'srt' => q{FCA US LLC.},
      'ss' => q{Not assigned},
      'st' => q{Tecnisys},
      'stada' => q{STADA Arzneimittel AG},
      'staples' => q{Staples, Inc.},
      'star' => q{Star India Private Limited},
      'starhub' => q{StarHub Limited},
      'statebank' => q{STATE BANK OF INDIA},
      'statefarm' => q{State Farm Mutual Automobile Insurance Company},
      'statoil' => q{Statoil ASA},
      'stc' => q{Saudi Telecom Company},
      'stcgroup' => q{Saudi Telecom Company},
      'stockholm' => q{Stockholms kommun},
      'storage' => q{Self Storage Company LLC},
      'store' => q{DotStore Inc.},
      'stream' => q{dot Stream Limited},
      'studio' => q{United TLD Holdco Ltd.},
      'study' => q{OPEN UNIVERSITIES AUSTRALIA PTY LTD},
      'style' => q{Binky Moon, LLC},
      'su' => q{Russian Institute for Development of Public Networks - (ROSNIIROS)},
      'sucks' => q{Vox Populi Registry Ltd.},
      'supplies' => q{Atomic Fields, LLC},
      'supply' => q{Half Falls, LLC},
      'support' => q{Grand Orchard, LLC},
      'surf' => q{Top Level Domain Holdings Limited},
      'surgery' => q{Tin Avenue, LLC},
      'suzuki' => q{SUZUKI MOTOR CORPORATION},
      'sv' => q{SVNet},
      'swatch' => q{The Swatch Group Ltd},
      'swiftcover' => q{Swiftcover Insurance Services Limited},
      'swiss' => q{Swiss Confederation},
      'sx' => q{SX Registry SA B.V.},
      'sy' => q{National Agency for Network Services (NANS)},
      'sydney' => q{State of New South Wales, Department of Premier and Cabinet},
      'symantec' => q{Symantec Corporation},
      'systems' => q{Dash Cypress, LLC},
      'sz' => q{University of Swaziland - Department of Computer Science},
      'tab' => q{Tabcorp Holdings Limited},
      'taipei' => q{Taipei City Government},
      'talk' => q{Amazon Registry Services, Inc.},
      'taobao' => q{Alibaba Group Holding Limited},
      'target' => q{Target Domain Holdings, LLC},
      'tatamotors' => q{Tata Motors Ltd},
      'tatar' => q{Limited Liability Company &quot;Coordination Center of Regional Domain of Tatarstan Republic&quot;},
      'tattoo' => q{Uniregistry, Corp.},
      'tax' => q{Storm Orchard, LLC},
      'taxi' => q{Pine Falls, LLC},
      'tc' => q{Melrex TC},
      'tci' => q{Asia Green IT System Bilgisayar San. ve Tic. Ltd. Sti.},
      'td' => q{SociÃ©tÃ© des tÃ©lÃ©communications du Tchad (SOTEL TCHAD)},
      'tdk' => q{TDK Corporation},
      'team' => q{Atomic Lake, LLC},
      'tech' => q{Dot Tech LLC},
      'technology' => q{Auburn Falls, LLC},
      'tel' => q{Telnic Ltd.},
      'telecity' => q{TelecityGroup International Limited},
      'telefonica' => q{TelefÃ³nica S.A.},
      'temasek' => q{Temasek Holdings (Private) Limited},
      'tennis' => q{Cotton Bloom, LLC},
      'teva' => q{Teva Pharmaceutical Industries Limited},
      'tf' => q{Association FranÃ§aise pour le Nommage Internet en CoopÃ©ration (A.F.N.I.C.)},
      'tg' => q{Autorite de Reglementation des secteurs de Postes et de Telecommunications (ART&amp;P)},
      'th' => q{Thai Network Information Center Foundation},
      'thd' => q{Homer TLC, Inc.},
      'theater' => q{Blue Tigers, LLC},
      'theatre' => q{XYZ.COM LLC},
      'tiaa' => q{Teachers Insurance and Annuity Association of America},
      'tickets' => q{Accent Media Limited},
      'tienda' => q{Victor Manor, LLC},
      'tiffany' => q{Tiffany and Company},
      'tips' => q{Corn Willow, LLC},
      'tires' => q{Dog Edge, LLC},
      'tirol' => q{punkt Tirol GmbH},
      'tj' => q{Information Technology Center},
      'tjmaxx' => q{The TJX Companies, Inc.},
      'tjx' => q{The TJX Companies, Inc.},
      'tk' => q{Telecommunication Tokelau Corporation (Teletok)},
      'tkmaxx' => q{The TJX Companies, Inc.},
      'tl' => q{Ministry of Transport and  Communications; National Division of  Information and Technology},
      'tm' => q{TM Domain Registry Ltd},
      'tmall' => q{Alibaba Group Holding Limited},
      'tn' => q{Agence Tunisienne d&#39;Internet},
      'to' => q{Government of the Kingdom of Tonga - H.R.H. Crown Prince Tupouto&#39;a
      c/o Consulate of Tonga},
      'today' => q{Pearl Woods, LLC},
      'tokyo' => q{GMO Registry, Inc.},
      'tools' => q{Pioneer North, LLC},
      'top' => q{Jiangsu Bangning Science &amp; Technology Co.,Ltd.},
      'toray' => q{Toray Industries, Inc.},
      'toshiba' => q{TOSHIBA Corporation},
      'total' => q{Total SA},
      'tours' => q{Sugar Station, LLC},
      'town' => q{Koko Moon, LLC},
      'toyota' => q{TOYOTA MOTOR CORPORATION},
      'toys' => q{Pioneer Orchard, LLC},
      'tp' => q{Retired},
      'tr' => q{Middle East Technical University - Department of Computer Engineering},
      'trade' => q{Elite Registry Limited},
      'trading' => q{DOTTRADING REGISTRY LTD},
      'training' => q{Wild Willow, LLC},
      'travel' => q{Tralliance Registry Management Company, LLC.},
      'travelchannel' => q{Lifestyle Domain Holdings, Inc.},
      'travelers' => q{Travelers TLD, LLC},
      'travelersinsurance' => q{Travelers TLD, LLC},
      'trust' => q{Artemis Internet Inc},
      'trv' => q{Travelers TLD, LLC},
      'tt' => q{University of the West Indies - Faculty of Engineering},
      'tube' => q{Latin American Telecom LLC},
      'tui' => q{TUI AG},
      'tunes' => q{Amazon Registry Services, Inc.},
      'tushu' => q{Amazon Registry Services, Inc.},
      'tv' => q{Ministry of Finance and Tourism},
      'tvs' => q{T V SUNDRAM IYENGAR  &amp; SONS PRIVATE LIMITED},
      'tw' => q{Taiwan Network Information Center (TWNIC)},
      'tz' => q{Tanzania Network Information Centre (tzNIC)},
      'ua' => q{Hostmaster Ltd.},
      'ubank' => q{National Australia Bank Limited},
      'ubs' => q{UBS AG},
      'uconnect' => q{FCA US LLC.},
      'ug' => q{Uganda Online Ltd.},
      'uk' => q{Nominet UK},
      'um' => q{Not assigned},
      'unicom' => q{China United Network Communications Corporation Limited},
      'university' => q{Little Station, LLC},
      'uno' => q{Dot Latin LLC},
      'uol' => q{UBN INTERNET LTDA.},
      'ups' => q{UPS Market Driver, Inc.},
      'us' => q{NeuStar, Inc.},
      'uy' => q{SeCIU - Universidad de la Republica},
      'uz' => q{Computerization and Information Technologies Developing Center - UZINFOCOM},
      'va' => q{Holy See Secretariat of State Department of Telecommunications},
      'vacations' => q{Atomic Tigers, LLC},
      'vana' => q{Lifestyle Domain Holdings, Inc.},
      'vanguard' => q{The Vanguard Group, Inc.},
      'vc' => q{Ministry of Telecommunications, Science, Technology and Industry},
      've' => q{ComisiÃ³n Nacional de Telecomunicaciones (CONATEL)},
      'vegas' => q{Dot Vegas, Inc.},
      'ventures' => q{Binky Lake, LLC},
      'verisign' => q{VeriSign, Inc.},
      'vermÃ¶gensberater' => q{Deutsche VermÃ¶gensberatung Aktiengesellschaft DVAG},
      'vermÃ¶gensberatung' => q{Deutsche VermÃ¶gensberatung Aktiengesellschaft DVAG},
      'versicherung' => q{dotversicherung-registry GmbH},
      'vet' => q{United TLD Holdco, Ltd},
      'vg' => q{Telecommunications Regulatory Commission of the Virgin Islands},
      'vi' => q{Virgin Islands Public Telcommunications System - c/o COBEX Internet Services},
      'viajes' => q{Black Madison, LLC},
      'video' => q{United TLD Holdco, Ltd},
      'vig' => q{VIENNA INSURANCE GROUP AG Wiener Versicherung Gruppe},
      'viking' => q{Viking River Cruises (Bermuda) Ltd.},
      'villas' => q{New Sky, LLC},
      'vin' => q{Holly Shadow, LLC},
      'vip' => q{Minds + Machines Group Limited},
      'virgin' => q{Virgin Enterprises Limited},
      'visa' => q{Visa Worldwide Pte. Limited},
      'vision' => q{Koko Station, LLC},
      'vista' => q{Vistaprint Limited},
      'vistaprint' => q{Vistaprint Limited},
      'viva' => q{Saudi Telecom Company},
      'vivo' => q{Telefonica Brasil S.A.},
      'vlaanderen' => q{DNS.be vzw},
      'vn' => q{Ministry of Information and Communications of Socialist Republic of Viet Nam},
      'vodka' => q{Top Level Domain Holdings Limited},
      'volkswagen' => q{Volkswagen Group of America Inc.},
      'vote' => q{Monolith Registry LLC},
      'voting' => q{Valuetainment Corp.},
      'voto' => q{Monolith Registry LLC},
      'voyage' => q{Ruby House, LLC},
      'vu' => q{Telecom Vanuatu Limited},
      'vuelos' => q{Travel Reservations SRL},
      'wales' => q{Nominet UK},
      'walmart' => q{Wal-Mart Stores, Inc.},
      'walter' => q{Sandvik AB},
      'wang' => q{Zodiac Registry Limited},
      'wanggou' => q{Amazon Registry Services, Inc.},
      'warman' => q{Weir Group IP Limited},
      'watch' => q{Sand Shadow, LLC},
      'watches' => q{Richemont DNS Inc.},
      'weather' => q{The Weather Channel, LLC},
      'weatherchannel' => q{The Weather Channel, LLC},
      'webcam' => q{dot Webcam Limited},
      'weber' => q{Saint-Gobain Weber SA},
      'website' => q{DotWebsite Inc.},
      'wed' => q{Atgron, Inc.},
      'wedding' => q{Top Level Domain Holdings Limited},
      'weibo' => q{Sina Corporation},
      'weir' => q{Weir Group IP Limited},
      'wf' => q{Association FranÃ§aise pour le Nommage Internet en CoopÃ©ration (A.F.N.I.C.)},
      'whoswho' => q{Who&#39;s Who Registry},
      'wien' => q{punkt.wien GmbH},
      'wiki' => q{Top Level Design, LLC},
      'williamhill' => q{William Hill Organization Limited},
      'win' => q{First Registry Limited},
      'windows' => q{Microsoft Corporation},
      'wine' => q{June Station, LLC},
      'winners' => q{The TJX Companies, Inc.},
      'wme' => q{William Morris Endeavor Entertainment, LLC},
      'wolterskluwer' => q{Wolters Kluwer N.V.},
      'woodside' => q{Woodside Petroleum Limited},
      'work' => q{Top Level Domain Holdings Limited},
      'works' => q{Little Dynamite, LLC},
      'world' => q{Bitter Fields, LLC},
      'ws' => q{Government of Samoa Ministry of Foreign Affairs &amp; Trade},
      'wtc' => q{World Trade Centers Association, Inc.},
      'wtf' => q{Hidden Way, LLC},
      'xbox' => q{Microsoft Corporation},
      'xerox' => q{Xerox DNHC LLC},
      'xfinity' => q{Comcast IP Holdings I, LLC},
      'xihuan' => q{QIHOO 360 TECHNOLOGY CO. LTD.},
      'xin' => q{Elegant Leader Limited},
      'xperia' => q{Sony Mobile Communications AB},
      'xxx' => q{ICM Registry LLC},
      'xyz' => q{XYZ.COM LLC},
      'yachts' => q{DERYachts, LLC},
      'yahoo' => q{Yahoo! Domain Services Inc.},
      'yamaxun' => q{Amazon Registry Services, Inc.},
      'yandex' => q{YANDEX, LLC},
      'ye' => q{TeleYemen},
      'yodobashi' => q{YODOBASHI CAMERA CO.,LTD.},
      'yoga' => q{Top Level Domain Holdings Limited},
      'yokohama' => q{GMO Registry, Inc.},
      'you' => q{Amazon Registry Services, Inc.},
      'youtube' => q{Charleston Road Registry Inc.},
      'yt' => q{Association FranÃ§aise pour le Nommage Internet en CoopÃ©ration (A.F.N.I.C.)},
      'yun' => q{QIHOO 360 TECHNOLOGY CO. LTD.},
      'za' => q{ZA Domain Name Authority},
      'zappos' => q{Amazon Registry Services, Inc.},
      'zara' => q{Industria de DiseÃ±o Textil, S.A. (INDITEX, S.A.)},
      'zero' => q{Amazon Registry Services, Inc.},
      'zip' => q{Charleston Road Registry Inc.},
      'zippo' => q{Zadco Company},
      'zm' => q{Zambia Information and Communications Technology Authority (ZICTA)},
      'zone' => q{Outer Falls, LLC},
      'zuerich' => q{Kanton ZÃ¼rich (Canton of Zurich)},
      'zw' => q{Postal and Telecommunications Regulatory Authority of Zimbabwe (POTRAZ)},
      'Î´Î¿ÎºÎ¹Î¼Î®' => q{Internet Assigned Numbers Authority},
      'ÎµÎ»' => q{ICS-FORTH GR},
      'Ð±Ð³' => q{Imena.BG AD},
      'Ð±ÐµÐ»' => q{Reliable Software, Ltd.},
      'Ð´ÐµÑ‚Ð¸' => q{The Foundation for Network Initiatives â€œThe Smart Internetâ€},
      'ÐµÑŽ' => q{EURid vzw/asbl},
      'Ð¸ÑÐ¿Ñ‹Ñ‚Ð°Ð½Ð¸Ðµ' => q{Internet Assigned Numbers Authority},
      'ÐºÐ¾Ð¼' => q{VeriSign Sarl},
      'Ð¼ÐºÐ´' => q{Macedonian Academic Research Network Skopje},
      'Ð¼Ð¾Ð½' => q{Datacom Co.,Ltd},
      'Ð¼Ð¾ÑÐºÐ²Ð°' => q{Foundation for Assistance for Internet Technologies and Infrastructure Development (FAITID)},
      'Ð¾Ð½Ð»Ð°Ð¹Ð½' => q{CORE Association},
      'Ð¾Ñ€Ð³' => q{Public Interest Registry},
      'Ñ€ÑƒÑ' => q{Rusnames Limited},
      'Ñ€Ñ„' => q{Coordination Center for TLD RU},
      'ÑÐ°Ð¹Ñ‚' => q{CORE Association},
      'ÑÑ€Ð±' => q{Serbian National Internet Domain Registry (RNIDS)},
      'ÑƒÐºÑ€' => q{Ukrainian Network Information Centre (UANIC), Inc.},
      'Ò›Ð°Ð·' => q{Association of IT Companies of Kazakhstan},
      'Õ°Õ¡Õµ' => q{&quot;Internet Society&quot; Non-governmental Organization},
      'à¤•à¥‰à¤®' => q{VeriSign Sarl},
      'à¤¨à¥‡à¤Ÿ' => q{VeriSign Sarl},
      'à¤ªà¤°à¥€à¤•à¥à¤·à¤¾' => q{Internet Assigned Numbers Authority},
      'à¤­à¤¾à¤°à¤¤' => q{National Internet Exchange of India},
      'à¤­à¤¾à¤°à¤¤à¤®à¥' => q{Not assigned},
      'à¤­à¤¾à¤°à¥‹à¤¤' => q{Not assigned},
      'à¤¸à¤‚à¤—à¤ à¤¨' => q{Public Interest Registry},
      'à¦¬à¦¾à¦‚à¦²à¦¾' => q{Not assigned},
      'à¦­à¦¾à¦°à¦¤' => q{National Internet Exchange of India},
      'à¦­à¦¾à§°à¦¤' => q{Not assigned},
      'à¨­à¨¾à¨°à¨¤' => q{National Internet Exchange of India},
      'àª­àª¾àª°àª¤' => q{National Internet Exchange of India},
      'à¬­à¬¾à¬°à¬¤' => q{Not assigned},
      'à®‡à®¨à¯à®¤à®¿à®¯à®¾' => q{National Internet Exchange of India},
      'à®‡à®²à®™à¯à®•à¯ˆ' => q{LK Domain Registry},
      'à®šà®¿à®™à¯à®•à®ªà¯à®ªà¯‚à®°à¯' => q{Singapore Network Information Centre (SGNIC) Pte Ltd},
      'à®ªà®°à®¿à®Ÿà¯à®šà¯ˆ' => q{Internet Assigned Numbers Authority},
      'à°­à°¾à°°à°¤à±' => q{National Internet Exchange of India},
      'à²­à²¾à²°à²¤' => q{Not assigned},
      'à´­à´¾à´°à´¤à´‚' => q{Not assigned},
      'à¶½à¶‚à¶šà·' => q{LK Domain Registry},
      'à¸„à¸­à¸¡' => q{VeriSign Sarl},
      'à¹„à¸—à¸¢' => q{Thai Network Information Center Foundation},
      'áƒ’áƒ”' => q{Information Technologies Development Center (ITDC)},
      'ã¿ã‚“ãª' => q{Charleston Road Registry Inc.},
      'ã‚¯ãƒ©ã‚¦ãƒ‰' => q{Amazon Registry Services, Inc.},
      'ã‚°ãƒ¼ã‚°ãƒ«' => q{Charleston Road Registry Inc.},
      'ã‚³ãƒ ' => q{VeriSign Sarl},
      'ã‚¹ãƒˆã‚¢' => q{Amazon Registry Services, Inc.},
      'ã‚»ãƒ¼ãƒ«' => q{Amazon Registry Services, Inc.},
      'ãƒ†ã‚¹ãƒˆ' => q{Internet Assigned Numbers Authority},
      'ãƒ•ã‚¡ãƒƒã‚·ãƒ§ãƒ³' => q{Amazon Registry Services, Inc.},
      'ãƒã‚¤ãƒ³ãƒˆ' => q{Amazon Registry Services, Inc.},
      'ä¸–ç•Œ' => q{Stable Tone Limited},
      'ä¸­ä¿¡' => q{CITIC Group Corporation},
      'ä¸­å›½' => q{China Internet Network Information Center (CNNIC)},
      'ä¸­åœ‹' => q{China Internet Network Information Center (CNNIC)},
      'ä¸­æ–‡ç½‘' => q{TLD REGISTRY LIMITED},
      'ä¼ä¸š' => q{Dash McCook, LLC},
      'ä½›å±±' => q{Guangzhou YU Wei Information Technology Co., Ltd.},
      'ä¿¡æ¯' => q{Beijing Tele-info Network Technology Co., Ltd.},
      'å¥åº·' => q{Stable Tone Limited},
      'å…«å¦' => q{Zodiac Scorpio Limited},
      'å…¬å¸' => q{Computer Network Information Center of Chinese Academy of Sciences ï¼ˆChina Internet Network Information Centerï¼‰},
      'å…¬ç›Š' => q{China Organizational Name Administration Center},
      'å°æ¹¾' => q{Taiwan Network Information Center (TWNIC)},
      'å°ç£' => q{Taiwan Network Information Center (TWNIC)},
      'å•†åŸŽ' => q{Zodiac Aquarius Limited},
      'å•†åº—' => q{Wild Island, LLC},
      'å•†æ ‡' => q{HU YI GLOBAL INFORMATION RESOURCES(HOLDING) COMPANY.HONGKONG LIMITED},
      'å˜‰é‡Œ' => q{Kerry Trading Co. Limited},
      'å˜‰é‡Œå¤§é…’åº—' => q{Kerry Trading Co. Limited},
      'åœ¨çº¿' => q{TLD REGISTRY LIMITED},
      'å¤§ä¼—æ±½è½¦' => q{Volkswagen (China) Investment Co., Ltd.},
      'å¤§æ‹¿' => q{VeriSign Sarl},
      'å¨±ä¹' => q{Will Bloom, LLC},
      'å®¶é›»' => q{Amazon Registry Services, Inc.},
      'å·¥è¡Œ' => q{Industrial and Commercial Bank of China Limited},
      'å¹¿ä¸œ' => q{Guangzhou YU Wei Information Technology Co., Ltd.},
      'å¾®åš' => q{Sina Corporation},
      'æ…ˆå–„' => q{Excellent First Limited},
      'æˆ‘çˆ±ä½ ' => q{Tycoon Treasure Limited},
      'æ‰‹æœº' => q{Beijing RITT-Net Technology Development Co., Ltd},
      'æ‰‹è¡¨' => q{Richemont DNS Inc.},
      'æ”¿åŠ¡' => q{China Organizational Name Administration Center},
      'æ”¿åºœ' => q{Net-Chinese Co., Ltd.},
      'æ–°åŠ å¡' => q{Singapore Network Information Centre (SGNIC) Pte Ltd},
      'æ–°é—»' => q{Xinhua News Agency Guangdong Branch æ–°åŽé€šè®¯ç¤¾å¹¿ä¸œåˆ†ç¤¾},
      'æ—¶å°š' => q{RISE VICTORY LIMITED},
      'æ›¸ç±' => q{Amazon Registry Services, Inc.},
      'æœºæž„' => q{Public Interest Registry},
      'æµ‹è¯•' => q{Internet Assigned Numbers Authority},
      'æ·¡é©¬é”¡' => q{Temasek Holdings (Private) Limited},
      'æ¸¬è©¦' => q{Internet Assigned Numbers Authority},
      'æ¸¸æˆ' => q{Spring Fields, LLC},
      'æ¾³é–€' => q{Bureau of Telecommunications Regulation (DSRT)},
      'ç‚¹çœ‹' => q{VeriSign Sarl},
      'ç å®' => q{Richemont DNS Inc.},
      'ç§»åŠ¨' => q{Afilias Limited},
      'ç»„ç»‡æœºæž„' => q{Public Interest Registry},
      'ç½‘å€' => q{KNET Co., Ltd},
      'ç½‘åº—' => q{Zodiac Libra Limited},
      'ç½‘ç«™' => q{Global Website TLD Asia Limited},
      'ç½‘ç»œ' => q{Computer Network Information Center of Chinese Academy of Sciences ï¼ˆChina Internet Network Information Centerï¼‰},
      'è”é€š' => q{China United Network Communications Corporation Limited},
      'è¯ºåŸºäºš' => q{Nokia Corporation},
      'è°·æ­Œ' => q{Charleston Road Registry Inc.},
      'è´­ç‰©' => q{Minds + Machines Group Limited},
      'é›†å›¢' => q{Eagle Horizon Limited},
      'é›»è¨Šç›ˆç§‘' => q{PCCW Enterprises Limited},
      'é£žåˆ©æµ¦' => q{Koninklijke Philips N.V.},
      'é£Ÿå“' => q{Amazon Registry Services, Inc.},
      'é¤åŽ…' => q{HU YI GLOBAL INFORMATION RESOURCES (HOLDING) COMPANY. HONGKONG LIMITED},
      'é¦™æ ¼é‡Œæ‹‰' => q{Shangriâ€La International Hotel Management Limited},
      'é¦™æ¸¯' => q{Hong Kong Internet Registration Corporation Ltd.},
      'ë‹·ë„·' => q{VeriSign Sarl},
      'ë‹·ì»´' => q{VeriSign Sarl},
      'ì‚¼ì„±' => q{SAMSUNG SDS CO., LTD},
      'í…ŒìŠ¤íŠ¸' => q{Internet Assigned Numbers Authority},
      'í•œêµ­' => q{KISA (Korea Internet &amp; Security Agency)},
    }
  );
  
  my $flat_profile = flatten ( \%tld_profile );
  
  sub flatten {
    my $hashref = shift;
    my %results;
    @results{ keys %{ $hashref->{$_} } } = values % { $hashref->{$_} }
      for ( keys %$hashref );
    return \%results;
  }
  
  sub check_type {
    my $type = shift;
    croak "unknown TLD type: $type" unless grep { $type eq $_ } TLD_TYPES;
    return 1;
  }
  
  =head1 PUBLIC METHODS
  
    Each public function/method is described here.
    These are how you should interact with this module.
  
  =head3 C<< tlds >>
  
    This routine returns the tlds requested.
  
    my @all_tlds = tlds; #array of tlds
    my $all_tlds = tlds; #hashref of tlds and their descriptions
  
    my @cc_tlds = tlds('cc'); #array of just 'cc' type tlds
    my $cc_tlds = tlds('cc'); #hashref of just 'cc' type tlds and their descriptions
  
    Valid types are:
      cc                 - country code domains
      ccidn              - internationalized country code top-level domain 
      gtld_open          - generic domains that anyone can register
      gtld_restricted    - generic restricted registration domains
      gtld_new           - new gTLDs
      new_open           - recently added generic domains
      new_restricted     - new restricted registration domains
      reserved           - RFC2606 restricted names, not returned by tlds
  
  =cut
  
  sub tlds {
    my $type = shift;
    check_type ( $type ) if $type;
    my $results = $type ? 
      wantarray ? [ keys %{ $tld_profile{$type} } ] : 
        dclone ( $tld_profile{$type} ) :
  	wantarray ? [ map { keys %$_ } values %tld_profile ] : 
  	  $flat_profile;
    return wantarray ? @$results : $results;
  }
  
  =head3 C<< tld_exists >>
  
    This routine returns true if the given domain exists and false otherwise.
  
    die "no such domain" unless tld_exists($tld); #call without tld type 
    die "no such domain" unless tld_exists($tld, 'new_open'); #call with tld type
  
  =cut
  
  sub tld_exists {
    my ( $tld, $type )  = ( lc ( $_[0] ), $_[1] );
    check_type ( $type ) if $type;
    my $result = $type ? 
      $tld_profile{$type}{$tld} ? 1 : 0 :
      $flat_profile->{$tld} ? 1 : 0;
    return $result;
  }
  
  =head1 COPYRIGHT
  
    Copyright (c) 2003-2016 Alex Pavlovic, all rights reserved.  This program
    is free software; you can redistribute it and/or modify it under the same terms
    as Perl itself.
  
  =head1 AUTHORS
  
    Alexander Pavlovic <alex.pavlovic@devradius.com>
    Ricardo SIGNES <rjbs@cpan.org>
  
  =cut
  
  1;
NET_DOMAIN_TLD

$fatpacked{"x86_64-linux-thread-multi/NetAddr/IP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_NETADDR_IP';
  #!/usr/bin/perl -w
  
  package NetAddr::IP;
  
  use strict;
  #use diagnostics;
  use Carp;
  use NetAddr::IP::Lite 1.57 qw(Zero Zeros Ones V4mask V4net);
  use NetAddr::IP::Util 1.53 qw(
  	sub128
  	inet_aton
  	inet_any2n
  	ipv6_aton
  	isIPv4
  	ipv4to6
  	mask4to6
  	shiftleft
  	addconst
  	hasbits
  	notcontiguous
  );
  
  use AutoLoader qw(AUTOLOAD);
  
  use vars qw(
  	@EXPORT_OK
  	@EXPORT_FAIL
  	@ISA
  	$VERSION
  	$_netlimit
  	$rfc3021
  );
  require Exporter;
  
  @EXPORT_OK = qw(Compact Coalesce Zero Zeros Ones V4mask V4net netlimit);
  @EXPORT_FAIL = qw($_netlimit);
  
  @ISA = qw(Exporter NetAddr::IP::Lite);
  
  $VERSION = do { sprintf " %d.%03d", (q$Revision: 4.79 $ =~ /\d+/g) };
  
  $rfc3021 = 0;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  NetAddr::IP - Manages IPv4 and IPv6 addresses and subnets
  
  =head1 SYNOPSIS
  
    use NetAddr::IP qw(
  	Compact
  	Coalesce
  	Zeros
  	Ones
  	V4mask
  	V4net
  	netlimit
  	:aton		DEPRECATED
  	:lower
  	:upper
  	:old_storable
  	:old_nth
  	:rfc3021
  	:nofqdn
    );
  
    NOTE: NetAddr::IP::Util has a full complement of network address
  	utilities to convert back and forth between binary and text.
  
  	inet_aton, inet_ntoa, ipv6_aton, ipv6_ntoa 
  	ipv6_n2x, ipv6_n2d inet_any2d, inet_n2dx, 
  	inet_n2ad, inetanyto6, ipv6to4
  
  See L<NetAddr::IP::Util>
  
  
    my $ip = new NetAddr::IP '127.0.0.1';
  	 or if you prefer
    my $ip = NetAddr::IP->new('127.0.0.1);
  	or from a packed IPv4 address
    my $ip = new_from_aton NetAddr::IP (inet_aton('127.0.0.1'));
  	or from an octal filtered IPv4 address
    my $ip = new_no NetAddr::IP '127.012.0.0';
  
    print "The address is ", $ip->addr, " with mask ", $ip->mask, "\n" ;
  
    if ($ip->within(new NetAddr::IP "127.0.0.0", "255.0.0.0")) {
        print "Is a loopback address\n";
    }
  
  				# This prints 127.0.0.1/32
    print "You can also say $ip...\n";
  
  * The following four functions return ipV6 representations of:
  
    ::                                       = Zeros();
    FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF  = Ones();
    FFFF:FFFF:FFFF:FFFF:FFFF:FFFF::          = V4mask();
    ::FFFF:FFFF                              = V4net();
  
    Will also return an ipV4 or ipV6 representation of a
    resolvable Fully Qualified Domanin Name (FQDN).
  
  ###### DEPRECATED, will be remove in version 5 ############
  
    * To accept addresses in the format as returned by
    inet_aton, invoke the module as:
  
    use NetAddr::IP qw(:aton);
  
  ###### USE new_from_aton instead ##########################
  
  * To enable usage of legacy data files containing NetAddr::IP
  objects stored using the L<Storable> module.
  
    use NetAddr::IP qw(:old_storable);
  
  * To compact many smaller subnets (see: C<$me-E<gt>compact($addr1,$addr2,...)>
  
    @compacted_object_list = Compact(@object_list)
  
  * Return a reference to list of C<NetAddr::IP> subnets of
  C<$masklen> mask length, when C<$number> or more addresses from
  C<@list_of_subnets> are found to be contained in said subnet.
  
    $arrayref = Coalesce($masklen, $number, @list_of_subnets)
  
  * By default B<NetAddr::IP> functions and methods return string IPv6
  addresses in uppercase.  To change that to lowercase:
  
  NOTE: the AUGUST 2010 RFC5952 states:
  
      4.3. Lowercase
  
        The characters "a", "b", "c", "d", "e", and "f" in an IPv6
        address MUST be represented in lowercase.
  
  It is recommended that all NEW applications using NetAddr::IP be
  invoked as shown on the next line.
  
    use NetAddr::IP qw(:lower);
  
  * To ensure the current IPv6 string case behavior even if the default changes:
  
    use NetAddr::IP qw(:upper);
  
  * To set a limit on the size of B<nets> processed or returned by NetAddr::IP.
  
  Set the maximum number of nets beyond which NetAddr::IP will return
  an error as a power of 2 (default 16 or 65536 nets). Each 2**16
  consumes approximately 4 megs of memory. A 2**20 consumes 64 megs of
  memory, A 2**24 consumes 1 gigabyte of memory.
  
    use NetAddr::IP qw(netlimit);
    netlimit 20;
  
  The maximum B<netlimit> allowed is 2**24. Attempts to set limits below
  the default of 16 or above the maximum of 24 are ignored.
  
  Returns true on success, otherwise C<undef>.
  
  =cut
  
  $_netlimit = 2 ** 16;			# default
  
  sub netlimit($) {
    return undef unless $_[0];
    return undef if $_[0] =~ /\D/;
    return undef if $_[0] < 16;
    return undef if $_[0] > 24;
    $_netlimit = 2 ** $_[0];
  };
  
  =head1 INSTALLATION
  
  Un-tar the distribution in an appropriate directory and type:
  
  	perl Makefile.PL
  	make
  	make test
  	make install
  
  B<NetAddr::IP> depends on B<NetAddr::IP::Util> which installs by
  default with its primary functions compiled using Perl's XS extensions
  to build a C library. If you do not have a C complier available or
  would like the slower Pure Perl version for some other reason, then
  type:
  
  	perl Makefile.PL -noxs
  	make
  	make test
  	make install
  
  =head1 DESCRIPTION
  
  This module provides an object-oriented abstraction on top of IP
  addresses or IP subnets that allows for easy manipulations.  Version
  4.xx of NetAddr::IP will work with older versions of Perl and is
  compatible with Math::BigInt.
  
  The internal representation of all IP objects is in 128 bit IPv6 notation.
  IPv4 and IPv6 objects may be freely mixed.
  
  =head2 Overloaded Operators
  
  Many operators have been overloaded, as described below:
  
  =cut
  
  				#############################################
  				# These are the overload methods, placed here
  				# for convenience.
  				#############################################
  
  use overload
  
      '@{}'	=> sub {
  	return [ $_[0]->hostenum ];
      };
  
  =pod
  
  =over
  
  =item B<Assignment (C<=>)>
  
  Has been optimized to copy one NetAddr::IP object to another very quickly.
  
  =item B<C<-E<gt>copy()>>
  
  The B<assignment (C<=>)> operation is only put in to operation when the
  copied object is further mutated by another overloaded operation. See
  L<overload> B<SPECIAL SYMBOLS FOR "use overload"> for details.
  
  B<C<-E<gt>copy()>> actually creates a new object when called.
  
  =item B<Stringification>
  
  An object can be used just as a string. For instance, the following code
  
  	my $ip = new NetAddr::IP '192.168.1.123';
  	print "$ip\n";
  
  Will print the string 192.168.1.123/32.
  
  =item B<Equality>
  
  You can test for equality with either C<eq> or C<==>. C<eq> allows
  comparison with arbitrary strings as well as NetAddr::IP objects. The
  following example:
  
      if (NetAddr::IP->new('127.0.0.1','255.0.0.0') eq '127.0.0.1/8')
         { print "Yes\n"; }
  
  will print out "Yes".
  
  Comparison with C<==> requires both operands to be NetAddr::IP objects.
  
  In both cases, a true value is returned if the CIDR representation of
  the operands is equal.
  
  =item B<Comparison via E<gt>, E<lt>, E<gt>=, E<lt>=, E<lt>=E<gt> and C<cmp>>
  
  Internally, all network objects are represented in 128 bit format.
  The numeric representation of the network is compared through the
  corresponding operation. Comparisons are tried first on the address portion
  of the object and if that is equal then the NUMERIC cidr portion of the
  masks are compared. This leads to the counterintuitive result that
  
  	/24 > /16
  
  Comparison should not be done on netaddr objects with different CIDR as
  this may produce indeterminate - unexpected results,
  rather the determination of which netblock is larger or smaller should be
  done by comparing
  
  	$ip1->masklen <=> $ip2->masklen
  
  =item B<Addition of a constant (C<+>)>
  
  Add a 32 bit signed constant to the address part of a NetAddr object.
  This operation changes the address part to point so many hosts above the
  current objects start address. For instance, this code:
  
      print NetAddr::IP->new('127.0.0.1/8') + 5;
  
  will output 127.0.0.6/8. The address will wrap around at the broadcast
  back to the network address. This code:
  
      print NetAddr::IP->new('10.0.0.1/24') + 255;
  
      outputs 10.0.0.0/24.
  
  Returns the the unchanged object when the constant is missing or out of
  range.
  
      2147483647 <= constant >= -2147483648
  
  =item B<Subtraction of a constant (C<->)>
  
  The complement of the addition of a constant.
  
  =item B<Difference (C<->)>
  
  Returns the difference between the address parts of two NetAddr::IP
  objects address parts as a 32 bit signed number.
  
  Returns B<undef> if the difference is out of range.
  
  (See range restrictions on Addition above)
  
  =item B<Auto-increment>
  
  Auto-incrementing a NetAddr::IP object causes the address part to be
  adjusted to the next host address within the subnet. It will wrap at
  the broadcast address and start again from the network address.
  
  =item B<Auto-decrement>
  
  Auto-decrementing a NetAddr::IP object performs exactly the opposite
  of auto-incrementing it, as you would expect.
  
  =cut
  
  				#############################################
  				# End of the overload methods.
  				#############################################
  
  
  # Preloaded methods go here.
  
  =pod
  
  =back
  
  =head2 Serializing and Deserializing
  
  This module defines hooks to collaborate with L<Storable> for
  serializing C<NetAddr::IP> objects, through compact and human readable
  strings. You can revert to the old format by invoking this module as
  
    use NetAddr::IP ':old_storable';
  
  You must do this if you have legacy data files containing NetAddr::IP
  objects stored using the L<Storable> module.
  
  =cut
  
  my $full_format = "%04X:%04X:%04X:%04X:%04X:%04X:%D.%D.%D.%D";
  my $full6_format = "%04X:%04X:%04X:%04X:%04X:%04X:%04X:%04X";
  
  sub import
  {
      if (grep { $_ eq ':old_storable' } @_) {
  	@_ = grep { $_ ne ':old_storable' } @_;
      } else {
  	*{STORABLE_freeze} = sub
  	{
  	    my $self = shift;
  	    return $self->cidr();	# use stringification
  	};
  	*{STORABLE_thaw} = sub
  	{
  	    my $self	= shift;
  	    my $cloning	= shift;	# Not used
  	    my $serial	= shift;
  
  	    my $ip = new NetAddr::IP $serial;
  	    $self->{addr} = $ip->{addr};
  	    $self->{mask} = $ip->{mask};
  	    $self->{isv6} = $ip->{isv6};
  	    return;
  	};
      }
  
      if (grep { $_ eq ':aton' } @_)
      {
  	$NetAddr::IP::Lite::Accept_Binary_IP = 1;
  	@_ = grep { $_ ne ':aton' } @_;
      }
      if (grep { $_ eq ':old_nth' } @_)
      {
  	$NetAddr::IP::Lite::Old_nth = 1;
  	@_ = grep { $_ ne ':old_nth' } @_;
      }
      if (grep { $_ eq ':nofqdn'} @_)
      {
  	$NetAddr::IP::NetAddr::IP::Lite::NoFQDN = 1;
  	@_ = grep { $_ ne ':nofqdn' } @_;
      }
      if (grep { $_ eq ':lower' } @_)
      {
          $full_format = lc($full_format);
          $full6_format = lc($full6_format);
          NetAddr::IP::Util::lower();
  	@_ = grep { $_ ne ':lower' } @_;
      }
      if (grep { $_ eq ':upper' } @_)
      {
          $full_format = uc($full_format);
          $full6_format = uc($full6_format);
          NetAddr::IP::Util::upper();
  	@_ = grep { $_ ne ':upper' } @_;
      }
      if (grep { $_ eq ':rfc3021' } @_)
      {
  	$rfc3021 = 1;
          @_ = grep { $_ ne ':rfc3021' } @_;
      }
      NetAddr::IP->export_to_level(1, @_);
  }
  
  sub compact {
      return (ref $_[0] eq 'ARRAY')
  	? compactref($_[0])	# Compact(\@list)
  	: @{compactref(\@_)};	# Compact(@list)  or ->compact(@list)
  }
  
  *Compact = \&compact;
  
  sub Coalesce {
    return &coalesce;
  }
  
  sub hostenumref($) {
    my $r = _splitref(0,$_[0]);
    unless ((notcontiguous($_[0]->{mask}))[1] == 128 ||
  	  ($rfc3021 && $_[0]->masklen == 31) ) {
      splice(@$r, 0, 1);
      splice(@$r, scalar @$r - 1, 1);
    }
    return $r;
  }
  
  sub splitref {
    unshift @_, 0;	# mark as no reverse
  # perl 5.8.4 fails with this operation. see perl bug [ 23429]
  #  goto &_splitref;
    &_splitref;
  }
  
  sub rsplitref {
    unshift @_, 1;	# mark as reversed
  # perl 5.8.4 fails with this operation. see perl bug [ 23429]
  #  goto &_splitref;
    &_splitref;
  }
  
  sub split {
    unshift @_, 0;	# mark as no reverse
    my $rv = &_splitref;
    return $rv ? @$rv : ();
  }
  
  sub rsplit {
    unshift @_, 1;	# mark as reversed
    my $rv = &_splitref;
    return $rv ? @$rv : ();
  }
  
  sub full($) {
    if (! $_[0]->{isv6} && isIPv4($_[0]->{addr})) {
      my @hex = (unpack("n8",$_[0]->{addr}));
      $hex[9] = $hex[7] & 0xff;
      $hex[8] = $hex[7] >> 8;
      $hex[7] = $hex[6] & 0xff;
      $hex[6] >>= 8;
      return sprintf($full_format,@hex);
    } else {
      &full6;
    }
  }
  
  sub full6($) {
    my @hex = (unpack("n8",$_[0]->{addr}));
    return sprintf($full6_format,@hex);
  }
  
  sub full6m($) {
    my @hex = (unpack("n8",$_[0]->{mask}));
    return sprintf($full6_format,@hex);
  }
  
  sub DESTROY {};
  
  1;
  __END__
  
  sub do_prefix ($$$) {
      my $mask	= shift;
      my $faddr	= shift;
      my $laddr	= shift;
  
      if ($mask > 24) {
  	return "$faddr->[0].$faddr->[1].$faddr->[2].$faddr->[3]-$laddr->[3]";
      }
      elsif ($mask == 24) {
  	return "$faddr->[0].$faddr->[1].$faddr->[2].";
      }
      elsif ($mask > 16) {
  	return "$faddr->[0].$faddr->[1].$faddr->[2]-$laddr->[2].";
      }
      elsif ($mask == 16) {
  	return "$faddr->[0].$faddr->[1].";
      }
      elsif ($mask > 8) {
  	return "$faddr->[0].$faddr->[1]-$laddr->[1].";
      }
      elsif ($mask == 8) {
  	return "$faddr->[0].";
      }
      else {
  	return "$faddr->[0]-$laddr->[0]";
      }
  }
  
  =pod
  
  =head2 Methods
  
  =over
  
  =item C<-E<gt>new([$addr, [ $mask|IPv6 ]])>
  
  =item C<-E<gt>new6([$addr, [ $mask]])>
  
  =item C<-E<gt>new_no([$addr, [ $mask]])>
  
  =item C<-E<gt>new_from_aton($netaddr)>
  
  =item new_cis and new_cis6 are DEPRECATED 
  
  =item C<-E<gt>new_cis("$addr $mask)>
  
  =item C<-E<gt>new_cis6("$addr $mask)>
  
  The first two methods create a new address with the supplied address in
  C<$addr> and an optional netmask C<$mask>, which can be omitted to get 
  a /32 or /128 netmask for IPv4 / IPv6 addresses respectively.
  
  The third method C<new_no> is exclusively for IPv4 addresses and filters
  improperly formatted
  dot quad strings for leading 0's that would normally be interpreted as octal
  format by NetAddr per the specifications for inet_aton.
  
  B<new_from_aton> takes a packed IPv4 address and assumes a /32 mask. This
  function replaces the DEPRECATED :aton functionality which is fundamentally
  broken.
  
  The last two methods B<new_cis> and B<new_cis6> differ from B<new> and
  B<new6> only in that they except the common Cisco address notation for
  address/mask pairs with a B<space> as a separator instead of a slash (/)
  
  These methods are DEPRECATED because the functionality is now included
  in the other "new" methods
  
    i.e.  ->new_cis('1.2.3.0 24')
          or
          ->new_cis6('::1.2.3.0 120')
  
  C<-E<gt>new6> and
  C<-E<gt>new_cis6> mark the address as being in ipV6 address space even
  if the format would suggest otherwise.
  
    i.e.  ->new6('1.2.3.4') will result in ::102:304
  
    addresses submitted to ->new in ipV6 notation will
    remain in that notation permanently. i.e.
          ->new('::1.2.3.4') will result in ::102:304
    whereas new('1.2.3.4') would print out as 1.2.3.4
  
    See "STRINGIFICATION" below.
  
  C<$addr> can be almost anything that can be resolved to an IP address
  in all the notations I have seen over time. It can optionally contain
  the mask in CIDR notation.
  
  B<prefix> notation is understood, with the limitation that the range
  specified by the prefix must match with a valid subnet.
  
  Addresses in the same format returned by C<inet_aton> or
  C<gethostbyname> can also be understood, although no mask can be
  specified for them. The default is to not attempt to recognize this
  format, as it seems to be seldom used.
  
  To accept addresses in that format, invoke the module as in
  
    use NetAddr::IP ':aton'
  
  If called with no arguments, 'default' is assumed.
  
  If called with an empty string as the argument, returns 'undef'
  
  C<$addr> can be any of the following and possibly more...
  
    n.n
    n.n/mm
    n.n.n
    n.n.n/mm
    n.n.n.n
    n.n.n.n/mm		32 bit cidr notation
    n.n.n.n/m.m.m.m
    loopback, localhost, broadcast, any, default
    x.x.x.x/host
    0xABCDEF, 0b111111000101011110, (a bcd number)
    a netaddr as returned by 'inet_aton'
  
  
  Any RFC1884 notation
  
    ::n.n.n.n
    ::n.n.n.n/mmm		128 bit cidr notation
    ::n.n.n.n/::m.m.m.m
    ::x:x
    ::x:x/mmm
    x:x:x:x:x:x:x:x
    x:x:x:x:x:x:x:x/mmm
    x:x:x:x:x:x:x:x/m:m:m:m:m:m:m:m any RFC1884 notation
    loopback, localhost, unspecified, any, default
    ::x:x/host
    0xABCDEF, 0b111111000101011110 within the limits
    of perl's number resolution
    123456789012  a 'big' bcd number (bigger than perl likes)
    and Math::BigInt
  
  A Fully Qualified Domain Name which returns an ipV4 address or an ipV6
  address, embodied in that order. This previously undocumented feature
  may be disabled with:
  
  	use NetAddr::IP::Lite ':nofqdn';
  
  If called with no arguments, 'default' is assumed.
  
  If called with an empty string as the argument, returns 'undef'
  
  =item C<-E<gt>broadcast()>
  
  Returns a new object referring to the broadcast address of a given
  subnet. The broadcast address has all ones in all the bit positions
  where the netmask has zero bits. This is normally used to address all
  the hosts in a given subnet.
  
  =item C<-E<gt>network()>
  
  Returns a new object referring to the network address of a given
  subnet. A network address has all zero bits where the bits of the
  netmask are zero. Normally this is used to refer to a subnet.
  
  =item C<-E<gt>addr()>
  
  Returns a scalar with the address part of the object as an IPv4 or IPv6 text
  string as appropriate. This is useful for printing or for passing the
  address part of the NetAddr::IP object to other components that expect an IP
  address. If the object is an ipV6 address or was created using ->new6($ip)
  it will be reported in ipV6 hex format otherwise it will be reported in dot
  quad format only if it resides in ipV4 address space.
  
  =item C<-E<gt>mask()>
  
  Returns a scalar with the mask as an IPv4 or IPv6 text string as
  described above.
  
  =item C<-E<gt>masklen()>
  
  Returns a scalar the number of one bits in the mask.
  
  =item C<-E<gt>bits()>
  
  Returns the width of the address in bits. Normally 32 for v4 and 128 for v6.
  
  =item C<-E<gt>version()>
  
  Returns the version of the address or subnet. Currently this can be
  either 4 or 6.
  
  =item C<-E<gt>cidr()>
  
  Returns a scalar with the address and mask in CIDR notation. A
  NetAddr::IP object I<stringifies> to the result of this function.
  (see comments about ->new6() and ->addr() for output formats)
  
  =item C<-E<gt>aton()>
  
  Returns the address part of the NetAddr::IP object in the same format
  as the C<inet_aton()> or C<ipv6_aton> function respectively. If the object
  was created using ->new6($ip), the address returned will always be in ipV6
  format, even for addresses in ipV4 address space.
  
  =item C<-E<gt>range()>
  
  Returns a scalar with the base address and the broadcast address
  separated by a dash and spaces. This is called range notation.
  
  =item C<-E<gt>prefix()>
  
  Returns a scalar with the address and mask in ipV4 prefix
  representation. This is useful for some programs, which expect its
  input to be in this format. This method will include the broadcast
  address in the encoding.
  
  =cut
  
  # only applicable to ipV4
  sub prefix($) {
      return undef if $_[0]->{isv6};
      my $mask = (notcontiguous($_[0]->{mask}))[1];
      return $_[0]->addr if $mask == 128;
      $mask -= 96;
      my @faddr = split (/\./, $_[0]->first->addr);
      my @laddr = split (/\./, $_[0]->broadcast->addr);
      return do_prefix $mask, \@faddr, \@laddr;
  }
  
  =item C<-E<gt>nprefix()>
  
  Just as C<-E<gt>prefix()>, but does not include the broadcast address.
  
  =cut
  
  # only applicable to ipV4
  sub nprefix($) {
      return undef if $_[0]->{isv6};
      my $mask = (notcontiguous($_[0]->{mask}))[1];
      return $_[0]->addr if $mask == 128;
      $mask -= 96;
      my @faddr = split (/\./, $_[0]->first->addr);
      my @laddr = split (/\./, $_[0]->last->addr);
      return do_prefix $mask, \@faddr, \@laddr;
  }
  
  =pod
  
  =item C<-E<gt>numeric()>
  
  When called in a scalar context, will return a numeric representation
  of the address part of the IP address. When called in an array
  contest, it returns a list of two elements. The first element is as
  described, the second element is the numeric representation of the
  netmask.
  
  This method is essential for serializing the representation of a
  subnet.
  
  =item C<-E<gt>bigint()>
  
  When called in scalar context, will return a Math::BigInt
  representation of the address part of the IP address. When called in
  an array context, it returns a list of two elements, The first
  element is as described, the second element is the Math::BigInt
  representation of the netmask.
  
  =item C<-E<gt>wildcard()>
  
  When called in a scalar context, returns the wildcard bits
  corresponding to the mask, in dotted-quad or ipV6 format as applicable.
  
  When called in an array context, returns a two-element array. The
  first element, is the address part. The second element, is the
  wildcard translation of the mask.
  
  =cut
  
  sub wildcard($) {
    my $copy = $_[0]->copy;
    $copy->{addr} = ~ $copy->{mask};
    $copy->{addr} &= V4net unless $copy->{isv6};
    if (wantarray) {
      return ($_[0]->addr, $copy->addr);
    }
    return $copy->addr;
  }
  
  =pod
  
  =item C<-E<gt>short()>
  
  Returns the address part in a short or compact notation.
  
    (ie, 127.0.0.1 becomes 127.1).
  
  Works with both, V4 and V6.
  
  =cut
  
  sub _compact_v6 ($) {
      my $addr = shift;
  
      my @o = split /:/, $addr;
      return $addr unless @o and grep { $_ =~ m/^0+$/ } @o;
  
      my @candidates	= ();
      my $start		= undef;
  
      for my $i (0 .. $#o)
      {
  	if (defined $start)
  	{
  	    if ($o[$i] !~ m/^0+$/)
  	    {
  		push @candidates, [ $start, $i - $start ];
  		$start = undef;
  	    }
  	}
  	else
  	{
  	    $start = $i if $o[$i] =~ m/^0+$/;
  	}
      }
  
      push @candidates, [$start, 8 - $start] if defined $start;
  
      my $l = (sort { $b->[1] <=> $a->[1] } @candidates)[0];
  
      return $addr unless defined $l;
  
      $addr = $l->[0] == 0 ? '' : join ':', @o[0 .. $l->[0] - 1];
      $addr .= '::';
      $addr .= join ':', @o[$l->[0] + $l->[1] .. $#o];
      $addr =~ s/(^|:)0{1,3}/$1/g;
  
      return $addr;
  }
  
  
  #sub _old_compV6 {
  #  my @addr = split(':',shift);
  #  my $found = 0;
  #  my $v;
  #  foreach(0..$#addr) {
  #    ($v = $addr[$_]) =~ s/^0+//;
  #    $addr[$_] = $v || 0;
  #  }
  #  @_ = reverse(1..$#addr);
  #  foreach(@_) {
  #    if ($addr[$_] || $addr[$_ -1]) {
  #      last if $found;
  #      next;
  #    }
  #    $addr[$_] = $addr[$_ -1] = '';
  #    $found = '1';
  #  }
  #  (my $rv = join(':',@addr)) =~ s/:+:/::/;
  #  return $rv;
  #}
  
  # thanks to Rob Riepel <riepel@networking.Stanford.EDU>
  # for this faster and more compact solution 11-17-08
  sub _compV6 ($) {
      my $ip = shift;
      return $ip unless my @candidates = $ip =~ /((?:^|:)0(?::0)+(?::|$))/g;
      my $longest = (sort { length($b) <=> length($a) } @candidates)[0];
      $ip =~ s/$longest/::/;
      return $ip;
  }
  
  sub short($) {
    my $addr = $_[0]->addr;
    if (! $_[0]->{isv6} && isIPv4($_[0]->{addr})) {
      my @o = split(/\./, $addr, 4);
      splice(@o, 1, 2) if $o[1] == 0 and $o[2] == 0;
      return join '.', @o;
    }
    return _compV6($addr);
  }
  
  =item C<-E<gt>canon()>
  
  Returns the address part in canonical notation as a string.  For
  ipV4, this is dotted quad, and is the same as the return value from 
  "->addr()".  For ipV6 it is as per RFC5952, and is the same as the LOWER CASE value
  returned by "->short()".
  
  =cut
  
  sub canon($) {
    my $addr = $_[0]->addr;
    return $_[0]->{isv6} ? lc _compV6($addr) : $addr;
  }
  
  =item C<-E<gt>full()>
  
  Returns the address part in FULL notation for
  ipV4 and ipV6 respectively.
  
    i.e. for ipV4
      0000:0000:0000:0000:0000:0000:127.0.0.1
  
         for ipV6
      0000:0000:0000:0000:0000:0000:0000:0000
  
  To force ipV4 addresses into full ipV6 format use:
  
  =item C<-E<gt>full6()>
  
  Returns the address part in FULL ipV6 notation
  
  =item C<-E<gt>full6m()>
     
  Returns the mask part in FULL ipV6 notation
  
  =item C<$me-E<gt>contains($other)>
  
  Returns true when C<$me> completely contains C<$other>. False is
  returned otherwise and C<undef> is returned if C<$me> and C<$other>
  are not both C<NetAddr::IP> objects.
  
  =item C<$me-E<gt>within($other)>
  
  The complement of C<-E<gt>contains()>. Returns true when C<$me> is
  completely contained within C<$other>.
  
  Note that C<$me> and C<$other> must be C<NetAddr::IP> objects.
  
  =item C-E<gt>is_rfc1918()>
  
  Returns true when C<$me> is an RFC 1918 address.
  
    10.0.0.0      -   10.255.255.255  (10/8 prefix)
    172.16.0.0    -   172.31.255.255  (172.16/12 prefix)
    192.168.0.0   -   192.168.255.255 (192.168/16 prefix)
  
  =item C<-E<gt>is_local()>
  
  Returns true when C<$me> is a local network address.
     
          i.e.    ipV4    127.0.0.0 - 127.255.255.255
    or            ipV6    === ::1
  
  =item C<-E<gt>splitref($bits,[optional $bits1,$bits2,...])>
  
  Returns a reference to a list of objects, representing subnets of C<bits> mask
  produced by splitting the original object, which is left
  unchanged. Note that C<$bits> must be longer than the original
  mask in order for it to be splittable.
  
  ERROR conditions:
  
    ->splitref will DIE with the message 'netlimit exceeded'
      if the number of return objects exceeds 'netlimit'.
      See function 'netlimit' above (default 2**16 or 65536 nets).
  
    ->splitref returns undef when C<bits> or the (bits list)
      will not fit within the original object.
  
    ->splitref returns undef if a supplied ipV4, ipV6, or NetAddr
      mask in inappropriately formatted,
  
  B<bits> may be a CIDR mask, a dot quad or ipV6 string or a NetAddr::IP object.
  If C<bits> is missing, the object is split for into all available addresses
  within the ipV4 or ipV6 object ( auto-mask of CIDR 32, 128 respectively ).
  
  With optional additional C<bits> list, the original object is split into
  parts sized based on the list. NOTE: a short list will replicate the last
  item. If the last item is too large to for what remains of the object after
  splitting off the first parts of the list, a "best fits" list of remaining
  objects will be returned based on an increasing sort of the CIDR values of
  the C<bits> list.
  
    i.e.	my $ip = new NetAddr::IP('192.168.0.0/24');
  	my $objptr = $ip->split(28, 29, 28, 29, 26);
  
     has split plan 28 29 28 29 26 26 26 28
     and returns this list of objects
  
  	192.168.0.0/28
  	192.168.0.16/29
  	192.168.0.24/28
  	192.168.0.40/29
  	192.168.0.48/26
  	192.168.0.112/26
  	192.168.0.176/26
  	192.168.0.240/28
  
  NOTE: that /26 replicates twice beyond the original request and /28 fills
  the remaining return object requirement.
  
  =item C<-E<gt>rsplitref($bits,[optional $bits1,$bits2,...])>
  
  C<-E<gt>rsplitref> is the same as C<-E<gt>splitref> above except that the split plan is
  applied to the original object in reverse order.
  
    i.e.	my $ip = new NetAddr::IP('192.168.0.0/24');
  	my @objects = $ip->split(28, 29, 28, 29, 26);
  
     has split plan 28 26 26 26 29 28 29 28
     and returns this list of objects
  
  	192.168.0.0/28
  	192.168.0.16/26
  	192.168.0.80/26
  	192.168.0.144/26
  	192.168.0.208/29
  	192.168.0.216/28
  	192.168.0.232/29
  	192.168.0.240/28
  
  =item C<-E<gt>split($bits,[optional $bits1,$bits2,...])>
  
  Similar to C<-E<gt>splitref> above but returns the list rather than a list
  reference. You may not want to use this if a large number of objects is
  expected.
  
  =item C<-E<gt>rsplit($bits,[optional $bits1,$bits2,...])>
  
  Similar to C<-E<gt>rsplitref> above but returns the list rather than a list
  reference. You may not want to use this if a large number of objects is
  expected.
  
  =cut
  
  # input:	$naip,
  #		@bits,		 list of masks for splits
  #
  #  returns:	empty array request will not fit in submitted net
  #		(\@bits,undef)	 if there is just one plan item i.e. return original net
  #		(\@bits,\%masks) for a real plan
  #
  sub _splitplan {
    my($ip,@bits) = @_;
    my $addr = $ip->addr();
    my $isV6 = $ip->{isv6};
    unless (@bits) {
      $bits[0] = $isV6 ? 128 : 32;
    }
    my $basem = $ip->masklen();
  
    my(%nets,$dif);
    my $denom = 0;
  
    my($x,$maddr);
    foreach(@bits) {
      if (ref $_) {	# is a NetAddr::IP
        $x = $_->{isv6} ? $_->{addr} : $_->{addr} | V4mask;
        ($x,$maddr) = notcontiguous($x);
        return () if $x;	# spurious bits
        $_ = $isV6 ? $maddr : $maddr - 96;
      }
      elsif ( $_ =~ /^d+$/ ) {		# is a negative number of the form -nnnn
  	;
      }
      elsif ($_ = NetAddr::IP->new($addr,$_,$isV6)) { # will be undefined if bad mask and will fall into oops!
        $_ = $_->masklen();
      }
      else {
        return ();	# oops!
      }
      $dif = $_ - $basem;			# for normalization
      return () if $dif < 0;		# overange nets not allowed
      return (\@bits,undef) unless ($dif || $#bits);	# return if original net = mask alone
      $denom = $dif if $dif > $denom;
      next if exists $nets{$_};
      $nets{$_} = $_ - $basem;		# for normalization
    }
  
  # $denom is the normalization denominator, since these are all exponents
  # normalization can use add/subtract to accomplish normalization
  #
  # keys of %nets are the masks used by this split
  # values of %nets are the normalized weighting for
  # calculating when the split is "full" or complete
  # %masks values contain the actual masks for each split subnet
  # @bits contains the masks in the order the user actually wants them
  #
    my %masks;					# calculate masks
    my $maskbase = $isV6 ? 128 : 32;
    foreach( keys %nets ) {
      $nets{$_} = 2 ** ($denom - $nets{$_});
      $masks{$_} = shiftleft(Ones, $maskbase - $_);
    }
  
    my @plan;
    my $idx = 0;
    $denom = 2 ** $denom;
    PLAN:
    while ($denom > 0) {				# make a net plan
      my $nexmask = ($idx < $#bits) ? $bits[$idx] : $bits[$#bits];
      ++$idx;
      unless (($denom -= $nets{$nexmask}) < 0) {
        return () if (push @plan, $nexmask) > $_netlimit;
        next;
      }
  # a fractional net is needed that is not in the mask list or the replicant
      $denom += $nets{$nexmask};			# restore mistake
    TRY:
      foreach (sort { $a <=> $b } keys %nets) {
        next TRY if $nexmask > $_;
        do {
  	next TRY if $denom - $nets{$_} < 0;
  	return () if (push @plan, $_) > $_netlimit;
  	$denom -= $nets{$_};
        } while $denom;
      }
      die 'ERROR: miscalculated weights' if $denom;
    }
    return () if $idx < @bits;			# overrange original subnet request
    return (\@plan,\%masks);
  }
  
  # input:	$rev,	# t/f
  #		$naip,
  #		@bits	# list of masks for split
  #
  sub _splitref {
    my $rev = shift;
    my($plan,$masks) = &_splitplan;
  # bug report 82719
    croak("netmask error: overrange or spurious bits") unless defined $plan;
  #  return undef unless $plan;
    my $net = $_[0]->network();
    return [$net] unless $masks;
    my $addr = $net->{addr};
    my $isV6 = $net->{isv6};
    my @plan = $rev ? reverse @$plan : @$plan;
  # print "plan @plan\n";
  
  # create splits
    my @ret;
    while ($_ = shift @plan) {
      my $mask = $masks->{$_};
      push @ret, $net->_new($addr,$mask,$isV6);
      last unless @plan;
      $addr = (sub128($addr,$mask))[1];
    }
    return \@ret;
  }
  
  =pod
  
  =item C<-E<gt>hostenum()>
  
  Returns the list of hosts within a subnet.
  
  ERROR conditions:
  
    ->hostenum will DIE with the message 'netlimit exceeded'
      if the number of return objects exceeds 'netlimit'.
      See function 'netlimit' above (default 2**16 or 65536 nets).
  
  =cut
  
  sub hostenum ($) {
      return @{$_[0]->hostenumref};
  }
  
  =pod
  
  =item C<-E<gt>hostenumref()>
  
  Faster version of C<-E<gt>hostenum()>, returning a reference to a list.
  
  NOTE: hostenum and hostenumref report zero (0) useable hosts in a /31
  network. This is the behavior expected prior to RFC 3021. To report 2
  useable hosts for use in point-to-point networks, use B<:rfc3021> tag.
  
  	use NetAddr::IP qw(:rfc3021);
  
  This will cause hostenum and hostenumref to return two (2) useable hosts in
  a /31 network.
   
  =item C<$me-E<gt>compact($addr1, $addr2, ...)>
  
  =item C<@compacted_object_list = Compact(@object_list)>
  
  Given a list of objects (including C<$me>), this method will compact
  all the addresses and subnets into the largest (ie, least specific)
  subnets possible that contain exactly all of the given objects.
  
  Note that in versions prior to 3.02, if fed with the same IP subnets
  multiple times, these subnets would be returned. From 3.02 on, a more
  "correct" approach has been adopted and only one address would be
  returned.
  
  Note that C<$me> and all C<$addr>'s must be C<NetAddr::IP> objects.
  
  =item C<$me-E<gt>compactref(\@list)>
  
  =item C<$compacted_object_list = Compact(\@list)>
  
  As usual, a faster version of C<-E<gt>compact()> that returns a
  reference to a list. Note that this method takes a reference to a list
  instead.
  
  Note that C<$me> must be a C<NetAddr::IP> object.
  
  =cut
  
  sub compactref($) {
  #  my @r = sort { NetAddr::IP::Lite::comp_addr_mask($a,$b) } @{$_[0]}		# use overload 'cmp' function
  #	or return [];
  #  return [] unless @r;
  
    my @r;
    {
      my $unr  = [];
      my $args = $_[0];
  
      if (ref $_[0] eq __PACKAGE__ and ref $_[1] eq 'ARRAY') {
        # ->compactref(\@list)
        #
        $unr = [$_[0], @{$_[1]}]; # keeping structures intact
      }
      else {
        # Compact(@list) or ->compact(@list) or Compact(\@list)
        #
        $unr = $args;
      }
  
      return [] unless @$unr;
  
      foreach(@$unr) {
        $_->{addr} = $_->network->{addr};
      }
  
      @r = sort @$unr;
    }
  
    my $changed;
    do {
      $changed = 0;
      for(my $i=0; $i <= $#r -1;$i++) {
        if ($r[$i]->contains($r[$i +1])) {
          splice(@r,$i +1,1);
          ++$changed;
          --$i;
        }
        elsif ((notcontiguous($r[$i]->{mask}))[1] == (notcontiguous($r[$i +1]->{mask}))[1]) {		# masks the same
          if (hasbits($r[$i]->{addr} ^ $r[$i +1]->{addr})) {	# if not the same netblock
            my $upnet = $r[$i]->copy;
            $upnet->{mask} = shiftleft($upnet->{mask},1);
            if ($upnet->contains($r[$i +1])) {					# adjacent nets in next net up
        $r[$i] = $upnet;
        splice(@r,$i +1,1);
        ++$changed;
        --$i;
            }
          } else {									# identical nets
            splice(@r,$i +1,1);
            ++$changed;
            --$i;
          }
        }
      }
    } while $changed;
    return \@r;
  }
  
  =pod
  
  =item C<$me-E<gt>coalesce($masklen, $number, @list_of_subnets)>
  
  =item C<$arrayref = Coalesce($masklen,$number,@list_of_subnets)>
  
  Will return a reference to list of C<NetAddr::IP> subnets of
  C<$masklen> mask length, when C<$number> or more addresses from
  C<@list_of_subnets> are found to be contained in said subnet.
  
  Subnets from C<@list_of_subnets> with a mask shorter than C<$masklen>
  are passed "as is" to the return list.
  
  Subnets from C<@list_of_subnets> with a mask longer than C<$masklen>
  will be counted (actually, the number of IP addresses is counted)
  towards C<$number>.
  
  Called as a method, the array will include C<$me>.
  
  WARNING: the list of subnet must be the same type. i.e ipV4 or ipV6
  
  =cut
  
  sub coalesce
  {
      my $masklen	= shift;
      if (ref $masklen && ref $masklen eq __PACKAGE__ ) {	# if called as a method
        push @_,$masklen;
        $masklen = shift;
      }
  
      my $number	= shift;
  
      # Addresses are at @_
      return [] unless @_;
      my %ret = ();
      my $type = $_[0]->{isv6};
      return [] unless defined $type;
  
      for my $ip (@_)
      {
  	return [] unless $ip->{isv6} == $type;
  	$type = $ip->{isv6};
  	my $n = NetAddr::IP->new($ip->addr . '/' . $masklen)->network;
  	if ($ip->masklen > $masklen)
  	{
  	    $ret{$n} += $ip->num + $NetAddr::IP::Lite::Old_nth;
  	}
      }
  
      my @ret = ();
  
      # Add to @ret any arguments with netmasks longer than our argument
      for my $c (sort { $a->masklen <=> $b->masklen }
  	       grep { $_->masklen <= $masklen } @_)
      {
  	next if grep { $_->contains($c) } @ret;
  	push @ret, $c->network;
      }
  
      # Now add to @ret all the subnets with more than $number hits
      for my $c (map { new NetAddr::IP $_ }
  	       grep { $ret{$_} >= $number }
  	       keys %ret)
      {
  	next if grep { $_->contains($c) } @ret;
  	push @ret, $c;
      }
  
      return \@ret;
  }
  
  =pod
  
  =item C<-E<gt>first()>
  
  Returns a new object representing the first usable IP address within
  the subnet (ie, the first host address).
  
  =item C<-E<gt>last()>
  
  Returns a new object representing the last usable IP address within
  the subnet (ie, one less than the broadcast address).
  
  =item C<-E<gt>nth($index)>
  
  Returns a new object representing the I<n>-th usable IP address within
  the subnet (ie, the I<n>-th host address).  If no address is available
  (for example, when the network is too small for C<$index> hosts),
  C<undef> is returned.
  
  Version 4.00 of NetAddr::IP and version 1.00 of NetAddr::IP::Lite implements
  C<-E<gt>nth($index)> and C<-E<gt>num()> exactly as the documentation states.
  Previous versions behaved slightly differently and not in a consistent
  manner. See the README file for details.
  
  To use the old behavior for C<-E<gt>nth($index)> and C<-E<gt>num()>:
  
    use NetAddr::IP::Lite qw(:old_nth);
  
    old behavior:
    NetAddr::IP->new('10/32')->nth(0) == undef
    NetAddr::IP->new('10/32')->nth(1) == undef
    NetAddr::IP->new('10/31')->nth(0) == undef
    NetAddr::IP->new('10/31')->nth(1) == 10.0.0.1/31
    NetAddr::IP->new('10/30')->nth(0) == undef
    NetAddr::IP->new('10/30')->nth(1) == 10.0.0.1/30
    NetAddr::IP->new('10/30')->nth(2) == 10.0.0.2/30
    NetAddr::IP->new('10/30')->nth(3) == 10.0.0.3/30
  
  Note that in each case, the broadcast address is represented in the
  output set and that the 'zero'th index is alway undef except for   
  a point-to-point /31 or /127 network where there are exactly two   
  addresses in the network.
  
    new behavior:
    NetAddr::IP->new('10/32')->nth(0)  == 10.0.0.0/32
    NetAddr::IP->new('10.1/32'->nth(0) == 10.0.0.1/32
    NetAddr::IP->new('10/31')->nth(0)  == 10.0.0.0/31
    NetAddr::IP->new('10/31')->nth(1)  == 10.0.0.1/31
    NetAddr::IP->new('10/30')->nth(0) == 10.0.0.1/30 
    NetAddr::IP->new('10/30')->nth(1) == 10.0.0.2/30 
    NetAddr::IP->new('10/30')->nth(2) == undef
  
  Note that a /32 net always has 1 usable address while a /31 has exactly 
  two usable addresses for point-to-point addressing. The first
  index (0) returns the address immediately following the network address
  except for a /31 or /127 when it return the network address.
  
  =item C<-E<gt>num()>
  
  As of version 4.42 of NetAddr::IP and version 1.27 of NetAddr::IP::Lite
  a /31 and /127 with return a net B<num> value of 2 instead of 0 (zero) 
  for point-to-point networks.
  
  Version 4.00 of NetAddr::IP and version 1.00 of NetAddr::IP::Lite
  return the number of usable IP addresses within the subnet, 
  not counting the broadcast or network address.
  
  Previous versions worked only for ipV4 addresses, returned a
  maximum span of 2**32 and returned the number of IP addresses
  not counting the broadcast address.
          (one greater than the new behavior)
  
  To use the old behavior for C<-E<gt>nth($index)> and C<-E<gt>num()>:
  
    use NetAddr::IP::Lite qw(:old_nth);
  
  WARNING:
  
  NetAddr::IP will calculate and return a numeric string for network
  ranges as large as 2**128. These values are TEXT strings and perl 
  can treat them as integers for numeric calculations.
  
  Perl on 32 bit platforms only handles integer numbers up to 2**32
  and on 64 bit platforms to 2**64.
  
  If you wish to manipulate numeric strings returned by NetAddr::IP
  that are larger than 2**32 or 2**64, respectively,  you must load
  additional modules such as Math::BigInt, bignum or some similar  
  package to do the integer math.
  
  =item C<-E<gt>re()>
  
  Returns a Perl regular expression that will match an IP address within
  the given subnet. Defaults to ipV4 notation. Will return an ipV6 regex
  if the address in not in ipV4 space.
  
  =cut
  
  sub re ($)
  {
      return &re6 unless isIPv4($_[0]->{addr});
      my $self = shift->network;	# Insure a "zero" host part
      my ($addr, $mlen) = ($self->addr, $self->masklen);
      my @o = split('\.', $addr, 4);
  
      my $octet= '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';
      my @r = @o;
      my $d;
  
  #    for my $i (0 .. $#o)
  #    {
  #	warn "# $self: $r[$i] == $o[$i]\n";
  #    }
  
      if ($mlen != 32)
      {
  	if ($mlen > 24)
  	{
  	     $d	= 2 ** (32 - $mlen) - 1;
  	     $r[3] = '(?:' . join('|', ($o[3]..$o[3] + $d)) . ')';
  	}
  	else
  	{
  	    $r[3] = $octet;
  	    if ($mlen > 16)
  	    {
  		$d = 2 ** (24 - $mlen) - 1;
  		$r[2] = '(?:' . join('|', ($o[2]..$o[2] + $d)) . ')';
  	    }
  	    else
  	    {
  		$r[2] = $octet;
  		if ($mlen > 8)
  		{
  		    $d = 2 ** (16 - $mlen) - 1;
  		    $r[1] = '(?:' . join('|', ($o[1]..$o[1] + $d)) . ')';
  		}
  		else
  		{
  		    $r[1] = $octet;
  		    if ($mlen > 0)
  		    {
  			$d = 2 ** (8 - $mlen) - 1;
  			$r[0] = '(?:' . join('|', ($o[0] .. $o[0] + $d)) . ')';
  		    }
  		    else { $r[0] = $octet; }
  		}
  	    }
  	}
      }
  
      ### no digit before nor after (look-behind, look-ahead)
      return "(?:(?<![0-9])$r[0]\\.$r[1]\\.$r[2]\\.$r[3](?![0-9]))";
  }
  
  =item C<-E<gt>re6()>
  
  Returns a Perl regular expression that will match an IP address within
  the given subnet. Always returns an ipV6 regex.
  
  =cut
  
  sub re6($) {
    my @net = split('',sprintf("%04X%04X%04X%04X%04X%04X%04X%04X",unpack('n8',$_[0]->network->{addr})));
    my @brd = split('',sprintf("%04X%04X%04X%04X%04X%04X%04X%04X",unpack('n8',$_[0]->broadcast->{addr})));
  
    my @dig;
  
    foreach(0..$#net) {
      my $n = $net[$_];
      my $b = $brd[$_];
      my $m;
      if ($n.'' eq $b.'') {
        if ($n =~ /\d/) {
  	push @dig, $n;
        } else {
  	push @dig, '['.(lc $n).$n.']';
        }
      } else {
        my $n = $net[$_];
        my $b = $brd[$_];
        if ($n.'' eq 0 && $b =~ /F/) {
  	push @dig, 'x';
        }
        elsif ($n =~ /\d/ && $b =~ /\d/) {
  	push @dig, '['.$n.'-'.$b.']';
        }
        elsif ($n =~ /[A-F]/ && $b =~ /[A-F]/) {
  	$n .= '-'.$b;
  	push @dig, '['.(lc $n).$n.']';
        }
        elsif ($n =~ /\d/ && $b =~ /[A-F]/) {
  	$m = ($n == 9) ? 9 : $n .'-9';
  	if ($b =~ /A/) {
  	  $m .= 'aA';
  	} else {
  	  $b = 'A-'. $b;
  	  $m .= (lc $b). $b;
  	}
  	push @dig, '['.$m.']';
        }
        elsif ($n =~ /[A-F]/ && $b =~ /\d/) {
  	if ($n =~ /A/) {
  	  $m = 'aA';
  	} else {
  	  $n .= '-F';
  	  $m = (lc $n).$n;
  	}
  	if ($b == 9) {
  	  $m .= 9;
  	} else {
  	  $m .= $b .'-9';
  	}
  	push @dig, '['.$m.']';
        }
      }
    }
    my @grp;
    do {
      my $grp = join('',splice(@dig,0,4));
      if ($grp =~ /^(0+)/) {
        my $l = length($1);
        if ($l == 4) {
  	$grp = '0{1,4}';
        } else {
  	$grp =~ s/^${1}/0\{0,$l\}/;
        }
      }
      if ($grp =~ /(x+)$/) {
        my $l = length($1);
        if ($l == 4) {
  	$grp = '[0-9a-fA-F]{1,4}';
        } else {
  	$grp =~ s/x+/\[0\-9a\-fA\-F\]\{$l\}/;
        }
      }
      push @grp, $grp;
    } while @dig > 0;
    return '('. join(':',@grp) .')';
  }
  
  sub mod_version {
    return $VERSION;
    &Compact;			# suppress warnings about these symbols
    &Coalesce;
    &STORABLE_freeze;
    &STORABLE_thaw;
  }
  
  =pod
  
  =back
  
  =head1 EXPORT_OK
  
  	Compact
  	Coalesce
  	Zeros
  	Ones
  	V4mask
  	V4net
  	netlimit
  
  =head1 NOTES / BUGS ... FEATURES
  
  NetAddr::IP only runs in Pure Perl mode on Windows boxes because I don't
  have the resources or know how to get the "configure" stuff working in the
  Windows environment. Volunteers WELCOME to port the "C" portion of this
  module to Windows.
  
  =head1 HISTORY
  
  =over 4
  
  See the Changes file
  
  =back
  
  =head1 AUTHORS
  
  Luis E. MuÃ±oz E<lt>luismunoz@cpan.orgE<gt>,
  Michael Robinton E<lt>michael@bizsystems.comE<gt>
  
  =head1 WARRANTY
  
  This software comes with the same warranty as Perl itself (ie, none),
  so by using it you accept any and all the liability.
  
  =head1 COPYRIGHT
  
  This software is (c) Luis E. MuÃ±oz, 1999 - 2007, and (c) Michael
  Robinton, 2006 - 2014.
  
  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of either:
  
    a) the GNU General Public License as published by the Free
    Software Foundation; either version 2, or (at your option) any
    later version, or
  
    b) the "Artistic License" which comes with this distribution.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See either
  the GNU General Public License or the Artistic License for more details.
  
  You should have received a copy of the Artistic License with this
  distribution, in the file named "Artistic".  If not, I'll be glad to provide
  one.
  
  You should also have received a copy of the GNU General Public License
  along with this program in the file named "Copying". If not, write to the
  
  	Free Software Foundation, Inc.
  	51 Franklin Street, Fifth Floor
  	Boston, MA 02110-1301 USA.
  
  or visit their web page on the internet at:
  
          http://www.gnu.org/copyleft/gpl.html.
  
  =head1 SEE ALSO
  
    perl(1) L<NetAddr::IP::Lite>, L<NetAddr::IP::Util>,
  L<NetAddr::IP::InetBase>
  
  =cut
  
  1;
X86_64-LINUX-THREAD-MULTI_NETADDR_IP

$fatpacked{"x86_64-linux-thread-multi/NetAddr/IP/InetBase.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_NETADDR_IP_INETBASE';
  #!/usr/bin/perl
  package NetAddr::IP::InetBase;
  
  use strict;
  #use diagnostics;
  #use lib qw(blib lib);
  
  use vars qw($VERSION @EXPORT_OK @ISA %EXPORT_TAGS $Mode);
  use AutoLoader qw(AUTOLOAD);
  require Exporter;
  
  @ISA = qw(Exporter);
  
  $VERSION = do { my @r = (q$Revision: 0.08 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
  
  @EXPORT_OK = qw(
  	inet_aton
  	inet_ntoa
  	ipv6_aton
  	ipv6_ntoa
  	ipv6_n2x
  	ipv6_n2d
  	inet_any2n
  	inet_n2dx
  	inet_n2ad
  	inet_ntop
  	inet_pton
  	packzeros
  	isIPv4
  	isNewIPv4
  	isAnyIPv4
  	AF_INET
  	AF_INET6
  	fake_AF_INET6
  	fillIPv4
  );
  
  %EXPORT_TAGS = (
  	all     => [@EXPORT_OK],
  	ipv4	=> [qw(
  		inet_aton
  		inet_ntoa
  		fillIPv4
  	)],
  	ipv6	=> [qw(
  		ipv6_aton
  		ipv6_ntoa
  		ipv6_n2x
  		ipv6_n2d
  		inet_any2n
  		inet_n2dx
  		inet_n2ad
  		inet_pton
  		inet_ntop
  		packzeros
  	)],
  );
  
  # prototypes
  sub inet_ntoa;
  sub ipv6_aton;
  sub ipv6_ntoa;
  sub inet_any2n($);
  sub inet_n2dx($);
  sub inet_n2ad($);
  sub _inet_ntop;
  sub _inet_pton;
  
  my $emulateAF_INET6 = 0;
  
  { no warnings 'once';
  
  *packzeros = \&_packzeros;
  
  ## dynamic configuraton for IPv6
  
  require Socket;
  
  *AF_INET = \&Socket::AF_INET;
  
  if (eval { AF_INET6() } ) {
    *AF_INET6 = \&Socket::AF_INET6;
    $emulateAF_INET6 = -1;			# have it, remind below
  }
  if (eval{ require Socket6 } ) {
    import Socket6 qw(
  	inet_pton
  	inet_ntop
    );
    unless ($emulateAF_INET6) {
      *AF_INET6 = \&Socket6::AF_INET6;
    }
    $emulateAF_INET6 = 0;				# clear, have it from elsewhere or here
  } else {
    unless ($emulateAF_INET6) {	# unlikely at this point
      if ($^O =~ /(?:free|dragon.+)bsd/i) {	# FreeBSD, DragonFlyBSD
  	$emulateAF_INET6 = 28;
      } elsif ($^O =~ /bsd/i) {		# other BSD flavors like NetBDS, OpenBSD, BSD
  	$emulateAF_INET6 = 24;
      } elsif ($^O =~ /(?:darwin|mac)/i) {	# Mac OS X
  	$emulateAF_INET6 = 30;
      } elsif ($^O =~ /win/i) {		# Windows
  	$emulateAF_INET6 = 23;
      } elsif ($^O =~ /(?:solaris|sun)/i) {		# Sun box
  	$emulateAF_INET6 = 26;
      } else {					# use linux default
  	$emulateAF_INET6 = 10;
      }
      *AF_INET6 = sub { $emulateAF_INET6; };
    } else {
      $emulateAF_INET6 = 0;			# clear, have it from elsewhere
    }
    *inet_pton = \&_inet_pton;
    *inet_ntop = \&_inet_ntop;
  }
  
  } # end no warnings 'once'
  
  sub fake_AF_INET6 {
    return $emulateAF_INET6;
  }
  
  # allow user to choose upper or lower case
  BEGIN {
    use vars qw($n2x_format $n2d_format);
    $n2x_format = "%x:%x:%x:%x:%x:%x:%x:%x";
    $n2d_format = "%x:%x:%x:%x:%x:%x:%d.%d.%d.%d";
  }
  
  my $case = 0;	# default lower case
  
  sub upper { $n2x_format = uc($n2x_format); $n2d_format = uc($n2d_format); $case = 1; }
  sub lower { $n2x_format = lc($n2x_format); $n2d_format = lc($n2d_format); $case = 0; }
  
  sub ipv6_n2x {
    die "Bad arg length for 'ipv6_n2x', length is ". length($_[0]) ." should be 16"
  	unless length($_[0]) == 16;
    return sprintf($n2x_format,unpack("n8",$_[0]));
  }
  
  sub ipv6_n2d {
    die "Bad arg length for 'ipv6_n2d', length is ". length($_[0]) ." should be 16"
  	unless length($_[0]) == 16;
    my @hex = (unpack("n8",$_[0]));
    $hex[9] = $hex[7] & 0xff;
    $hex[8] = $hex[7] >> 8;
    $hex[7] = $hex[6] & 0xff;
    $hex[6] >>= 8;
    return sprintf($n2d_format,@hex);
  }
  
  # if Socket lib is broken in some way, check for overange values
  #
  #my $overange = yinet_aton('256.1') ? 1:0;
  #my $overange = gethostbyname('256.1') ? 1:0;
  
  #sub inet_aton {
  #  unless (! $overange || $_[0] =~ /[^0-9\.]/) {	# hostname
  #    my @dq = split(/\./,$_[0]);
  #    foreach (@dq) {
  #      return undef if $_ > 255;
  #    }
  #  }
  #  scalar gethostbyname($_[0]);
  #}
  
  sub fillIPv4 {
    my $host = $_[0];
    return undef unless defined $host;
    if ($host =~ /^(\d+)(?:|\.(\d+)(?:|\.(\d+)(?:|\.(\d+))))$/) {
      if (defined $4) {
        return undef unless
          $1 >= 0 && $1 < 256 &&
          $2 >= 0 && $2 < 256 &&
          $3 >= 0 && $3 < 256 &&
          $4 >= 0 && $4 < 256;
        $host = $1.'.'.$2.'.'.$3.'.'.$4;
  #      return pack('C4',$1,$2,$3,$4);
  #      $host = ($1 << 24) + ($2 << 16) + ($3 << 8) + $4;
      } elsif (defined $3) {
        return undef unless  
          $1 >= 0 && $1 < 256 &&
          $2 >= 0 && $2 < 256 &&
          $3 >= 0 && $3 < 256;  
        $host = $1.'.'.$2.'.0.'.$3
  #      return pack('C4',$1,$2,0,$3);
  #      $host = ($1 << 24) + ($2 << 16) + $3;
      } elsif (defined $2) {
        return undef unless  
          $1 >= 0 && $1 < 256 &&
          $2 >= 0 && $2 < 256;  
        $host = $1.'.0.0.'.$2;
  #      return pack('C4',$1,0,0,$2);
  #      $host = ($1 << 24) + $2;
      } else {
        $host = '0.0.0.'.$1;
  #      return pack('C4',0,0,0,$1);
  #      $host = $1;
      }
  #    return pack('N',$host);
    }
    $host;
  } 	
  
  sub inet_aton {
    my $host = fillIPv4($_[0]);
    return $host ? scalar gethostbyname($host) : undef;
  }
  
  #sub inet_aton {
  #  my $host = $_[0];
  #  return undef unless defined $host;
  #  if ($host =~ /^(\d+)(?:|\.(\d+)(?:|\.(\d+)(?:|\.(\d+))))$/) {
  #    if (defined $4) {
  #      return undef unless
  #        $1 >= 0 && $1 < 256 &&
  #        $2 >= 0 && $2 < 256 &&
  #        $3 >= 0 && $3 < 256 &&
  #        $4 >= 0 && $4 < 256;
  #      return pack('C4',$1,$2,$3,$4);
  ##      $host = ($1 << 24) + ($2 << 16) + ($3 << 8) + $4;
  #    } elsif (defined $3) {
  #      return undef unless  
  #        $1 >= 0 && $1 < 256 &&
  #        $2 >= 0 && $2 < 256 &&
  #        $3 >= 0 && $3 < 256;  
  #      return pack('C4',$1,$2,0,$3);
  ##      $host = ($1 << 24) + ($2 << 16) + $3;
  #    } elsif (defined $2) {
  #      return undef unless  
  #        $1 >= 0 && $1 < 256 &&
  #        $2 >= 0 && $2 < 256;  
  #      return pack('C4',$1,0,0,$2);
  ##      $host = ($1 << 24) + $2;
  #    } else {
  #      return pack('C4',0,0,0,$1);
  ##      $host = $1;
  #    }
  ##    return pack('N',$host);
  #  }
  #  scalar gethostbyname($host);
  #} 	
  
  my $_zero = pack('L4',0,0,0,0);
  my $_ipv4mask = pack('L4',0xffffffff,0xffffffff,0xffffffff,0);
  
  sub isIPv4 {
    if (length($_[0]) != 16) {
      my $sub = (caller(1))[3] || (caller(0))[3];
      die "Bad arg length for $sub, length is ". (length($_[0]) *8) .", should be 128";
    }
    return ($_[0] & $_ipv4mask) eq $_zero
  	? 1 : 0;
  }
  
  my $_newV4compat = pack('N4',0,0,0xffff,0);
  
  sub isNewIPv4 {
    my $naddr = $_[0] ^ $_newV4compat;
    return isIPv4($naddr);
  }
  
  sub isAnyIPv4 {
    my $naddr = $_[0];
    my $rv = isIPv4($_[0]);
    return $rv if $rv;
    return isNewIPv4($naddr);
  }
  
  sub DESTROY {};
  
  sub import {
    if (grep { $_ eq ':upper' } @_) {
  	upper();
  	@_ = grep { $_ ne ':upper' } @_;
    }
    NetAddr::IP::InetBase->export_to_level(1,@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  NetAddr::IP::InetBase -- IPv4 and IPV6 utilities
  
  =head1 SYNOPSIS
  
    use NetAddr::IP::Base qw(
  	:upper
  	inet_aton
  	inet_ntoa
  	ipv6_aton
  	ipv6_ntoa
  	ipv6_n2x
  	ipv6_n2d
  	inet_any2n
  	inet_n2dx
  	inet_n2ad
  	inet_pton
  	inet_ntop
  	packzeros
  	isIPv4
  	isNewIPv4
  	isAnyIPv4
  	AF_INET
  	AF_INET6
  	fake_AF_INET6
  	fillIPv4
    );
  
    use NetAddr::IP::Util qw(:all :inet :ipv4 :ipv6 :math)
  
    :ipv4	  =>	inet_aton, inet_ntoa, fillIPv4
  
    :ipv6	  =>	ipv6_aton, ipv6_ntoa,ipv6_n2x, ipv6_n2d,
  		inet_any2n, inet_n2dx, inet_n2ad
  		inet_pton, inet_ntop, packzeros
  
    $dotquad = inet_ntoa($netaddr);
    $netaddr = inet_aton($dotquad);
    $ipv6naddr = ipv6_aton($ipv6_text);
    $ipv6_text = ipv6_ntoa($ipv6naddr);
    $hex_text = ipv6_n2x($ipv6naddr);
    $dec_text = ipv6_n2d($ipv6naddr);
    $ipv6naddr = inet_any2n($dotquad or $ipv6_text);
    $dotquad or $hex_text = inet_n2dx($ipv6naddr);
    $dotquad or $dec_text = inet_n2ad($ipv6naddr);
    $netaddr = inet_pton($AF_family,$text_addr);
    $text_addr = inet_ntop($AF_family,$netaddr);
    $hex_text = packzeros($hex_text);
    $rv = isIPv4($bits128);
    $rv = isNewIPv4($bits128);
    $rv = isAnyIPv4($bits128);
    $constant = AF_INET();
    $constant = AF_INET6();
    $trueif   = fake_AF_INET6();
    $ip_filled = fillIPv4($shortIP);
  
    NetAddr::IP::InetBase::lower();
    NetAddr::IP::InetBase::upper();
  
  =head1 INSTALLATION
  
  Un-tar the distribution in an appropriate directory and type:
  
  	perl Makefile.PL
  	make
  	make test
  	make install
  
  =head1 DESCRIPTION
  
  B<NetAddr::IP::InetBase> provides a suite network of conversion functions 
  written in pure Perl for converting both IPv4 and IPv6 addresses to
  and from network address format and text format.
  
  The IPv6 functions support all rfc1884 formats.
  
    i.e.	x:x:x:x:x:x:x:x:x
  	x:x:x:x:x:x:x:d.d.d.d
  	::x:x:x
  	::x:d.d.d.d
    and so on...
  
  =over 4
  
  =item * $dotquad = inet_ntoa($netaddr);
  
  Convert a packed IPv4 network address to a dot-quad IP address.
  
    input:	packed network address
    returns:	IP address i.e. 10.4.12.123
  
  =cut
  
  sub inet_ntoa {
    die 'Bad arg length for '. __PACKAGE__ ."::inet_ntoa, length is ". length($_[0]) ." should be 4"
          unless length($_[0]) == 4;
    my @hex = (unpack("n2",$_[0]));
    $hex[3] = $hex[1] & 0xff;
    $hex[2] = $hex[1] >> 8;
    $hex[1] = $hex[0] & 0xff;
    $hex[0] >>= 8;
    return sprintf("%d.%d.%d.%d",@hex);
  }
  
  =item * $netaddr = inet_aton($dotquad);
  
  Convert a dot-quad IP address into an IPv4 packed network address.
  
    input:	IP address i.e. 192.5.16.32
    returns:	packed network address
  
  =item * $ipv6addr = ipv6_aton($ipv6_text);
  
  Takes an IPv6 address of the form described in rfc1884
  and returns a 128 bit binary RDATA string.
  
    input:	ipv6 text
    returns:	128 bit RDATA string
  
  =cut
  
  sub ipv6_aton {
    my($ipv6) = @_;
    return undef unless $ipv6;
    local($1,$2,$3,$4,$5);
    if ($ipv6 =~ /^(.*:)(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/) {	# mixed hex, dot-quad
      return undef if $2 > 255 || $3 > 255 || $4 > 255 || $5 > 255;
      $ipv6 = sprintf("%s%X%02X:%X%02X",$1,$2,$3,$4,$5);			# convert to pure hex
    }
    my $c;
    return undef if
  	$ipv6 =~ /[^:0-9a-fA-F]/ ||			# non-hex character
  	(($c = $ipv6) =~ s/::/x/ && $c =~ /(?:x|:):/) ||	# double :: ::?
  	$ipv6 =~ /[0-9a-fA-F]{5,}/;			# more than 4 digits
    $c = $ipv6 =~ tr/:/:/;				# count the colons
    return undef if $c < 7 && $ipv6 !~ /::/;
    if ($c > 7) {						# strip leading or trailing ::
      return undef unless
  	$ipv6 =~ s/^::/:/ ||
  	$ipv6 =~ s/::$/:/;
      return undef if --$c > 7;
    }
    while ($c++ < 7) {					# expand compressed fields
      $ipv6 =~ s/::/:::/;
    }
    $ipv6 .= 0 if $ipv6 =~ /:$/;
    my @hex = split(/:/,$ipv6);
    foreach(0..$#hex) {
      $hex[$_] = hex($hex[$_] || 0);
    }
    pack("n8",@hex);
  }
  
  =item * $ipv6text = ipv6_ntoa($ipv6naddr);
  
  Convert a 128 bit binary IPv6 address to compressed rfc 1884
  text representation.
  
    input:	128 bit RDATA string
    returns:	ipv6 text
  
  =cut
  
  sub ipv6_ntoa {
    return inet_ntop(AF_INET6(),$_[0]);
  }
  
  =item * $hex_text = ipv6_n2x($ipv6addr);
  
  Takes an IPv6 RDATA string and returns an 8 segment IPv6 hex address
  
    input:	128 bit RDATA string
    returns:	x:x:x:x:x:x:x:x
  
    Note: this function does NOT compress adjacent
    strings of 0:0:0:0 into the :: format
  
  =item * $dec_text = ipv6_n2d($ipv6addr);
  
  Takes an IPv6 RDATA string and returns a mixed hex - decimal IPv6 address
  with the 6 uppermost chunks in hex and the lower 32 bits in dot-quad
  representation.
  
    input:	128 bit RDATA string
    returns:	x:x:x:x:x:x:d.d.d.d
  
    Note: this function does NOT compress adjacent
    strings of 0:0:0:0 into the :: format
  
  =item * $ipv6naddr = inet_any2n($dotquad or $ipv6_text);
  
  This function converts a text IPv4 or IPv6 address in text format in any
  standard notation into a 128 bit IPv6 string address. It prefixes any
  dot-quad address (if found) with '::' and passes it to B<ipv6_aton>.
  
    input:	dot-quad or rfc1844 address
    returns:	128 bit IPv6 string
  
  =cut
  
  sub inet_any2n($) {
    my($addr) = @_;
    $addr = '' unless $addr;
    $addr = '::' . $addr
  	unless $addr =~ /:/;
    return ipv6_aton($addr);
  }
  
  =item * $dotquad or $hex_text = inet_n2dx($ipv6naddr);
  
  This function B<does the right thing> and returns the text for either a
  dot-quad IPv4 or a hex notation IPv6 address.
  
    input:	128 bit IPv6 string
    returns:	ddd.ddd.ddd.ddd
  	    or	x:x:x:x:x:x:x:x
  
    Note: this function does NOT compress adjacent
    strings of 0:0:0:0 into the :: format
  
  =cut
  
  sub inet_n2dx($) {
    my($nadr) = @_;
    if (isAnyIPv4($nadr)) {
      local $1;
      ipv6_n2d($nadr) =~ /([^:]+)$/;
      return $1;
    }
    return ipv6_n2x($nadr);
  }
  
  =item * $dotquad or $dec_text = inet_n2ad($ipv6naddr);
  
  This function B<does the right thing> and returns the text for either a
  dot-quad IPv4 or a hex::decimal notation IPv6 address.
  
    input:	128 bit IPv6 string
    returns:	ddd.ddd.ddd.ddd
  	    or  x:x:x:x:x:x:ddd.ddd.ddd.dd
  
    Note: this function does NOT compress adjacent
    strings of 0:0:0:0 into the :: format
  
  =cut
  
  sub inet_n2ad($) {
    my($nadr) = @_;
    my $addr = ipv6_n2d($nadr);
    return $addr unless isAnyIPv4($nadr);
    local $1;
    $addr =~ /([^:]+)$/;
    return $1;
  }
  
  =item * $netaddr = inet_pton($AF_family,$text_addr);
  
  This function takes an IP address in IPv4 or IPv6 text format and converts it into
  binary format. The type of IP address conversion is controlled by the FAMILY
  argument.
  
  NOTE: inet_pton, inet_ntop and AF_INET6 come from the Socket6 library if it
  is present on this host.
  
  =cut
  
  sub _inet_pton {
    my($af,$ip) = @_;
    die 'Bad address family for '. __PACKAGE__ ."::inet_pton, got $af"
  	unless $af == AF_INET6() || $af == AF_INET();
    if ($af == AF_INET()) {
      inet_aton($ip);
    } else {
      ipv6_aton($ip);
    }
  }
  
  =item * $text_addr = inet_ntop($AF_family,$netaddr);
  
  This function takes and IP address in binary format and converts it into
  text format. The type of IP address conversion is controlled by the FAMILY 
  argument.
  
  NOTE: inet_ntop ALWAYS returns lowercase characters.
  
  NOTE: inet_pton, inet_ntop and AF_INET6 come from the Socket6 library if it
  is present on this host.
  
  =cut
  
  sub _inet_ntop {
    my($af,$naddr) = @_;
    die 'Unsupported address family for '. __PACKAGE__ ."::inet_ntop, af is $af"
  	unless $af == AF_INET6() || $af == AF_INET();
    if ($af == AF_INET()) {
      inet_ntoa($naddr);
    } else {
      return ($case)
  	? lc packzeros(ipv6_n2x($naddr))
  	: _packzeros(ipv6_n2x($naddr));
    }
  }
  
  =item * $hex_text = packzeros($hex_text);
  
  This function optimizes and rfc 1884 IPv6 hex address to reduce the number of
  long strings of zero bits as specified in rfc 1884, 2.2 (2) by substituting
  B<::> for the first occurence of the longest string of zeros in the address.
  
  =cut
  
  sub _packzeros {
    my $x6 = shift;
    if ($x6 =~ /\:\:/) {				# already contains ::
  # then re-optimize
      $x6 = ($x6 =~ /\:\d+\.\d+\.\d+\.\d+/)	# ipv4 notation ?
  	? ipv6_n2d(ipv6_aton($x6))
  	: ipv6_n2x(ipv6_aton($x6));
    }
    $x6 = ':'. lc $x6;				# prefix : & always lower case
    my $d = '';
    if ($x6 =~ /(.+\:)(\d+\.\d+\.\d+\.\d+)/) {	# if contains dot quad
      $x6 = $1;					# save hex piece
      $d = $2;					# and dot quad piece
    }
    $x6 .= ':';					# suffix :
    $x6 =~ s/\:0+/\:0/g;				# compress strings of 0's to single '0'
    $x6 =~ s/\:0([1-9a-f]+)/\:$1/g;		# eliminate leading 0's in hex strings
    my @x = $x6 =~ /(?:\:0)*/g;			# split only strings of :0:0..."
  
    my $m = 0;
    my $i = 0;
  
    for (0..$#x) {				# find next longest pattern :0:0:0...
      my $len = length($x[$_]);
      next unless $len > $m;
      $m = $len;
      $i = $_;					# index to first longest pattern
    }
  
    if ($m > 2) {					# there was a string of 2 or more zeros
      $x6 =~ s/$x[$i]/\:/;	  		# replace first longest :0:0:0... with "::"
      unless ($i) {				# if it is the first match, $i = 0
        $x6 = substr($x6,0,-1);			# keep the leading ::, remove trailing ':'
      } else {
        $x6 = substr($x6,1,-1);			# else remove leading & trailing ':'
      }
      $x6 .= ':' unless $x6 =~ /\:\:/;		# restore ':' if match and we can't see it, implies trailing '::'
    } else {					# there was no match
      $x6 = substr($x6,1,-1);			# remove leading & trailing ':'
    }
    $x6 .= $d;					# append digits if any
    return $case
  	? uc $x6
  	: $x6;
  }
  
  =item * $ipv6naddr = ipv4to6($netaddr);
  
  Convert an ipv4 network address into an ipv6 network address.
  
    input:	32 bit network address
    returns:	128 bit network address
  
  =item * $rv = isIPv4($bits128);
  
  This function returns true if there are no on bits present in the IPv6
  portion of the 128 bit string and false otherwise.
  
    i.e.	the address must be of the form - ::d.d.d.d
  
  Note: this is an old and deprecated ipV4 compatible ipV6 address
  	
  =item * $rv = isNewIPv4($bits128);
  
  This function return true if the IPv6 128 bit string is of the form
  
  	::ffff:d.d.d.d
  
  =item * $rv = isAnyIPv4($bits128);
  
  This function return true if the IPv6 bit string is of the form
  
  	::d.d.d.d	or	::ffff:d.d.d.d
  
  =item * NetAddr::IP::InetBase::lower();
  
  Return IPv6 strings in lowercase. This is the default.
  
  =item * NetAddr::IP::InetBase::upper();
  
  Return IPv6 strings in uppercase.
  
  The default may be set to uppercase when the module is loaded by invoking
  the TAG :upper. i.e.
  
  	use NetAddr::IP::InetBase qw( :upper );
  
  =item * $constant = AF_INET;
  
  This function returns the system value for AF_INET. 
  
  =item * $constant = AF_INET6;
  
  AF_INET6 is sometimes present in the Socket library and always present in the Socket6 library. When the Socket 
  library does not contain AF_INET6 and when Socket6 is not present, a place holder value is C<guessed> based on
  the underlying host operating system. See B<fake_AF_INET6> below.
  
  NOTE: inet_pton, inet_ntop and AF_INET6 come from the Socket6 library if it
  is present on this host.
  
  =item * $trueif = fake_AF_INET6;
  
  This function return FALSE if AF_INET6 is provided by Socket or Socket6. Otherwise, it returns the best guess
  value based on name of the host operating system.
  
  =item * $ip_filled = fillIPv4($shortIP);
  
  This function converts IPv4 addresses of the form 127.1 to the long form
  127.0.0.1 
  
  If the function is passed an argument that does not match the form of an IP
  address, the original argument is returned. i.e. pass it a hostname or a
  short IP and it will return a hostname or a filled IP.
  
  =back
  
  =head1 EXPORT_OK
  
  	:upper
  	inet_aton
  	inet_ntoa
  	ipv6_aton
  	ipv6_ntoa
  	ipv6_n2x
  	ipv6_n2d
  	inet_any2n
  	inet_n2dx
  	inet_n2ad
  	inet_pton
  	inet_ntop
  	packzeros
  	isIPv4
  	isNewIPv4
  	isAnyIPv4
  	AF_INET
  	AF_INET6
  	fake_AF_INET6
  	fillIPv4
  
  =head1 %EXPORT_TAGS
  
  	:all
  	:ipv4
  	:ipv6
  	:upper
  
  =head1 AUTHOR
  
  Michael Robinton <michael@bizsystems.com>
  
  =head1 COPYRIGHT
  
  Copyright 2003 - 2012, Michael Robinton E<lt>michael@bizsystems.comE<gt>
  
  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of either:
  
    a) the GNU General Public License as published by the Free
    Software Foundation; either version 2, or (at your option) any
    later version, or
  
    b) the "Artistic License" which comes with this distribution.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See either
  the GNU General Public License or the Artistic License for more details.
  
  You should have received a copy of the Artistic License with this
  distribution, in the file named "Artistic".  If not, I'll be glad to provide
  one.
  
  You should also have received a copy of the GNU General Public License
  along with this program in the file named "Copying". If not, write to the
  
  	Free Software Foundation, Inc.,
  	51 Franklin Street, Fifth Floor
  	Boston, MA 02110-1301 USA
  
  or visit their web page on the internet at:
  
          http://www.gnu.org/copyleft/gpl.html.
  
  =head1 AUTHOR
  
  Michael Robinton <michael@bizsystems.com>
  
  =head1 SEE ALSO
  
  NetAddr::IP(3), NetAddr::IP::Lite(3), NetAddr::IP::Util(3)
  
  =cut
  
  1;
X86_64-LINUX-THREAD-MULTI_NETADDR_IP_INETBASE

$fatpacked{"x86_64-linux-thread-multi/NetAddr/IP/Lite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_NETADDR_IP_LITE';
  #!/usr/bin/perl
  
  package NetAddr::IP::Lite;
  
  use Carp;
  use strict;
  #use diagnostics;
  #use warnings;
  use NetAddr::IP::InetBase qw(
  	inet_any2n
  	isIPv4
  	inet_n2dx
  	inet_aton
  	ipv6_aton
  	ipv6_n2x
  	fillIPv4
  );	
  use NetAddr::IP::Util qw(
  	addconst
  	sub128
  	ipv6to4
  	notcontiguous
  	shiftleft
  	hasbits
  	bin2bcd
  	bcd2bin
  	mask4to6
  	ipv4to6
  	naip_gethostbyname
  	havegethostbyname2
  );
  
  use vars qw(@ISA @EXPORT_OK $VERSION $Accept_Binary_IP $Old_nth $NoFQDN $AUTOLOAD *Zero);
  
  $VERSION = do { my @r = (q$Revision: 1.57 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
  
  require Exporter;
  
  @ISA = qw(Exporter);
  
  @EXPORT_OK = qw(Zeros Zero Ones V4mask V4net);
  
  # Set to true, to enable recognizing of ipV4 && ipV6 binary notation IP
  # addresses. Thanks to Steve Snodgrass for reporting. This can be done
  # at the time of use-ing the module. See docs for details.
  
  $Accept_Binary_IP = 0;
  $Old_nth = 0;
  *Zero = \&Zeros;
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  NetAddr::IP::Lite - Manages IPv4 and IPv6 addresses and subnets
  
  =head1 SYNOPSIS
  
    use NetAddr::IP::Lite qw(
  	Zeros
  	Ones
  	V4mask
  	V4net
  	:aton		DEPRECATED !
  	:old_nth
  	:upper
  	:lower
  	:nofqdn
    );
  
    my $ip = new NetAddr::IP::Lite '127.0.0.1';
  	or if your prefer
    my $ip = NetAddr::IP::Lite->new('127.0.0.1);
  	or from a packed IPv4 address
    my $ip = new_from_aton NetAddr::IP::Lite (inet_aton('127.0.0.1'));
  	or from an octal filtered IPv4 address
    my $ip = new_no NetAddr::IP::Lite '127.012.0.0';
  
    print "The address is ", $ip->addr, " with mask ", $ip->mask, "\n" ;
  
    if ($ip->within(new NetAddr::IP::Lite "127.0.0.0", "255.0.0.0")) {
        print "Is a loopback address\n";
    }
  
  				# This prints 127.0.0.1/32
    print "You can also say $ip...\n";
  
    The following four functions return ipV6 representations of:
  
    ::					   = Zeros();
    FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF  = Ones();
    FFFF:FFFF:FFFF:FFFF:FFFF:FFFF::	   = V4mask();
    ::FFFF:FFFF				   = V4net();
  
    Will also return an ipV4 or ipV6 representation of a
    resolvable Fully Qualified Domanin Name (FQDN).
  
  =head1 INSTALLATION
  
  Un-tar the distribution in an appropriate directory and type:
  
  	perl Makefile.PL
  	make
  	make test
  	make install
  
  B<NetAddr::IP::Lite> depends on B<NetAddr::IP::Util> which installs by default with its primary functions compiled
  using Perl's XS extensions to build a 'C' library. If you do not have a 'C'
  complier available or would like the slower Pure Perl version for some other
  reason, then type:
  
  	perl Makefile.PL -noxs
  	make
  	make test
  	make install
  
  =head1 DESCRIPTION
  
  This module provides an object-oriented abstraction on top of IP
  addresses or IP subnets, that allows for easy manipulations. Most of the
  operations of NetAddr::IP are supported. This module will work with older
  versions of Perl and is compatible with Math::BigInt.
  
  * By default B<NetAddr::IP> functions and methods return string IPv6
  addresses in uppercase.  To change that to lowercase:
  
  NOTE: the AUGUST 2010 RFC5952 states:
  
      4.3. Lowercase
  
        The characters "a", "b", "c", "d", "e", and "f" in an IPv6
        address MUST be represented in lowercase.
  
  It is recommended that all NEW applications using NetAddr::IP::Lite be
  invoked as shown on the next line.
  
    use NetAddr::IP::Lite qw(:lower);
  
  * To ensure the current IPv6 string case behavior even if the default changes:
  
    use NetAddr::IP::Lite qw(:upper);
  
  
  The internal representation of all IP objects is in 128 bit IPv6 notation.
  IPv4 and IPv6 objects may be freely mixed.
  
  The supported operations are described below:
  
  =cut
  
  # in the off chance that NetAddr::IP::Lite objects are created
  # and the caller later loads NetAddr::IP and expects to use
  # those objects, let the AUTOLOAD routine find and redirect
  # NetAddr::IP::Lite method and subroutine calls to NetAddr::IP.
  #
  
  my $parent = 'NetAddr::IP';
  
  # test function
  #
  # input:	subroutine name in NetAddr::IP
  # output:	t/f	if sub name exists in NetAddr::IP namespace
  #
  #sub sub_exists {
  #  my $other = $parent .'::';
  #  return exists ${$other}{$_[0]};
  #}
  
  sub DESTROY {};
  
  sub AUTOLOAD {
    no strict;
    my ($pkg,$func) = ($AUTOLOAD =~ /(.*)::([^:]+)$/);
    my $other = $parent .'::';
  
    if ($pkg =~ /^$other/o && exists ${$other}{$func}) {
      $other .= $func;
      goto &{$other};
    }
  
    my @stack = caller(0);
  
    if ( $pkg eq ref $_[0] ) {
      $other = qq|Can't locate object method "$func" via|;
    }
    else {
      $other = qq|Undefined subroutine \&$AUTOLOAD not found in|;
    }
    die $other . qq| package "$parent" or "$pkg" (did you forgot to load a module?) at $stack[1] line $stack[2].\n|;
  }
  
  =head2 Overloaded Operators
  
  =cut
  
  # these really should be packed in Network Long order but since they are
  # symmetrical, that extra internal processing can be skipped
  
  my $_v4zero = pack('L',0);
  my $_zero = pack('L4',0,0,0,0);
  my $_ones = ~$_zero;
  my $_v4mask = pack('L4',0xffffffff,0xffffffff,0xffffffff,0);
  my $_v4net = ~ $_v4mask;
  my $_ipv4FFFF = pack('N4',0,0,0xffff,0);
  
  sub Zeros() {
    return $_zero;
  }
  sub Ones() {
    return $_ones;
  }
  sub V4mask() {
    return $_v4mask;
  }
  sub V4net() {
    return $_v4net;
  }
  
  				#############################################
  				# These are the overload methods, placed here
  				# for convenience.
  				#############################################
  
  use overload
  
      '+'		=> \&plus,
  
      '-'		=> \&minus,
  
      '++'	=> \&plusplus,
  
      '--'	=> \&minusminus,
  
      "="		=> \&copy,
  
      '""'	=> sub { $_[0]->cidr(); },
  
      'eq'	=> sub {
  	my $a = (UNIVERSAL::isa($_[0],__PACKAGE__)) ? $_[0]->cidr : $_[0];
  	my $b = (UNIVERSAL::isa($_[1],__PACKAGE__)) ? $_[1]->cidr : $_[1];
  	$a eq $b;
      },
  
      'ne'	=> sub {
  	my $a = (UNIVERSAL::isa($_[0],__PACKAGE__)) ? $_[0]->cidr : $_[0];
  	my $b = (UNIVERSAL::isa($_[1],__PACKAGE__)) ? $_[1]->cidr : $_[1];
  	$a ne $b;
      },
  
      '=='	=> sub {
  	return 0 unless UNIVERSAL::isa($_[0],__PACKAGE__) && UNIVERSAL::isa($_[1],__PACKAGE__);
  	$_[0]->cidr eq $_[1]->cidr;
      },
  
      '!='	=> sub {
  	return 1 unless UNIVERSAL::isa($_[0],__PACKAGE__) && UNIVERSAL::isa($_[1],__PACKAGE__);
  	$_[0]->cidr ne $_[1]->cidr;
      },
  
      '>'		=> sub {
  	return &comp_addr_mask > 0 ? 1 : 0;
      },
  
      '<'		=> sub {
  	return &comp_addr_mask < 0 ? 1 : 0;
      },
  
      '>='	=> sub {
  	return &comp_addr_mask < 0 ? 0 : 1;
      },
  
      '<='	=> sub {
  	return &comp_addr_mask > 0 ? 0 : 1;
      },
  
      '<=>'	=> \&comp_addr_mask,
  
      'cmp'	=> \&comp_addr_mask;
  
  sub comp_addr_mask {
    my($c,$rv) = sub128($_[0]->{addr},$_[1]->{addr});
    return -1 unless $c;
    return 1 if hasbits($rv);
    ($c,$rv) = sub128($_[0]->{mask},$_[1]->{mask});
    return -1 unless $c;
    return hasbits($rv) ? 1 : 0;
  }
  
  #sub comp_addr {
  #  my($c,$rv) = sub128($_[0]->{addr},$_[1]->{addr});
  #  return -1 unless $c;
  #  return hasbits($rv) ? 1 : 0;
  #}
  
  =pod
  
  =over
  
  =item B<Assignment (C<=>)>
  
  Has been optimized to copy one NetAddr::IP::Lite object to another very quickly.
  
  =item B<C<-E<gt>copy()>>
  
  The B<assignment (C<=>)> operation is only put in to operation when the
  copied object is further mutated by another overloaded operation. See
  L<overload> B<SPECIAL SYMBOLS FOR "use overload"> for details.
  
  B<C<-E<gt>copy()>> actually creates a new object when called.
  
  =cut
  
  sub copy {
  	return _new($_[0],$_[0]->{addr}, $_[0]->{mask});
  }
  
  =item B<Stringification>
  
  An object can be used just as a string. For instance, the following code
  
  	my $ip = new NetAddr::IP::Lite '192.168.1.123';
          print "$ip\n";
  
  Will print the string 192.168.1.123/32.
  
  	my $ip = new6 NetAddr::IP::Lite '192.168.1.123';
  	print "$ip\n";
  
  Will print the string 0:0:0:0:0:0:C0A8:17B/128
  
  =item B<Equality>
  
  You can test for equality with either C<eq>, C<ne>, C<==> or C<!=>. C<eq>, C<ne> allows the
  comparison with arbitrary strings as well as NetAddr::IP::Lite objects. The
  following example:
  
      if (NetAddr::IP::Lite->new('127.0.0.1','255.0.0.0') eq '127.0.0.1/8')
         { print "Yes\n"; }
  
  Will print out "Yes".
  
  Comparison with C<==> and C<!=> requires both operands to be NetAddr::IP::Lite objects.
  
  =item B<Comparison via E<gt>, E<lt>, E<gt>=, E<lt>=, E<lt>=E<gt> and C<cmp>>
  
  Internally, all network objects are represented in 128 bit format.
  The numeric representation of the network is compared through the
  corresponding operation. Comparisons are tried first on the address portion
  of the object and if that is equal then the NUMERIC cidr portion of the
  masks are compared. This leads to the counterintuitive result that
  
          /24 > /16
  
  Comparison should not be done on netaddr objects with different CIDR as
  this may produce indeterminate - unexpected results,
  rather the determination of which netblock is larger or smaller should be
  done by comparing
  
          $ip1->masklen <=> $ip2->masklen
  
  =item B<Addition of a constant (C<+>)>
  
  Add a 32 bit signed constant to the address part of a NetAddr object.
  This operation changes the address part to point so many hosts above the
  current objects start address. For instance, this code:
  
      print NetAddr::IP::Lite->new('127.0.0.1/8') + 5;
  
  will output 127.0.0.6/8. The address will wrap around at the broadcast
  back to the network address. This code:
  
      print NetAddr::IP::Lite->new('10.0.0.1/24') + 255;
  
  outputs 10.0.0.0/24.
  
  Returns the the unchanged object when the constant is missing or out of range.
  
      2147483647 <= constant >= -2147483648
  
  =cut
  
  sub plus {
      my $ip	= shift;
      my $const	= shift;
  
      return $ip unless $const &&
  		$const < 2147483648 &&
  		$const > -2147483649;
  
      my $a = $ip->{addr};
      my $m = $ip->{mask};
  
      my $lo = $a & ~$m;
      my $hi = $a & $m;
  
      my $new = ((addconst($lo,$const))[1] & ~$m) | $hi;
  
      return _new($ip,$new,$m);
  }
  
  =item B<Subtraction of a constant (C<->)>
  
  The complement of the addition of a constant.
  
  =item B<Difference (C<->)>
  
  Returns the difference between the address parts of two NetAddr::IP::Lite
  objects address parts as a 32 bit signed number.
  
  Returns B<undef> if the difference is out of range.
  
  =cut
  
  my $_smsk = pack('L3N',0xffffffff,0xffffffff,0xffffffff,0x80000000);
  
  sub minus {
      my $ip	= shift;
      my $arg	= shift;
      unless (ref $arg) {
  	return plus($ip, -$arg);
      }
      my($carry,$dif) = sub128($ip->{addr},$arg->{addr});
      if ($carry) {					# value is positive
  	return undef if hasbits($dif & $_smsk);		# all sign bits should be 0's
  	return (unpack('L3N',$dif))[3];
      } else {
  	return undef if hasbits(($dif & $_smsk) ^ $_smsk);	# sign is 1's
  	return (unpack('L3N',$dif))[3] - 4294967296;
      }
  }
  
  				# Auto-increment an object
  
  =item B<Auto-increment>
  
  Auto-incrementing a NetAddr::IP::Lite object causes the address part to be
  adjusted to the next host address within the subnet. It will wrap at
  the broadcast address and start again from the network address.
  
  =cut
  
  sub plusplus {
      my $ip	= shift;
  
      my $a = $ip->{addr};
      my $m = $ip->{mask};
  
      my $lo = $a & ~ $m;
      my $hi = $a & $m;
  
      $ip->{addr} = ((addconst($lo,1))[1] & ~ $m) | $hi;
      return $ip;
  }
  
  =item B<Auto-decrement>
  
  Auto-decrementing a NetAddr::IP::Lite object performs exactly the opposite
  of auto-incrementing it, as you would expect.
  
  =cut
  
  sub minusminus {
      my $ip	= shift;
  
      my $a = $ip->{addr};
      my $m = $ip->{mask};
  
      my $lo = $a & ~$m;
      my $hi = $a & $m;
  
      $ip->{addr} = ((addconst($lo,-1))[1] & ~$m) | $hi;
      return $ip;
  }
  
  				#############################################
  				# End of the overload methods.
  				#############################################
  
  # Preloaded methods go here.
  
  				# This is a variant to ->new() that
  				# creates and blesses a new object
  				# without the fancy parsing of
  				# IP formats and shorthands.
  
  # return a blessed IP object without parsing
  # input:	prototype, naddr, nmask
  # returns:	blessed IP object
  #
  sub _new ($$$) {
    my $proto = shift;
    my $class = ref($proto) || die "reference required";
    $proto = $proto->{isv6};
    my $self = {
  	addr	=> $_[0],
  	mask	=> $_[1],
  	isv6	=> $proto,
    };
    return bless $self, $class;
  }
  
  =pod
  
  =back
  
  =head2 Methods
  
  =over
  
  =item C<-E<gt>new([$addr, [ $mask|IPv6 ]])>
  
  =item C<-E<gt>new6([$addr, [ $mask]])>
  
  =item C<-E<gt>new6FFFF([$addr, [ $mask]])>
  
  =item C<-E<gt>new_no([$addr, [ $mask]])>
  
  =item C<-E<gt>new_from_aton($netaddr)>
  
  =item new_cis and new_cis6 are DEPRECATED
  
  =item C<-E<gt>new_cis("$addr $mask)>
  
  =item C<-E<gt>new_cis6("$addr $mask)>
  
  The first three methods create a new address with the supplied address in
  C<$addr> and an optional netmask C<$mask>, which can be omitted to get 
  a /32 or /128 netmask for IPv4 / IPv6 addresses respectively. 
  
  new6FFFF specifically returns an IPv4 address in IPv6 format according to RFC4291
  
    new6		     ::xxxx:xxxx
    new6FFFF	::FFFF:xxxx:xxxx
  
  The third method C<new_no> is exclusively for IPv4 addresses and filters
  improperly formatted
  dot quad strings for leading 0's that would normally be interpreted as octal
  format by NetAddr per the specifications for inet_aton.
  
  B<new_from_aton> takes a packed IPv4 address and assumes a /32 mask. This
  function replaces the DEPRECATED :aton functionality which is fundamentally
  broken.
  
  The last two methods B<new_cis> and B<new_cis6> differ from B<new> and
  B<new6> only in that they except the common Cisco address notation for
  address/mask pairs with a B<space> as a separator instead of a slash (/)
  
  These methods are DEPRECATED because the functionality is now included
  in the other "new" methods
  
    i.e.  ->new_cis('1.2.3.0 24')
          or
          ->new_cis6('::1.2.3.0 120')
  
  C<-E<gt>new6> and
  C<-E<gt>new_cis6> mark the address as being in ipV6 address space even
  if the format would suggest otherwise.
  
    i.e.  ->new6('1.2.3.4') will result in ::102:304
  
    addresses submitted to ->new in ipV6 notation will
    remain in that notation permanently. i.e.
          ->new('::1.2.3.4') will result in ::102:304
    whereas new('1.2.3.4') would print out as 1.2.3.4
  
    See "STRINGIFICATION" below.
  
  C<$addr> can be almost anything that can be resolved to an IP address
  in all the notations I have seen over time. It can optionally contain
  the mask in CIDR notation. If the OPTIONAL perl module Socket6 is
  available in the local library it will autoload and ipV6 host6 
  names will be resolved as well as ipV4 hostnames.
  
  B<prefix> notation is understood, with the limitation that the range
  specified by the prefix must match with a valid subnet.
  
  Addresses in the same format returned by C<inet_aton> or
  C<gethostbyname> can also be understood, although no mask can be
  specified for them. The default is to not attempt to recognize this
  format, as it seems to be seldom used.
  
  ###### DEPRECATED, will be remove in version 5 ############
  To accept addresses in that format, invoke the module as in
  
    use NetAddr::IP::Lite ':aton'
  
  ###### USE new_from_aton instead ##########################
  
  If called with no arguments, 'default' is assumed.
  
  If called with an empty string as the argument, returns 'undef'
  
  C<$addr> can be any of the following and possibly more...
  
    n.n
    n.n/mm
    n.n mm
    n.n.n
    n.n.n/mm
    n.n.n mm
    n.n.n.n
    n.n.n.n/mm		32 bit cidr notation
    n.n.n.n mm
    n.n.n.n/m.m.m.m
    n.n.n.n m.m.m.m
    loopback, localhost, broadcast, any, default
    x.x.x.x/host
    0xABCDEF, 0b111111000101011110, (or a bcd number)
    a netaddr as returned by 'inet_aton'
  
  
  Any RFC1884 notation
  
    ::n.n.n.n
    ::n.n.n.n/mmm		128 bit cidr notation
    ::n.n.n.n/::m.m.m.m
    ::x:x
    ::x:x/mmm
    x:x:x:x:x:x:x:x
    x:x:x:x:x:x:x:x/mmm
    x:x:x:x:x:x:x:x/m:m:m:m:m:m:m:m any RFC1884 notation
    loopback, localhost, unspecified, any, default
    ::x:x/host
    0xABCDEF, 0b111111000101011110 within the limits
    of perl's number resolution
    123456789012  a 'big' bcd number (bigger than perl likes)
    and Math::BigInt
  
  A Fully Qualified Domain Name which returns an ipV4 address or an ipV6
  address, embodied in that order. This previously undocumented feature
  may be disabled with:
  
  	use NetAddr::IP::Lite ':nofqdn';
  
  If called with no arguments, 'default' is assumed.
  
  If called with and empty string as the argument, 'undef' is returned;
  
  =cut
  
  my $lbmask = inet_aton('255.0.0.0');
  my $_p4broad	= inet_any2n('255.255.255.255');
  my $_p4loop	= inet_any2n('127.0.0.1');
  my $_p4mloop	= inet_aton('255.0.0.0');
     $_p4mloop	= mask4to6($_p4mloop);
  my $_p6loop	= inet_any2n('::1');
  
  my %fip4 = (
          default         => Zeros,
          any             => Zeros,
          broadcast       => $_p4broad,
          loopback        => $_p4loop,
  	unspecified	=> undef,
  );
  my %fip4m = (
          default         => Zeros,
          any             => Zeros,
          broadcast       => Ones,
          loopback        => $_p4mloop,
  	unspecified	=> undef,	# not applicable for ipV4
  	host		=> Ones,
  );
  
  my %fip6 = (
  	default         => Zeros,
  	any             => Zeros,
  	broadcast       => undef,	# not applicable for ipV6
  	loopback        => $_p6loop,
  	unspecified     => Zeros,
  );
  
  my %fip6m = (
  	default         => Zeros,
  	any             => Zeros,
  	broadcast       => undef,	# not applicable for ipV6
  	loopback        => Ones,
  	unspecified     => Ones,
  	host		=> Ones,
  );
  
  my $ff000000 = pack('L3N',0xffffffff,0xffffffff,0xffffffff,0xFF000000);
  my $ffff0000 = pack('L3N',0xffffffff,0xffffffff,0xffffffff,0xFFFF0000);
  my $ffffff00 = pack('L3N',0xffffffff,0xffffffff,0xffffffff,0xFFFFFF00);
  
  sub _obits ($$) {
      my($lo,$hi) = @_;
  
      return 0xFF if $lo == $hi;
      return (~ ($hi ^ $lo)) & 0xFF;
  }
  
  sub new_no($;$$) {
    unshift @_, -1;
    goto &_xnew;
  }
  
  sub new($;$$) {
    unshift @_, 0;
    goto &_xnew;
  }
  
  sub new_from_aton($$) {
    my $proto     = shift;
    my $class = ref $proto || $proto || __PACKAGE__;
    my $ip = shift;
    return undef unless defined $ip;
    my $addrlen = length($ip);
    return undef unless $addrlen == 4;
    my $self = {
  	addr    => ipv4to6($ip),
  	mask    => &Ones,
  	isv6    => 0,
    };
    return bless $self, $class;
  }
  
  sub new6($;$$) {
    unshift @_, 1;
    goto &_xnew;
  }
  
  sub new6FFFF($;$$) {
    my $ip = _xnew(1,@_);
    $ip->{addr} |= $_ipv4FFFF;
    return $ip;
  }
  
  sub new_cis($;$$) {
    my @in = @_;
    if ( $in[1] && $in[1] =~ m!^(.+)\s+(.+)$! ) {
      $in[1] = $1 .'/'. $2;
    }
    @_ = (0,@in);
    goto &_xnew;
  }
  
  sub new_cis6($;$$) {
    my @in = @_;
    if ( $in[1] && $in[1] =~ m!^(.+)\s+(.+)$! ) {
      $in[1] = $1 .'/'. $2;
    }
    @_ = (1,@in);
    goto &_xnew;
  }
  
  sub _no_octal {
  #  $_[0] =~ m/^(\d+)\.(\d+)\.(\d+)\.(\d+)$/;
  #  return sprintf("%d.%d.%d.%d",$1,$2,$3,$4);
    (my $rv = $_[0]) =~ s#\b0*([1-9]\d*/?|0/?)#$1#g;	# suppress leading zeros
    $rv;
  }
  
  sub _xnew($$;$$) {
    my $noctal	= 0;
    my $isV6	= shift;
    if ($isV6 < 0) {		# flag for no octal?
      $isV6	= 0;
      $noctal	= 1;
    }
    my $proto	= shift;
    my $class	= ref $proto || $proto || __PACKAGE__;
    my $ip	= shift;
  
    if ($ip && $noctal && $ip !~ m|(?:[^\s0123456789/. -])|) {		# octal suppression required if not an IPv4 address
      $ip = _no_octal($ip);
    }
  
  # fix for bug #75976
    return undef if defined $ip && $ip eq '';
  
    $ip = 'default' unless defined $ip;
    $ip = _retMBIstring($ip)		# treat as big bcd string
  	if ref $ip && ref $ip eq 'Math::BigInt';	# can /CIDR notation
    my $hasmask = 1;
    my($mask,$tmp);
  
  # IP to lower case AFTER ref test for Math::BigInt. 'lc' strips blessing
  
    $ip = lc $ip;
  
    while (1) {
  # process IP's with no CIDR or that have the CIDR as part of the IP argument string
      unless (@_) {
  #      if ($ip =~ m!^(.+)/(.+)$!) {
        if ($ip !~ /\D/) {		# binary number notation
  	$ip = bcd2bin($ip);
  	$mask = Ones;
  	last;
        }
        elsif ($ip =~ m!^([a-z0-9.:-]+)(?:/|\s+)([a-z0-9.:-]+)$! ||
  	     $ip =~ m!^[\[]{1}([a-z0-9.:-]+)(?:/|\s+)([a-z0-9.:-]+)[\]]{1}$!) {
  	$ip	= $1;
  	$mask	= $2;
        } elsif (grep($ip eq $_,(qw(default any broadcast loopback unspecified)))) {
  	$isV6 = 1 if $ip eq 'unspecified';
  	if ($isV6) {
  	  $mask = $fip6m{$ip};
  	  return undef unless defined ($ip = $fip6{$ip});
  	} else {
  	  $mask	= $fip4m{$ip};
  	  return undef unless defined ($ip = $fip4{$ip});
  	}
  	last;
        }
      }
  # process "ipv6" token and default IP's
      elsif (defined $_[0]) {
        if ($_[0] =~ /ipv6/i || $isV6) {
  	if (grep($ip eq $_,(qw(default any loopback unspecified)))) {
  	  $mask	= $fip6m{$ip};
  	  $ip	= $fip6{$ip};
  	  last;
  	} else {
  	  return undef unless $isV6;
  # add for ipv6 notation "12345, 1"
          }
  #	$mask = lc $_[0];
  #      } else {
  #	$mask = lc $_[0];
        }
  # extract mask
        $mask = $_[0];
      }
  ###
  ### process mask
      unless (defined $mask) {
        $hasmask	= 0;
        $mask	= 'host';
      }
  
  # two kinds of IP's can turn on the isV6 flag
  # 1) big digits that are over the IPv4 boundry
  # 2) IPv6 IP syntax
  #
  # check these conditions and set isV6 as appropriate
  #
      my $try;
      $isV6 = 1 if	# check big bcd and IPv6 rfc1884
  	( $ip !~ /\D/ && 				  # ip is all decimal
  	  (length($ip) > 3 || $ip > 255) &&		  # exclude a single digit in the range of zero to 255, could be funny IPv4
  	  ($try = bcd2bin($ip)) && ! isIPv4($try)) ||	  # precedence so $try is not corrupted
  	(index($ip,':') >= 0 && ($try = ipv6_aton($ip))); # fails if not an rfc1884 address
  
  # if either of the above conditions is true, $try contains the NetAddr 128 bit address
  
  # checkfor Math::BigInt mask
      $mask = _retMBIstring($mask)				# treat as big bcd string
          if ref $mask && ref $mask eq 'Math::BigInt';
  
  # MASK to lower case AFTER ref test for Math::BigInt, 'lc' strips blessing
  
      $mask = lc $mask;
  
      if ($mask !~ /\D/) {				# bcd or CIDR notation
        my $isCIDR = length($mask) < 4 && $mask < 129;
        if ($isV6) {
  	if ($isCIDR) {
  	  my($dq1,$dq2,$dq3,$dq4);
  	  if ($ip =~ /^(\d+)(?:|\.(\d+)(?:|\.(\d+)(?:|\.(\d+))))$/ &&
  	    do {$dq1 = $1;
  		$dq2 = $2 || 0;
  		$dq3 = $3 || 0;
  		$dq4 = $4 || 0;
  		1;
  	    } &&
  	    $dq1 >= 0 && $dq1 < 256 &&
  	    $dq2 >= 0 && $dq2 < 256 &&
  	    $dq3 >= 0 && $dq3 < 256 &&
  	    $dq4 >= 0 && $dq4 < 256
  	  ) {	# corner condition of IPv4 with isV6
  	    $ip = join('.',$dq1,$dq2,$dq3,$dq4);
  	    $try = ipv4to6(inet_aton($ip));
  	    if ($mask < 32) {
  	      $mask = shiftleft(Ones,32 -$mask);
  	    }
  	    elsif ($mask == 32) {
  	      $mask = Ones;
  	    } else {
  	      return undef;			# undoubtably an error
  	    }
  	  }
  	  elsif ($mask < 128) {
  	    $mask = shiftleft(Ones,128 -$mask);	# small cidr
  	  } else {
  	    $mask = Ones();
  	  }
  	} else {
  	  $mask = bcd2bin($mask);
  	}
        }
        elsif ($isCIDR && $mask < 33) {		# is V4
  #	if ($ip && $noctal && $ip !~ m|(?:[^\s0123456789.])|) {              # octal suppression required if not an IPv4 address
  #	  $mask = _no_octal($mask);
  #	}
  	if ($mask < 32) {
  	  $mask = shiftleft(Ones,32 -$mask);
  	}
  	elsif ( $mask == 32) {
  	  $mask = Ones;
  	} else {
  	  $mask = bcd2bin($mask);
  	  $mask |= $_v4mask;			# v4 always 
  	}
        } else {					# also V4
  	$mask = bcd2bin($mask);
  	$mask |= $_v4mask;
        }
        if ($try) {				# is a big number
  	$ip = $try;
  	last;
        }
      } elsif ($mask =~ m/^\d+\.\d+\.\d+\.\d+$/) { # ipv4 form of mask
        $mask = _no_octal($mask) if $noctal;	# filter for octal
        return undef unless defined ($mask = inet_aton($mask));
        $mask = mask4to6($mask);
      } elsif (grep($mask eq $_,qw(default any broadcast loopback unspecified host))) {
        if (index($ip,':') < 0 && ! $isV6) {
  	return undef unless defined ($mask = $fip4m{$mask});
        } else {
  	return undef unless defined ($mask = $fip6m{$mask});
        }
      } else {
        return undef unless defined ($mask = ipv6_aton($mask));	# try ipv6 form of mask
      }
  
  # process remaining IP's
  
      if (index($ip,':') < 0) {				# ipv4 address
        if ($ip =~ m/^(\d+)\.(\d+)\.(\d+)\.(\d+)$/) {
  	;	# the common case
        }
        elsif (grep($ip eq $_,(qw(default any broadcast loopback)))) {
  	return undef unless defined ($ip = $fip4{$ip});
  	last;
        }
        elsif ($ip =~ m/^(\d+)\.(\d+)$/) {
  	$ip = ($hasmask)
  		? "${1}.${2}.0.0"
  		: "${1}.0.0.${2}";
        }
        elsif ($ip =~ m/^(\d+)\.(\d+)\.(\d+)$/) {
  	$ip = ($hasmask)
  		? "${1}.${2}.${3}.0"
  		: "${1}.${2}.0.${3}";
        }
        elsif ($ip =~ /^(\d+)$/ && $hasmask && $1 >= 0 and $1 < 256) { # pure numeric
  	$ip = sprintf("%d.0.0.0",$1);
        }
  #      elsif ($ip =~ /^\d+$/ && !$hasmask) {	# a big integer
        elsif ($ip =~ /^\d+$/ ) {	# a big integer
  	$ip = bcd2bin($ip);
  	last;
        }
  # these next three might be broken??? but they have been in the code a long time and no one has complained
        elsif ($ip =~ /^0[xb]\d+$/ && $hasmask &&
  		(($tmp = eval "$ip") || 1) &&
  		$tmp >= 0 && $tmp < 256) {
          $ip = sprintf("%d.0.0.0",$tmp);
        }
        elsif ($ip =~ /^-?\d+$/) {
  	$ip += 2 ** 32 if $ip < 0;
  	$ip = pack('L3N',0,0,0,$ip);
  	last;
        }
        elsif ($ip =~ /^-?0[xb]\d+$/) {
  	$ip = eval "$ip";
  	$ip = pack('L3N',0,0,0,$ip);
  	last;
        }
  
  #	notations below include an implicit mask specification
  
        elsif ($ip =~ m/^(\d+)\.$/) {
  	$ip = "${1}.0.0.0";
  	$mask = $ff000000;
        }
        elsif ($ip =~ m/^(\d+)\.(\d+)-(\d+)\.?$/ && $2 <= $3 && $3 < 256) {
  	$ip = "${1}.${2}.0.0";
  	$mask = pack('L3C4',0xffffffff,0xffffffff,0xffffffff,255,_obits($2,$3),0,0);
        }
        elsif ($ip =~ m/^(\d+)-(\d+)\.?$/ and $1 <= $2 && $2 < 256) {
  	$ip = "${1}.0.0.0";
  	$mask = pack('L3C4',0xffffffff,0xffffffff,0xffffffff,_obits($1,$2),0,0,0)
        }
        elsif ($ip =~ m/^(\d+)\.(\d+)\.$/) {
  	$ip = "${1}.${2}.0.0";
  	$mask = $ffff0000;
        }
        elsif ($ip =~ m/^(\d+)\.(\d+)\.(\d+)-(\d+)\.?$/ && $3 <= $4 && $4 < 256) {
  	$ip = "${1}.${2}.${3}.0";
  	$mask = pack('L3C4',0xffffffff,0xffffffff,0xffffffff,255,255,_obits($3,$4),0);
        }
        elsif ($ip =~ m/^(\d+)\.(\d+)\.(\d+)\.$/) {
  	$ip = "${1}.${2}.${3}.0";
  	$mask = $ffffff00;
        }
        elsif ($ip =~ m/^(\d+)\.(\d+)\.(\d+)\.(\d+)-(\d+)$/ && $4 <= $5 && $5 < 256) {
  	$ip = "${1}.${2}.${3}.${4}";
  	$mask = pack('L3C4',0xffffffff,0xffffffff,0xffffffff,255,255,255,_obits($4,$5));
        }
        elsif ($ip =~ m/^(\d+\.\d+\.\d+\.\d+)
  		\s*-\s*(\d+\.\d+\.\d+\.\d+)$/x) {
  #	if ($noctal) {
  #	  return undef unless ($ip = inet_aton(_no_octal($1)));
  #	  return undef unless ($tmp = inet_aton(_no_octal($2)));
  #	} else {
  	  return undef unless ($ip = inet_aton($1));
  	  return undef unless ($tmp = inet_aton($2));
  #	}
  # check for left side greater than right side
  # save numeric difference in $mask
  	return undef if ($tmp = unpack('N',$tmp) - unpack('N',$ip)) < 0;
  	$ip = ipv4to6($ip);
  	$tmp = pack('L3N',0,0,0,$tmp);
  	$mask = ~$tmp;
  	return undef if notcontiguous($mask);
  # check for non-aligned left side
  	return undef if hasbits($ip & $tmp);
  	last;
        }
  # check for resolvable IPv4 hosts
        elsif (! $NoFQDN && $ip !~ /[^a-zA-Z0-9\._-]/ && ($tmp = gethostbyname(fillIPv4($ip))) && $tmp ne $_v4zero && $tmp ne $_zero ) {
  	$ip = ipv4to6($tmp);
  	last;
        }
  # check for resolvable IPv6 hosts
        elsif (! $NoFQDN && $ip !~ /[^a-zA-Z0-9\._-]/ && havegethostbyname2() && ($tmp = naip_gethostbyname($ip))) {
  	$ip = $tmp;
  	$isV6 = 1;
  	last;
        }
        elsif ($Accept_Binary_IP && ! $hasmask) {
  	if (length($ip) == 4) {
  	  $ip = ipv4to6($ip);
  	} elsif (length($ip) == 16) {
  	  $isV6 = 1;
  	} else {
  	  return undef;
  	}
  	last;
        } else {
  	return undef;
        }
        return undef unless defined ($ip = inet_aton($ip));
        $ip = ipv4to6($ip);
        last;
      }
  ########## continuing
      else {						# ipv6 address
        $isV6 = 1;
        $ip = $1 if $ip =~ /\[([^\]]+)\]/;		# transform URI notation
        if (defined ($tmp = ipv6_aton($ip))) {
  	$ip = $tmp;
  	last;
        }
        last if grep($ip eq $_,(qw(default any loopback unspecified))) &&
  		defined ($ip = $fip6{$ip});
        return undef;
      }
    } # end while (1)
    return undef if notcontiguous($mask);			# invalid if not contiguous
  
    my $self = {
  	addr	=> $ip,
  	mask	=> $mask,
  	isv6	=> $isV6,
    };
    return bless $self, $class;
  }
  
  =item C<-E<gt>broadcast()>
  
  Returns a new object referring to the broadcast address of a given
  subnet. The broadcast address has all ones in all the bit positions
  where the netmask has zero bits. This is normally used to address all
  the hosts in a given subnet.
  
  =cut
  
  sub broadcast ($) {
    my $ip = _new($_[0],$_[0]->{addr} | ~$_[0]->{mask},$_[0]->{mask});
    $ip->{addr} &= V4net unless $ip->{isv6};
    return $ip;
  }
  
  =item C<-E<gt>network()>
  
  Returns a new object referring to the network address of a given
  subnet. A network address has all zero bits where the bits of the
  netmask are zero. Normally this is used to refer to a subnet.
  
  =cut
  
  sub network ($) {
    return _new($_[0],$_[0]->{addr} & $_[0]->{mask},$_[0]->{mask});
  }
  
  =item C<-E<gt>addr()>
  
  Returns a scalar with the address part of the object as an IPv4 or IPv6 text
  string as appropriate. This is useful for printing or for passing the address
  part of the NetAddr::IP::Lite object to other components that expect an IP
  address. If the object is an ipV6 address or was created using ->new6($ip)
  it will be reported in ipV6 hex format otherwise it will be reported in dot
  quad format only if it resides in ipV4 address space.
  
  =cut
  
  sub addr ($) {
    return ($_[0]->{isv6})
  	? ipv6_n2x($_[0]->{addr})
  	: inet_n2dx($_[0]->{addr});
  }
  
  =item C<-E<gt>mask()>
  
  Returns a scalar with the mask as an IPv4 or IPv6 text string as
  described above.
  
  =cut
  
  sub mask ($) {
    return ipv6_n2x($_[0]->{mask}) if $_[0]->{isv6};
    my $mask = isIPv4($_[0]->{addr})
  	? $_[0]->{mask} & V4net
  	: $_[0]->{mask};
    return inet_n2dx($mask);
  }
  
  =item C<-E<gt>masklen()>
  
  Returns a scalar the number of one bits in the mask.
  
  =cut
  
  sub masklen ($) {
    my $len = (notcontiguous($_[0]->{mask}))[1];
    return 0 unless $len;
    return $len if $_[0]->{isv6};
    return isIPv4($_[0]->{addr})
  	? $len -96
  	: $len;
  }
  
  =item C<-E<gt>bits()>
  
  Returns the width of the address in bits. Normally 32 for v4 and 128 for v6.
  
  =cut
  
  sub bits {
    return $_[0]->{isv6} ? 128 : 32;
  }
  
  =item C<-E<gt>version()>
  
  Returns the version of the address or subnet. Currently this can be
  either 4 or 6.
  
  =cut
  
  sub version {
    my $self = shift;
    return $self->{isv6} ? 6 : 4;
  }
  
  =item C<-E<gt>cidr()>
  
  Returns a scalar with the address and mask in CIDR notation. A
  NetAddr::IP::Lite object I<stringifies> to the result of this function.
  (see comments about ->new6() and ->addr() for output formats)
  
  =cut
  
  sub cidr ($) {
    return $_[0]->addr . '/' . $_[0]->masklen;
  }
  
  =item C<-E<gt>aton()>
  
  Returns the address part of the NetAddr::IP::Lite object in the same format
  as the C<inet_aton()> or C<ipv6_aton> function respectively. If the object
  was created using ->new6($ip), the address returned will always be in ipV6
  format, even for addresses in ipV4 address space.
  
  =cut
  
  sub aton {
    return $_[0]->{addr} if $_[0]->{isv6};
    return isIPv4($_[0]->{addr})
  	? ipv6to4($_[0]->{addr})
  	: $_[0]->{addr};
  }
  
  =item C<-E<gt>range()>
  
  Returns a scalar with the base address and the broadcast address
  separated by a dash and spaces. This is called range notation.
  
  =cut
  
  sub range ($) {
    return $_[0]->network->addr . ' - ' . $_[0]->broadcast->addr;
  }
  
  =item C<-E<gt>numeric()>
  
  When called in a scalar context, will return a numeric representation
  of the address part of the IP address. When called in an array
  context, it returns a list of two elements. The first element is as
  described, the second element is the numeric representation of the
  netmask.
  
  This method is essential for serializing the representation of a
  subnet.
  
  =cut
  
  sub numeric ($) {
    if (wantarray) {
      if (! $_[0]->{isv6} && isIPv4($_[0]->{addr})) {
        return (	sprintf("%u",unpack('N',ipv6to4($_[0]->{addr}))),
  		sprintf("%u",unpack('N',ipv6to4($_[0]->{mask}))));
      }
      else {
        return (	bin2bcd($_[0]->{addr}),
  		bin2bcd($_[0]->{mask}));
      }
    }
    return (! $_[0]->{isv6} && isIPv4($_[0]->{addr}))
      ? sprintf("%u",unpack('N',ipv6to4($_[0]->{addr})))
      : bin2bcd($_[0]->{addr});
  }
  
  =item C<-E<gt>bigint()>
  
  When called in a scalar context, will return a Math::BigInt representation
  of the address part of the IP address. When called in an array
  contest, it returns a list of two elements. The first element is as
  described, the second element is the Math::BigInt  representation of the
  netmask.
  
  =cut
  
  my $biloaded;
  my $bi2strng;
  my $no_mbi_emu = 1;
  
  # function to force into test development mode
  #
  sub _force_bi_emu {
    undef $biloaded;
    undef $bi2strng;
    $no_mbi_emu = 0;
    print STDERR "\n\n\tWARNING: test development mode, this
  \tmessage SHOULD NEVER BE SEEN IN PRODUCTION!
  set my \$no_mbi_emu = 1 in t/bigint.t to remove this warning\n\n";
  }
  
  # function to stringify various flavors of Math::BigInt objects
  # tests to see if the object is a hash or a signed scalar
  
  sub _bi_stfy {
    "$_[0]" =~ /(\d+)/;		# stringify and remove '+' if present
    $1;
  }
  
  sub _fakebi2strg {
    ${$_[0]} =~ /(\d+)/;
    $1;
  }
  
  # fake new from bi string Math::BigInt 0.01
  #
  sub _bi_fake {
    bless \('+'. $_[1]), 'Math::BigInt';
  }
  
  # as of this writing there are three known flavors of Math::BigInt
  # v0.01         MBI::new returns a scalar ref
  # v1.?? - 1.69  CALC::_new takes a reference to a scalar, returns an array, MBI returns a hash ref
  # v1.70 and up  CALC::_new takes a scalar, returns and array, MBI returns a hash ref
  
  sub _loadMBI {						# load Math::BigInt on demand
    if (eval {$no_mbi_emu && require Math::BigInt}) {	# any version should work, three known
      import Math::BigInt;
      $biloaded = \&Math::BigInt::new;
      $bi2strng = \&_bi_stfy;
    } else {
      $biloaded = \&_bi_fake;
      $bi2strng = \&_fakebi2strg;
    }
  }
  
  sub _retMBIstring {
    _loadMBI unless $biloaded;				# load Math::BigInt on demand
    $bi2strng->(@_);
  }
  
  sub _biRef {
    _loadMBI unless $biloaded;				# load Math::BigInt on demand
    $biloaded->('Math::BigInt',$_[0]);
  }
  
  sub bigint($) {
    my($addr,$mask);
    if (wantarray) {
      if (! $_[0]->{isv6} && isIPv4($_[0]->{addr})) {
        $addr = $_[0]->{addr}
  	? sprintf("%u",unpack('N',ipv6to4($_[0]->{addr})))
  	: 0;
        $mask = $_[0]->{mask}
  	? sprintf("%u",unpack('N',ipv6to4($_[0]->{mask})))
  	: 0;
      }
      else {
        $addr = $_[0]->{addr}
  	? bin2bcd($_[0]->{addr})
  	: 0;
        $mask = $_[0]->{mask}
  	? bin2bcd($_[0]->{mask})
  	: 0;
      }
      (_biRef($addr),_biRef($mask));
  
    } else {	# not wantarray
  
      if (! $_[0]->{isv6} && isIPv4($_[0]->{addr})) {
        $addr = $_[0]->{addr}
  	? sprintf("%u",unpack('N',ipv6to4($_[0]->{addr})))
  	: 0;
      } else {
        $addr = $_[0]->{addr}
  	? bin2bcd($_[0]->{addr})
  	: 0;
      }
      _biRef($addr);
    }
  }
  
  =item C<$me-E<gt>contains($other)>
  
  Returns true when C<$me> completely contains C<$other>. False is
  returned otherwise and C<undef> is returned if C<$me> and C<$other>
  are not both C<NetAddr::IP::Lite> objects.
  
  =cut
  
  sub contains ($$) {
    return within(@_[1,0]);
  }
  
  =item C<$me-E<gt>within($other)>
  
  The complement of C<-E<gt>contains()>. Returns true when C<$me> is
  completely contained within C<$other>, undef if C<$me> and C<$other>
  are not both C<NetAddr::IP::Lite> objects.
  
  =cut
  
  sub within ($$) {
    return 1 unless hasbits($_[1]->{mask});	# 0x0 contains everything
    my $netme	= $_[0]->{addr} & $_[0]->{mask};
    my $brdme	= $_[0]->{addr} | ~ $_[0]->{mask};
    my $neto	= $_[1]->{addr} & $_[1]->{mask};
    my $brdo	= $_[1]->{addr} | ~ $_[1]->{mask};
    return (sub128($netme,$neto) && sub128($brdo,$brdme))
  	? 1 : 0;
  }
  
  =item C-E<gt>is_rfc1918()>
  
  Returns true when C<$me> is an RFC 1918 address.
  
       10.0.0.0        -   10.255.255.255  (10/8 prefix)
       172.16.0.0      -   172.31.255.255  (172.16/12 prefix)
       192.168.0.0     -   192.168.255.255 (192.168/16 prefix)
  
  =cut
  
  my $ip_10	= NetAddr::IP::Lite->new('10.0.0.0/8');
  my $ip_10n	= $ip_10->{addr};               # already the right value
  my $ip_10b	= $ip_10n | ~ $ip_10->{mask};
  
  my $ip_172	= NetAddr::IP::Lite->new('172.16.0.0/12');
  my $ip_172n	= $ip_172->{addr};              # already the right value
  my $ip_172b	= $ip_172n | ~ $ip_172->{mask};
  
  my $ip_192	= NetAddr::IP::Lite->new('192.168.0.0/16');
  my $ip_192n	= $ip_192->{addr};              # already the right value
  my $ip_192b	= $ip_192n | ~ $ip_192->{mask};
  
  sub is_rfc1918 ($) {
    my $netme     = $_[0]->{addr} & $_[0]->{mask};
    my $brdme     = $_[0]->{addr} | ~ $_[0]->{mask};
    return 1 if (sub128($netme,$ip_10n) && sub128($ip_10b,$brdme));
    return 1 if (sub128($netme,$ip_192n) && sub128($ip_192b,$brdme));
    return (sub128($netme,$ip_172n) && sub128($ip_172b,$brdme))
          ? 1 : 0;
  }
  
  =item C<-E<gt>is_local()>
  
  Returns true when C<$me> is a local network address.
  
  	i.e.	ipV4	127.0.0.0 - 127.255.255.255
    or		ipV6	=== ::1
  
  =cut
  
  my $_lclhost6	= NetAddr::IP::Lite->new('::1');
  my $_lclnet	= NetAddr::IP::Lite->new('127/8');
  
  sub is_local ($) {
    return ($_[0]->{isv6})
  	? $_[0] == $_lclhost6
  	: $_[0]->within($_lclnet);
  }
  
  =item C<-E<gt>first()>
  
  Returns a new object representing the first usable IP address within
  the subnet (ie, the first host address).
  
  =cut
  
  my $_cidr127 = pack('N4',0xffffffff,0xffffffff,0xffffffff,0xfffffffe);
  
  sub first ($) {
    if (hasbits($_[0]->{mask} ^ $_cidr127)) {
      return $_[0]->network + 1;
    } else {
      return $_[0]->network;
    }
  #  return $_[0]->network + 1;
  }
  
  =item C<-E<gt>last()>
  
  Returns a new object representing the last usable IP address within
  the subnet (ie, one less than the broadcast address).
  
  =cut
  
  sub last ($) {
    if (hasbits($_[0]->{mask} ^ $_cidr127)) {
      return $_[0]->broadcast - 1;
    } else {
      return $_[0]->broadcast;
    }
  #  return $_[0]->broadcast - 1;
  }
  
  =item C<-E<gt>nth($index)>
  
  Returns a new object representing the I<n>-th usable IP address within
  the subnet (ie, the I<n>-th host address).  If no address is available
  (for example, when the network is too small for C<$index> hosts),
  C<undef> is returned.
  
  Version 4.00 of NetAddr::IP and version 1.00 of NetAddr::IP::Lite implements
  C<-E<gt>nth($index)> and C<-E<gt>num()> exactly as the documentation states.
  Previous versions behaved slightly differently and not in a consistent
  manner.
  
  To use the old behavior for C<-E<gt>nth($index)> and C<-E<gt>num()>:
  
    use NetAddr::IP::Lite qw(:old_nth);
  
    old behavior:
    NetAddr::IP->new('10/32')->nth(0) == undef
    NetAddr::IP->new('10/32')->nth(1) == undef
    NetAddr::IP->new('10/31')->nth(0) == undef
    NetAddr::IP->new('10/31')->nth(1) == 10.0.0.1/31
    NetAddr::IP->new('10/30')->nth(0) == undef
    NetAddr::IP->new('10/30')->nth(1) == 10.0.0.1/30
    NetAddr::IP->new('10/30')->nth(2) == 10.0.0.2/30
    NetAddr::IP->new('10/30')->nth(3) == 10.0.0.3/30
  
  Note that in each case, the broadcast address is represented in the
  output set and that the 'zero'th index is alway undef except for
  a point-to-point /31 or /127 network where there are exactly two
  addresses in the network.
  
    new behavior:
    NetAddr::IP->new('10/32')->nth(0)  == 10.0.0.0/32
    NetAddr::IP->new('10.1/32'->nth(0) == 10.0.0.1/32
    NetAddr::IP->new('10/31')->nth(0)  == 10.0.0.0/32
    NetAddr::IP->new('10/31')->nth(1)  == 10.0.0.1/32
    NetAddr::IP->new('10/30')->nth(0) == 10.0.0.1/30
    NetAddr::IP->new('10/30')->nth(1) == 10.0.0.2/30
    NetAddr::IP->new('10/30')->nth(2) == undef
  
  Note that a /32 net always has 1 usable address while a /31 has exactly 
  two usable addresses for point-to-point addressing. The first
  index (0) returns the address immediately following the network address 
  except for a /31 or /127 when it return the network address.
  
  =cut
  
  sub nth ($$) {
    my $self    = shift;
    my $count   = shift;
  
    my $slash31 = ! hasbits($self->{mask} ^ $_cidr127);
    if ($Old_nth) {
      return undef if $slash31 && $count != 1;
      return undef if ($count < 1 or $count > $self->num ());
    }
    elsif ($slash31) {
      return undef if ($count && $count != 1);	# only index 0, 1 allowed for /31
    } else {
      ++$count;
      return undef if ($count < 1 or $count > $self->num ());
    }
    return $self->network + $count;
  }
  
  =item C<-E<gt>num()>
  
  As of version 4.42 of NetAddr::IP and version 1.27 of NetAddr::IP::Lite
  a /31 and /127 with return a net B<num> value of 2 instead of 0 (zero)
  for point-to-point networks.
  
  Version 4.00 of NetAddr::IP and version 1.00 of NetAddr::IP::Lite
  return the number of usable IP addresses within the subnet, 
  not counting the broadcast or network address.
  
  Previous versions worked only for ipV4 addresses, returned a    
  maximum span of 2**32 and returned the number of IP addresses 
  not counting the broadcast address.
  	(one greater than the new behavior)
  
  To use the old behavior for C<-E<gt>nth($index)> and C<-E<gt>num()>:
  
    use NetAddr::IP::Lite qw(:old_nth);
  
  WARNING:
  
  NetAddr::IP will calculate and return a numeric string for network 
  ranges as large as 2**128. These values are TEXT strings and perl
  can treat them as integers for numeric calculations.
  
  Perl on 32 bit platforms only handles integer numbers up to 2**32 
  and on 64 bit platforms to 2**64.
  
  If you wish to manipulate numeric strings returned by NetAddr::IP
  that are larger than 2**32 or 2**64, respectively,  you must load 
  additional modules such as Math::BigInt, bignum or some similar 
  package to do the integer math.
  
  =cut
  
  sub num ($) {
    if ($Old_nth) {
      my @net = unpack('L3N',$_[0]->{mask} ^ Ones);
  # number of ip's less broadcast
      return 0xfffffffe if $net[0] || $net[1] || $net[2]; # 2**32 -1
      return $net[3] if $net[3];
    } else {	# returns 1 for /32 /128, 2 for /31 /127 else n-2 up to 2**32
      (undef, my $net) = addconst($_[0]->{mask},1);
      return 1 unless hasbits($net);	# ipV4/32 or ipV6/128
      $net = $net ^ Ones;
      return 2 unless hasbits($net);	# ipV4/31 or ipV6/127
      $net &= $_v4net unless $_[0]->{isv6};
      return bin2bcd($net);
    }
  }
  
  # deprecated
  #sub num ($) {
  #  my @net = unpack('L3N',$_[0]->{mask} ^ Ones);
  #  if ($Old_nth) {
  ## number of ip's less broadcast
  #    return 0xfffffffe if $net[0] || $net[1] || $net[2]; # 2**32 -1
  #    return $net[3] if $net[3];
  #  } else {	# returns 1 for /32 /128, 0 for /31 /127 else n-2 up to 2**32
  ## number of usable IP's === number of ip's less broadcast & network addys
  #    return 0xfffffffd if $net[0] || $net[1] || $net[2]; # 2**32 -2
  #    return 1 unless $net[3];
  #    $net[3]--;
  #  }
  #  return $net[3];
  #}
  
  =pod
  
  =back
  
  =cut
  
  sub import {
    if (grep { $_ eq ':aton' } @_) {
      $Accept_Binary_IP = 1;
      @_ = grep { $_ ne ':aton' } @_;
    }
    if (grep { $_ eq ':old_nth' } @_) {
      $Old_nth = 1;
      @_ = grep { $_ ne ':old_nth' } @_;
    }
    if (grep { $_ eq ':lower' } @_)
    {
      NetAddr::IP::Util::lower();
      @_ = grep { $_ ne ':lower' } @_;
    }
    if (grep { $_ eq ':upper' } @_)
    {
      NetAddr::IP::Util::upper();
      @_ = grep { $_ ne ':upper' } @_;
    }
    if (grep { $_ eq ':nofqdn' } @_)
    {
      $NoFQDN = 1;
      @_ = grep { $_ ne ':nofqdn' } @_;
    }
    NetAddr::IP::Lite->export_to_level(1, @_);
  }
  
  =head1 EXPORT_OK
  
  	Zeros
  	Ones
  	V4mask
  	V4net
  	:aton		DEPRECATED
  	:old_nth
  	:upper
  	:lower
  	:nofqdn
  
  =head1 AUTHORS
  
  Luis E. MuÃ±oz E<lt>luismunoz@cpan.orgE<gt>,
  Michael Robinton E<lt>michael@bizsystems.comE<gt>
  
  =head1 WARRANTY
  
  This software comes with the  same warranty as perl itself (ie, none),
  so by using it you accept any and all the liability.
  
  =head1 COPYRIGHT
  
   This software is (c) Luis E. MuÃ±oz, 1999 - 2005
   and (c) Michael Robinton, 2006 - 2014.
  
  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of either:
  
    a) the GNU General Public License as published by the Free
    Software Foundation; either version 2, or (at your option) any
    later version, or
  
    b) the "Artistic License" which comes with this distribution.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See either
  the GNU General Public License or the Artistic License for more details.
  
  You should have received a copy of the Artistic License with this
  distribution, in the file named "Artistic".  If not, I'll be glad to provide
  one.
  
  You should also have received a copy of the GNU General Public License
  along with this program in the file named "Copying". If not, write to the
  
          Free Software Foundation, Inc.,
          51 Franklin Street, Fifth Floor
          Boston, MA 02110-1301 USA
  
  or visit their web page on the internet at:
  
          http://www.gnu.org/copyleft/gpl.html.
  
  =head1 SEE ALSO
  
  NetAddr::IP(3), NetAddr::IP::Util(3), NetAddr::IP::InetBase(3)
  
  =cut
  
  1;
X86_64-LINUX-THREAD-MULTI_NETADDR_IP_LITE

$fatpacked{"x86_64-linux-thread-multi/NetAddr/IP/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_NETADDR_IP_UTIL';
  #!/usr/bin/perl
  package NetAddr::IP::Util;
  
  use strict;
  #use diagnostics;
  #use lib qw(blib/lib);
  
  use vars qw($VERSION @EXPORT_OK @ISA %EXPORT_TAGS $Mode);
  use AutoLoader qw(AUTOLOAD);
  use NetAddr::IP::Util_IS;
  use NetAddr::IP::InetBase qw(
  	:upper
  	:all
  );
  
  *NetAddr::IP::Util::upper = \&NetAddr::IP::InetBase::upper;
  *NetAddr::IP::Util::lower = \&NetAddr::IP::InetBase::lower;
  
  require DynaLoader;
  require Exporter;
  
  @ISA = qw(Exporter DynaLoader);
  
  $VERSION = do { my @r = (q$Revision: 1.53 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
  
  @EXPORT_OK = qw(
  	inet_aton
  	inet_ntoa
  	ipv6_aton
  	ipv6_ntoa
  	ipv6_n2x
  	ipv6_n2d
  	inet_any2n
  	hasbits
  	isIPv4
  	isNewIPv4
  	isAnyIPv4
  	inet_n2dx
  	inet_n2ad
  	inet_pton
  	inet_ntop
  	inet_4map6
  	shiftleft
  	addconst
  	add128
  	sub128
  	notcontiguous
  	bin2bcd
  	bcd2bin
  	mode
  	ipv4to6
  	mask4to6
  	ipanyto6
  	maskanyto6
  	ipv6to4
  	bin2bcdn
  	bcdn2txt
  	bcdn2bin
  	simple_pack
  	comp128
  	packzeros
  	AF_INET
  	AF_INET6
  	naip_gethostbyname
  	havegethostbyname2
  );
  
  %EXPORT_TAGS = (
  	all     => [@EXPORT_OK],
  	inet	=> [qw(
  		inet_aton
  		inet_ntoa
  		ipv6_aton
  		ipv6_ntoa
  		ipv6_n2x
  		ipv6_n2d
  		inet_any2n
  		inet_n2dx
  		inet_n2ad
  		inet_pton
  		inet_ntop
  		inet_4map6
  		ipv4to6
  		mask4to6
  		ipanyto6
  		maskanyto6
  		ipv6to4
  		packzeros
  		naip_gethostbyname
  	)],
  	math	=> [qw(
  		shiftleft
  		hasbits
  		isIPv4
  		isNewIPv4
  		isAnyIPv4
  		addconst
  		add128
  		sub128
  		notcontiguous
  		bin2bcd
  		bcd2bin
  	)],
  	ipv4	=> [qw(
  		inet_aton
  		inet_ntoa
  	)],
  	ipv6	=> [qw(
  		ipv6_aton
  		ipv6_ntoa
  		ipv6_n2x
  		ipv6_n2d
  		inet_any2n
  		inet_n2dx
  		inet_n2ad
  		inet_pton
  		inet_ntop
  		inet_4map6
  		ipv4to6
  		mask4to6
  		ipanyto6
  		maskanyto6
  		ipv6to4
  		packzeros
  		naip_gethostbyname
  	)],
  );
  
  if (NetAddr::IP::Util_IS->not_pure) {
    eval {		## attempt to load 'C' version of utilities
  	bootstrap NetAddr::IP::Util $VERSION;
    };
  }
  if (NetAddr::IP::Util_IS->pure || $@) {	## load the pure perl version if 'C' lib missing
    require NetAddr::IP::UtilPP;
    import NetAddr::IP::UtilPP qw( :all );
  #  require Socket;
  #  import Socket qw(inet_ntoa);
  #  *yinet_aton = \&Socket::inet_aton;
    $Mode = 'Pure Perl';
  }
  else {
    $Mode = 'CC XS';
  }
  
  # if Socket lib is broken in some way, check for overange values
  #
  #my $overange = yinet_aton('256.1') ? 1:0;
  #my $overange = gethostbyname('256.1') ? 1:0;
  
  sub mode() { $Mode };
  
  my $_newV4compat = pack('N4',0,0,0xffff,0);
  
  sub inet_4map6 {
    my $naddr = shift;
    if (length($naddr) == 4) {
      $naddr = ipv4to6($naddr);
    }
    elsif (length($naddr) == 16) {
      ;	# is OK
      return undef unless isAnyIPv4($naddr);
    } else {
      return undef;
    }
    $naddr |= $_newV4compat;
    return $naddr;
  }
  
  sub DESTROY {};
  
  my $havegethostbyname2 = 0;
  
  my $mygethostbyname;
  
  my $_Sock6ok = 1;		# for testing gethostbyname
  
  sub havegethostbyname2 {
    return $_Sock6ok
  	? $havegethostbyname2
  	: 0;
  }
  
  sub import {
    if (grep { $_ eq ':noSock6' } @_) {
  	$_Sock6ok = 0;
  	@_ = grep { $_ ne ':noSock6' } @_;
    }
    NetAddr::IP::Util->export_to_level(1,@_);
  }
  
  package NetAddr::IP::UtilPolluted;
  
  # Socket pollutes the name space with all of its symbols. Since
  # we don't want them all, confine them to this name space.
  
  use strict;
  use Socket;
  
  my $_v4zero = pack('L',0);
  my $_zero = pack('L4',0,0,0,0);
  
  # invoke replacement subroutine for Perl's "gethostbyname"
  # if Socket6 is available.
  #
  # NOTE: in certain BSD implementations, Perl's gethostbyname is broken
  # we will use our own InetBase::inet_aton instead
  
  sub _end_gethostbyname {
  #  my ($name,$aliases,$addrtype,$length,@addrs) = @_;
    my @rv = @_;
  # first ip address = rv[4]
    my $tip = $rv[4];
    unless ($tip && $tip ne $_v4zero && $tip ne $_zero) {
      @rv = ();
    }
  # length = rv[3]
    elsif ($rv[3] && $rv[3] == 4) {
      foreach (4..$#rv) {
        $rv[$_] = NetAddr::IP::Util::inet_4map6(NetAddr::IP::Util::ipv4to6($rv[$_]));
      }
      $rv[3] = 16;	# unconditionally set length to 16
    }
    elsif ($rv[3] == 16) {
      ;	# is ok
    } else {
      @rv = ();
    }
    return @rv;
  }
  
  unless ( eval { require Socket6 }) {
    $mygethostbyname = sub {
  # SEE NOTE above about broken BSD
  	my @tip = gethostbyname(NetAddr::IP::InetBase::fillIPv4($_[0]));
  	return &_end_gethostbyname(@tip);
    };
  } else {
    import Socket6 qw( gethostbyname2 getipnodebyname );
    my $try = eval { my @try = gethostbyname2('127.0.0.1',NetAddr::IP::Util::AF_INET()); $try[4] };
    if (! $@ && $try && $try eq INADDR_LOOPBACK()) {
      *_ghbn2 = \&Socket6::gethostbyname2;
      $havegethostbyname2 = 1;
    } else {
      *_ghbn2 = sub { return () };	# use failure branch below
    }
  
    $mygethostbyname = sub {
  	my @tip;
          unless ($_Sock6ok && (@tip = _ghbn2($_[0],NetAddr::IP::Util::AF_INET6())) && @tip > 1) {
  # SEE NOTE above about broken BSD
            @tip = gethostbyname(NetAddr::IP::InetBase::fillIPv4($_[0]));
          }
  	return &_end_gethostbyname(@tip);
    };
  }
  
  package NetAddr::IP::Util;
  
  sub naip_gethostbyname {
  # turn off complaint from Socket6 about missing numeric argument
    undef local $^W;
    my @rv = &$mygethostbyname($_[0]);
    return wantarray
  	? @rv
  	: $rv[4];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  NetAddr::IP::Util -- IPv4/6 and 128 bit number utilities
  
  =head1 SYNOPSIS
  
    use NetAddr::IP::Util qw(
  	inet_aton
  	inet_ntoa
  	ipv6_aton
  	ipv6_ntoa
  	ipv6_n2x
  	ipv6_n2d
  	inet_any2n
  	hasbits
  	isIPv4
  	isNewIPv4
  	isAnyIPv4
  	inet_n2dx
  	inet_n2ad
  	inet_pton
  	inet_ntop
  	inet_4map6
  	ipv4to6
  	mask4to6
  	ipanyto6
  	maskanyto6
  	ipv6to4
  	packzeros
  	shiftleft
  	addconst
  	add128
  	sub128
  	notcontiguous
  	bin2bcd
  	bcd2bin
  	mode
  	AF_INET
  	AF_INET6
  	naip_gethostbyname
    );
  
    use NetAddr::IP::Util qw(:all :inet :ipv4 :ipv6 :math)
  
    :inet	  =>	inet_aton, inet_ntoa, ipv6_aton
  		ipv6_ntoa, ipv6_n2x, ipv6_n2d, 
  		inet_any2n, inet_n2dx, inet_n2ad, 
  		inet_pton, inet_ntop, inet_4map6, 
  		ipv4to6, mask4to6, ipanyto6, packzeros
  		maskanyto6, ipv6to4, naip_gethostbyname
  
    :ipv4	  =>	inet_aton, inet_ntoa
  
    :ipv6	  =>	ipv6_aton, ipv6_ntoa, ipv6_n2x, 
  		ipv6_n2d, inet_any2n, inet_n2dx, 
  		inet_n2ad, inet_pton, inet_ntop,
  		inet_4map6, ipv4to6, mask4to6,
  		ipanyto6, maskanyto6, ipv6to4,
  		packzeros, naip_gethostbyname
  
    :math	  =>	hasbits, isIPv4, isNewIPv4, isAnyIPv4,
  		addconst, add128, sub128, notcontiguous,
  		bin2bcd, bcd2bin, shiftleft
  
    $dotquad = inet_ntoa($netaddr);
    $netaddr = inet_aton($dotquad);
    $ipv6naddr = ipv6_aton($ipv6_text);
    $ipv6_text = ipvt_ntoa($ipv6naddr);
    $hex_text = ipv6_n2x($ipv6naddr);
    $dec_text = ipv6_n2d($ipv6naddr);
    $hex_text = packzeros($hex_text);
    $ipv6naddr = inet_any2n($dotquad or $ipv6_text);
    $ipv6naddr = inet_4map6($netaddr or $ipv6naddr);
    $rv = hasbits($bits128);
    $rv = isIPv4($bits128);
    $rv = isNewIPv4($bits128);
    $rv = isAnyIPv4($bits128);
    $dotquad or $hex_text = inet_n2dx($ipv6naddr);
    $dotquad or $dec_text = inet_n2ad($ipv6naddr);
    $netaddr = inet_pton($AF_family,$hex_text);
    $hex_text = inet_ntop($AF_family,$netaddr);
    $ipv6naddr = ipv4to6($netaddr);
    $ipv6naddr = mask4to6($netaddr);
    $ipv6naddr = ipanyto6($netaddr);
    $ipv6naddr = maskanyto6($netaddr);
    $netaddr = ipv6to4($pv6naddr);
    $bitsX2 = shiftleft($bits128,$n);
    $carry = addconst($ipv6naddr,$signed_32con);
    ($carry,$ipv6naddr)=addconst($ipv6naddr,$signed_32con);
    $carry = add128($ipv6naddr1,$ipv6naddr2);
    ($carry,$ipv6naddr)=add128($ipv6naddr1,$ipv6naddr2);
    $carry = sub128($ipv6naddr1,$ipv6naddr2);
    ($carry,$ipv6naddr)=sub128($ipv6naddr1,$ipv6naddr2);
    ($spurious,$cidr) = notcontiguous($mask128);
    $bcdtext = bin2bcd($bits128);
    $bits128 = bcd2bin($bcdtxt);
    $modetext = mode;
    ($name,$aliases,$addrtype,$length,@addrs)=naip_gethostbyname(NAME);
    $trueif = havegethostbyname2();
  
    NetAddr::IP::Util::lower();
    NetAddr::IP::Util::upper();
  
  =head1 INSTALLATION
  
  Un-tar the distribution in an appropriate directory and type:
  
  	perl Makefile.PL
  	make
  	make test
  	make install
  
  B<NetAddr::IP::Util> installs by default with its primary functions compiled
  using Perl's XS extensions to build a 'C' library. If you do not have a 'C'
  complier available or would like the slower Pure Perl version for some other
  reason, then type:
  
  	perl Makefile.PL -noxs
  	make
  	make test
  	make install
  
  =head1 DESCRIPTION
  
  B<NetAddr::IP::Util> provides a suite of tools for manipulating and
  converting IPv4 and IPv6 addresses into 128 bit string context and back to
  text. The strings can be manipulated with Perl's logical operators:
  
  	and	&
  	or	|
  	xor	^
  		~	compliment
  
  in the same manner as 'vec' strings.
  
  The IPv6 functions support all rfc1884 formats.
  
    i.e.	x:x:x:x:x:x:x:x:x
  	x:x:x:x:x:x:x:d.d.d.d
  	::x:x:x
  	::x:d.d.d.d
    and so on...
  
  =over 4
  
  =item * $dotquad = inet_ntoa($netaddr);
  
  Convert a packed IPv4 network address to a dot-quad IP address.
  
    input:	packed network address
    returns:	IP address i.e. 10.4.12.123
  
  =item * $netaddr = inet_aton($dotquad);
  
  Convert a dot-quad IP address into an IPv4 packed network address.
  
    input:	IP address i.e. 192.5.16.32
    returns:	packed network address
  
  =item * $ipv6addr = ipv6_aton($ipv6_text);
  
  Takes an IPv6 address of the form described in rfc1884
  and returns a 128 bit binary RDATA string.
  
    input:	ipv6 text
    returns:	128 bit RDATA string
  
  =item * $ipv6_text = ipv6_ntoa($ipv6naddr);
  
  Convert a 128 bit binary IPv6 address to compressed rfc 1884
  text representation.
  
    input:	128 bit RDATA string
    returns:	ipv6 text
  
  =item * $hex_text = ipv6_n2x($ipv6addr);
  
  Takes an IPv6 RDATA string and returns an 8 segment IPv6 hex address
  
    input:	128 bit RDATA string
    returns:	x:x:x:x:x:x:x:x
  
  =item * $dec_text = ipv6_n2d($ipv6addr);
  
  Takes an IPv6 RDATA string and returns a mixed hex - decimal IPv6 address
  with the 6 uppermost chunks in hex and the lower 32 bits in dot-quad
  representation.
  
    input:	128 bit RDATA string
    returns:	x:x:x:x:x:x:d.d.d.d
  
  =item * $ipv6naddr = inet_any2n($dotquad or $ipv6_text);
  
  This function converts a text IPv4 or IPv6 address in text format in any
  standard notation into a 128 bit IPv6 string address. It prefixes any
  dot-quad address (if found) with '::' and passes it to B<ipv6_aton>.
  
    input:	dot-quad or rfc1844 address
    returns:	128 bit IPv6 string
  
  =item * $rv = hasbits($bits128);
  
  This function returns true if there are one's present in the 128 bit string
  and false if all the bits are zero.
  
    i.e.	if (hasbits($bits128)) {
  	  &do_something;
  	}
  
    or	if (hasbits($bits128 & $mask128) {
  	  &do_something;
  	}
  
  This allows the implementation of logical functions of the form of:
  
  	if ($bits128 & $mask128) {
  	    ...
  
    input:	128 bit IPv6 string
    returns:	true if any bits are present
  
  =item * $ipv6naddr = inet_4map6($netaddr or $ipv6naddr
  
  This function returns an ipV6 network address with the first 80 bits
  set to zero and the next 16 bits set to one, while the last 32 bits
  are filled with the ipV4 address. 
  
    input:	ipV4 netaddr
  	    or	ipV6 netaddr
    returns:	ipV6 netaddr
  
    returns: undef on error
  
  An ipV6 network address must be in one of the two compatible ipV4
  mapped address spaces. i.e.
  
  	::ffff::d.d.d.d    or    ::d.d.d.d
  
  =item * $rv = isIPv4($bits128);
  
  This function returns true if there are no on bits present in the IPv6
  portion of the 128 bit string and false otherwise.
  
    i.e.	the address must be of the form - ::d.d.d.d
  
  Note: this is an old and deprecated ipV4 compatible ipV6 address
  	
  =item * $rv = isNewIPv4($bits128);
  
  This function return true if the IPv6 128 bit string is of the form
  
  	::ffff::d.d.d.d
  
  =item * $rv = isAnyIPv4($bits128);
  
  This function return true if the IPv6 bit string is of the form
  
  	::d.d.d.d	or	::ffff::d.d.d.d
  
  =item * $dotquad or $hex_text = inet_n2dx($ipv6naddr);
  
  This function B<does the right thing> and returns the text for either a
  dot-quad IPv4 or a hex notation IPv6 address.
  
    input:	128 bit IPv6 string
    returns:	ddd.ddd.ddd.ddd
  	    or	x:x:x:x:x:x:x:x
  
  =item * $dotquad or $dec_text = inet_n2ad($ipv6naddr);
  
  This function B<does the right thing> and returns the text for either a
  dot-quad IPv4 or a hex::decimal notation IPv6 address.
  
    input:	128 bit IPv6 string
    returns:	ddd.ddd.ddd.ddd
  	    or  x:x:x:x:x:x:ddd.ddd.ddd.dd
  
  =item * $netaddr = inet_pton($AF_family,$hex_text);
  
  This function takes an IP address in IPv4 or IPv6 text format and converts it into
  binary format. The type of IP address conversion is controlled by the FAMILY
  argument.
  
  =item * $hex_text = inet_ntop($AF_family,$netaddr);
  
  This function takes and IP address in binary format and converts it into
  text format. The type of IP address conversion is controlled by the FAMILY 
  argument.
  
  NOTE: inet_ntop ALWAYS returns lowercase characters.
  
  =item * $hex_text = packzeros($hex_text);
  
  This function optimizes and rfc 1884 IPv6 hex address to reduce the number of
  long strings of zero bits as specified in rfc 1884, 2.2 (2) by substituting
  B<::> for the first occurence of the longest string of zeros in the address.
  
  =item * $ipv6naddr = ipv4to6($netaddr);
  
  Convert an ipv4 network address into an IPv6 network address.
  
    input:	32 bit network address
    returns:	128 bit network address
  
  =item * $ipv6naddr = mask4to6($netaddr);
  
  Convert an ipv4 network address/mask into an ipv6 network mask.
  
    input:	32 bit network/mask address
    returns:	128 bit network/mask address
  
  NOTE: returns the high 96 bits as one's
  
  =item * $ipv6naddr = ipanyto6($netaddr);
  
  Similar to ipv4to6 except that this function takes either an IPv4 or IPv6
  input and always returns a 128 bit IPv6 network address.
  
    input:	32 or 128 bit network address
    returns:	128 bit network address
  
  =item * $ipv6naddr = maskanyto6($netaddr);
  
  Similar to mask4to6 except that this function takes either an IPv4 or IPv6
  netmask and always returns a 128 bit IPv6 netmask.
  
    input:	32 or 128 bit network mask
    returns:	128 bit network mask
  
  =item * $netaddr = ipv6to4($pv6naddr);
  
  Truncate the upper 96 bits of a 128 bit address and return the lower
  32 bits. Returns an IPv4 address as returned by inet_aton.
  
    input:	128 bit network address
    returns:	32 bit inet_aton network address
  
  =item * $bitsXn = shiftleft($bits128,$n);
  
    input:	128 bit string variable,
  		number of shifts [optional]
    returns:	bits X n shifts
  
    NOTE: a single shift is performed
  	if $n is not specified
  
  =item * addconst($ipv6naddr,$signed_32con);
  
  Add a signed constant to a 128 bit string variable.
  
    input:	128 bit IPv6 string,
  		signed 32 bit integer
    returns:  scalar	carry
  	    array	(carry, result)
  
  =item * add128($ipv6naddr1,$ipv6naddr2);
  
  Add two 128 bit string variables.
  
    input:	128 bit string var1,
  		128 bit string var2
    returns:  scalar	carry
  	    array	(carry, result)
  
  =item * sub128($ipv6naddr1,$ipv6naddr2);
  
  Subtract two 128 bit string variables.
  
    input:	128 bit string var1,
  		128 bit string var2
    returns:  scalar	carry
  	    array	(carry, result)
  
  Note: The carry from this operation is the result of adding the one's
  complement of ARG2 +1 to the ARG1. It is logically
  B<NOT borrow>.
  
  	i.e. 	if ARG1 >= ARG2 then carry = 1
  	or	if ARG1  < ARG2 then carry = 0
  
  
  =item * ($spurious,$cidr) = notcontiguous($mask128);
  
  This function counts the bit positions remaining in the mask when the
  rightmost '0's are removed.
  
  	input:	128 bit netmask
  	returns true if there are spurious
  		    zero bits remaining in the
  		    mask, false if the mask is
  		    contiguous one's,
  		128 bit cidr number
  
  =item * $bcdtext = bin2bcd($bits128);
  
  Convert a 128 bit binary string into binary coded decimal text digits.
  
    input:	128 bit string variable
    returns:	string of bcd text digits
  
  =item * $bits128 = bcd2bin($bcdtxt);
  
  Convert a bcd text string to 128 bit string variable
  
    input:	string of bcd text digits
    returns:	128 bit string variable
  
  =cut
  
  #=item * $onescomp=NetAddr::IP::Util::comp128($ipv6addr);
  #
  #This function is not exported because it is more efficient to use perl " ~ "
  #on the bit string directly. This interface to the B<C> routine is published for
  #module testing purposes because it is used internally in the B<sub128> routine. The
  #function is very fast, but calling if from perl directly is very slow. It is almost
  #33% faster to use B<sub128> than to do a 1's comp with perl and then call
  #B<add128>.
  #
  #=item * $bcdpacked = NetAddr::IP::Util::bin2bcdn($bits128);
  #
  #Convert a 128 bit binary string into binary coded decimal digits.
  #This function is not exported.
  #
  #  input:	128 bit string variable
  #  returns:	string of packed decimal digits
  #
  #  i.e.	text = unpack("H*", $bcd);
  #
  #=item * $bcdtext =  NetAddr::IP::Util::bcdn2txt($bcdpacked);
  #
  #Convert a packed bcd string into text digits, suppress the leading zeros.
  #This function is not exported.
  #
  #  input:	string of packed decimal digits
  #  returns:	hexadecimal digits
  #
  #Similar to unpack("H*", $bcd);
  #
  #=item * $bcdpacked = NetAddr::IP::Util::simple_pack($bcdtext);
  #
  #Convert a numeric string into a packed bcd string, left fill with zeros
  #
  #  input:	string of decimal digits
  #  returns:	string of packed decimal digits
  #
  #Similar to pack("H*", $bcdtext);
  
  =item * $modetext = mode;
  
  Returns the operating mode of this module.
  
  	input:		none
  	returns:	"Pure Perl"
  		   or	"CC XS"
  
  =item * ($name,$aliases,$addrtype,$length,@addrs)=naip_gethostbyname(NAME);
  
  Replacement for Perl's gethostbyname if Socket6 is available
  
  In ARRAY context, returns a list of five elements, the hostname or NAME,
  a space separated list of C_NAMES, AF family, length of the address
  structure, and an array of one or more netaddr's
  
  In SCALAR context, returns the first netaddr.
  
  This function ALWAYS returns an IPv6 address, even on IPv4 only systems.
  IPv4 addresses are mapped into IPv6 space in the form:
  
  	::FFFF:FFFF:d.d.d.d
  
  This is NOT the expected result from Perl's gethostbyname2. It is instead equivalent to:
  
    On an IPv4 only system:
      $ipv6naddr = ipv4to6 scalar ( gethostbyname( name ));
  
    On a system with Socket6 and a working gethostbyname2:
      $ipv6naddr = gethostbyname2( name, AF_INET6 );
    and if that fails, the IPv4 conversion above.
  
  For a gethostbyname2 emulator that behave like Socket6, see:
  L<Net::DNS::Dig>
  
  =item * $trueif = havegethostbyname2();
  
  This function returns TRUE if Socket6 has a functioning B<gethostbyname2>,
  otherwise it returns FALSE. See the comments above about the behavior of
  B<naip_gethostbyname>.
  
  =item * NetAddr::IP::Util::lower();
  
  Return IPv6 strings in lowercase.
  
  =item * NetAddr::IP::Util::upper();
  
  Return IPv6 strings in uppercase.  This is the default.
  
  =back
  
  =head1 EXAMPLES
  
  
    # convert any textual IP address into a 128 bit vector
    #
    sub text2vec {
      my($anyIP,$anyMask) = @_;
  
    # not IPv4 bit mask
      my $notiv4 = ipv6_aton('FFFF:FFFF:FFFF:FFFF:FFFF:FFFF::');
  
      my $vecip	= inet_any2n($anyIP);
      my $mask	= inet_any2n($anyMask);
  
    # extend mask bits for IPv4
      my $bits = 128;	# default
      unless (hasbits($mask & $notiv4)) {
        $mask |= $notiv4;
        $bits = 32;
      }
      return ($vecip, $mask, $bits);
    }
  
    ... alternate implementation, a little faster
  
    sub text2vec {
      my($anyIP,$anyMask) = @_;
  
    # not IPv4 bit mask
      my $notiv4 = ipv6_aton('FFFF:FFFF:FFFF:FFFF:FFFF:FFFF::');
  
      my $vecip	= inet_any2n($anyIP);
      my $mask	= inet_any2n($anyMask);
  
    # extend mask bits for IPv4
      my $bits = 128;	# default
      if (isIPv4($mask)) {
        $mask |= $notiv4;
        $bits = 32;
      }
      return ($vecip, $mask, $bits);
    }
  
  
    ... elsewhere
      $nip = {
  	addr	=> $vecip,
  	mask	=> $mask,
  	bits	=> $bits,
      };
  
    # return network and broadcast addresses from IP and Mask
    #
    sub netbroad {
      my($nip) = shift;
      my $notmask	= ~ $nip->{mask};
      my $bcast	= $nip->{addr} | $notmask;
      my $network	= $nip->{addr} & $nip->{mask};
      return ($network, $broadcast);
    }
  
    # check if address is within a network
    #
    sub within {
      my($nip,$net) = @_;
      my $addr = $nip->{addr}
      my($nw,$bc) = netbroad($net);
    # arg1 >= arg2, sub128 returns true
      return (sub128($addr,$nw) && sub128($bc,$addr))
  	? 1 : 0;
    }
  
    # truely hard way to do $ip++
    # add a constant, wrapping at netblock boundaries
    # to subtract the constant, negate it before calling
    # 'addwrap' since 'addconst' will extend the sign bits
    #
    sub addwrap {
      my($nip,$const) = @_;
      my $addr	= $nip->{addr};
      my $mask	= $nip->{mask};
      my $bits	= $nip->{bits};
      my $notmask	= ~ $mask;
      my $hibits	= $addr & $mask;
      $addr = addconst($addr,$const);
      my $wraponly = $addr & $notmask;
      my $newip = {
  	addr	=> $hibits | $wraponly,
  	mask	=> $mask,
  	bits	=> $bits,
      };
      # bless $newip as appropriate
      return $newip;
    }
  
    # something more useful
    # increment a /24 net to the NEXT net at the boundry
  
    my $nextnet = 256;	# for /24
    LOOP:
    while (...continuing) {
      your code....
      ...
      my $lastip = $ip-copy();
      $ip++;
      if ($ip < $lastip) {	# host part wrapped?
    # discard carry
        (undef, $ip->{addr} = addconst($ip->{addr}, $nextnet);
      }
      next LOOP;
    }
  
  
  =head1 EXPORT_OK
  
  	inet_aton
  	inet_ntoa
  	ipv6_aton
  	ipv6_ntoa
  	ipv6_n2x
  	ipv6_n2d
  	inet_any2n
  	hasbits
  	isIPv4
  	isNewIPv4
  	isAnyIPv4
  	inet_n2dx
  	inet_n2ad
  	inet_pton
  	inet_ntop
  	inet_4map6
  	ipv4to6
  	mask4to6
  	ipanyto6
  	maskanyto6
  	ipv6to4
  	packzeros
  	shiftleft
  	addconst
  	add128
  	sub128
  	notcontiguous
  	bin2bcd
  	bcd2bin
  	mode
  	naip_gethostbyname
  	havegethostbyname2
  
  =head1 AUTHOR
  
  Michael Robinton <michael@bizsystems.com>
  
  =head1 COPYRIGHT
  
  Copyright 2003 - 2014, Michael Robinton E<lt>michael@bizsystems.comE<gt>
  
  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of either:
  
    a) the GNU General Public License as published by the Free
    Software Foundation; either version 2, or (at your option) any
    later version, or
  
    b) the "Artistic License" which comes with this distribution.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See either
  the GNU General Public License or the Artistic License for more details.
  
  You should have received a copy of the Artistic License with this
  distribution, in the file named "Artistic".  If not, I'll be glad to provide
  one.
  
  You should also have received a copy of the GNU General Public License
  along with this program in the file named "Copying". If not, write to the
  
  	Free Software Foundation, Inc.
  	51 Franklin Street, Fifth Floor
  	Boston, MA 02110-1301 USA.
  
  or visit their web page on the internet at:
  
          http://www.gnu.org/copyleft/gpl.html.
  
  =head1 AUTHOR
  
  Michael Robinton <michael@bizsystems.com>
  
  =head1 SEE ALSO
  
  NetAddr::IP(3), NetAddr::IP::Lite(3), NetAddr::IP::InetBase(3)
  
  =cut
  
  1;
X86_64-LINUX-THREAD-MULTI_NETADDR_IP_UTIL

$fatpacked{"x86_64-linux-thread-multi/NetAddr/IP/UtilPP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_NETADDR_IP_UTILPP';
  #!/usr/bin/perl
  package NetAddr::IP::UtilPP;
  
  use strict;
  #use diagnostics;
  #use lib qw(blib lib);
  
  use AutoLoader qw(AUTOLOAD);
  use vars qw($VERSION @EXPORT_OK @ISA %EXPORT_TAGS);
  require Exporter;
  
  
  @ISA = qw(Exporter);
  
  $VERSION = do { my @r = (q$Revision: 1.9 $ =~ /\d+/g); sprintf "%d."."%02d" x $#r, @r };
  
  @EXPORT_OK = qw(
  	hasbits
  	shiftleft
  	addconst
  	add128
  	sub128
  	notcontiguous
  	ipv4to6
  	mask4to6
  	ipanyto6
  	maskanyto6
  	ipv6to4
  	bin2bcd
  	bcd2bin
  	comp128
  	bin2bcdn
  	bcdn2txt
  	bcdn2bin
  	simple_pack
  );
  
  %EXPORT_TAGS = (
  	all	=> [@EXPORT_OK],
  );
  
  sub DESTROY {};
  
  1;
  __END__
  
  =head1 NAME
  
  NetAddr::IP::UtilPP -- pure Perl functions for NetAddr::IP::Util
  
  =head1 SYNOPSIS
  
    use NetAddr::IP::UtilPP qw(
  	hasbits
  	shiftleft
  	addconst
  	add128
  	sub128
  	notcontiguous
  	ipv4to6
  	mask4to6
  	ipanyto6
  	maskanyto6
  	ipv6to4
  	bin2bcd
  	bcd2bin
    );
  
    use NetAddr::IP::UtilPP qw(:all)
  
    $rv = hasbits($bits128);
    $bitsX2 = shiftleft($bits128,$n);
    $carry = addconst($ipv6naddr,$signed_32con);
    ($carry,$ipv6naddr)=addconst($ipv6naddr,$signed_32con);
    $carry = add128($ipv6naddr1,$ipv6naddr2);
    ($carry,$ipv6naddr)=add128($ipv6naddr1,$ipv6naddr2);
    $carry = sub128($ipv6naddr1,$ipv6naddr2);
    ($spurious,$cidr) = notcontiguous($mask128);
    ($carry,$ipv6naddr)=sub128($ipv6naddr1,$ipv6naddr2);
    $ipv6naddr = ipv4to6($netaddr);
    $ipv6naddr = mask4to6($netaddr);
    $ipv6naddr = ipanyto6($netaddr);
    $ipv6naddr = maskanyto6($netaddr);
    $netaddr = ipv6to4($pv6naddr);
    $bcdtext = bin2bcd($bits128);
    $bits128 = bcd2bin($bcdtxt);
  
  =head1 DESCRIPTION
  
  B<NetAddr::IP::UtilPP> provides pure Perl functions for B<NetAddr::IP::Util>
  
  =over 4
  
  =item * $rv = hasbits($bits128);
  
  This function returns true if there are one's present in the 128 bit string
  and false if all the bits are zero.
  
    i.e.	if (hasbits($bits128)) {
  	  &do_something;
  	}
  
    or	if (hasbits($bits128 & $mask128) {
  	  &do_something;
  	}
  
  This allows the implementation of logical functions of the form of:
  
  	if ($bits128 & $mask128) {
  	    ...
  
    input:	128 bit IPv6 string
    returns:	true if any bits are present
  
  =cut
  
  sub _deadlen {
    my($len,$should) = @_;
    $len *= 8;
    $should = 128 unless $should;
    my $sub = (caller(1))[3];
    die "Bad argument length for $sub, is $len, should be $should";
  }
  
  sub hasbits {
    _deadlen(length($_[0]))
  	if length($_[0]) != 16;
    return 1 if vec($_[0],0,32);
    return 1 if vec($_[0],1,32);
    return 1 if vec($_[0],2,32);
    return 1 if vec($_[0],3,32);
    return 0;
  }
  
  #=item * $rv = isIPv4($bits128);
  #
  #This function returns true if there are no on bits present in the IPv6
  #portion of the 128 bit string and false otherwise.
  #
  #=cut
  #
  #sub xisIPv4 {
  #  _deadlen(length($_[0]))
  #	if length($_[0]) != 16;
  #  return 0 if vec($_[0],0,32);
  #  return 0 if vec($_[0],1,32);
  #  return 0 if vec($_[0],2,32);
  #  return 1;
  #}
  
  =item * $bitsXn = shiftleft($bits128,$n);
  
    input:	128 bit string variable,
  		number of shifts [optional]
    returns:	bits X n shifts
  
    NOTE: input bits are returned
  	if $n is not specified
  
  =cut
  
  # multiply x 2
  #
  sub _128x2 {
    my $inp = shift;
    $$inp[0] = ($$inp[0] << 1 & 0xffffffff) + (($$inp[1] & 0x80000000) ? 1:0);
    $$inp[1] = ($$inp[1] << 1 & 0xffffffff) + (($$inp[2] & 0x80000000) ? 1:0);
    $$inp[2] = ($$inp[2] << 1 & 0xffffffff) + (($$inp[3] & 0x80000000) ? 1:0);
    $$inp[3] = $$inp[3] << 1 & 0xffffffff;
  }
  
  # multiply x 10
  #
  sub _128x10 {
    my($a128p) = @_;
    _128x2($a128p);		# x2
    my @x2 = @$a128p;		# save the x2 value
    _128x2($a128p);
    _128x2($a128p);		# x8
    _sa128($a128p,\@x2,0);	# add for x10
  }
  
  sub shiftleft {
    _deadlen(length($_[0]))
  	if length($_[0]) != 16;
    my($bits,$shifts) = @_;
    return $bits unless $shifts;
    die "Bad arg value for ".__PACKAGE__.":shiftleft, length should be 0 thru 128"
  	if $shifts < 0 || $shifts > 128;
    my @uint32t = unpack('N4',$bits);
    do {
      $bits = _128x2(\@uint32t);
      $shifts--
    } while $shifts > 0;
     pack('N4',@uint32t);
  }
  
  sub slowadd128 {
    my @ua = unpack('N4',$_[0]);
    my @ub = unpack('N4',$_[1]);
    my $carry = _sa128(\@ua,\@ub,$_[2]);
    return ($carry,pack('N4',@ua))
          if wantarray;
    return $carry;
  }
  
  sub _sa128 {
    my($uap,$ubp,$carry) = @_;
    if (($$uap[3] += $$ubp[3] + $carry) > 0xffffffff) {
      $$uap[3] -= 4294967296;	# 0x1_00000000
      $carry = 1;
    } else {
      $carry = 0;
    }
  
    if (($$uap[2] += $$ubp[2] + $carry) > 0xffffffff) {
      $$uap[2] -= 4294967296;
      $carry = 1;
    } else {
      $carry = 0;
    }
  
    if (($$uap[1] += $$ubp[1] + $carry) > 0xffffffff) {
      $$uap[1] -= 4294967296;
      $carry = 1;
    } else {
      $carry = 0;
    }
  
    if (($$uap[0] += $$ubp[0] + $carry) > 0xffffffff) {
      $$uap[0] -= 4294967296;
      $carry = 1;
    } else {
      $carry = 0;
    }
    $carry;
  }
  
  =item * addconst($ipv6naddr,$signed_32con);
  
  Add a signed constant to a 128 bit string variable.
  
    input:	128 bit IPv6 string,
  		signed 32 bit integer
    returns:  scalar	carry
  	    array	(carry, result)
  
  =cut
  
  sub addconst {
    my($a128,$const) = @_;
    _deadlen(length($a128))
  	if length($a128) != 16;
    unless ($const) {
      return (wantarray) ? ($const,$a128) : $const;
    }
    my $sign = ($const < 0) ? 0xffffffff : 0;
    my $b128 = pack('N4',$sign,$sign,$sign,$const);
    @_ = ($a128,$b128,0);
  # perl 5.8.4 fails with this operation. see perl bug [ 23429]
  #  goto &slowadd128;
    slowadd128(@_);
  }
  
  =item * add128($ipv6naddr1,$ipv6naddr2);
  
  Add two 128 bit string variables.
  
    input:	128 bit string var1,
  		128 bit string var2
    returns:  scalar	carry
  	    array	(carry, result)
  
  =cut
  
  sub add128 {
    my($a128,$b128) = @_;
    _deadlen(length($a128))
  	if length($a128) != 16;
    _deadlen(length($b128))
  	if length($b128) != 16;
    @_ = ($a128,$b128,0);
  # perl 5.8.4 fails with this operation. see perl bug [ 23429]
  #  goto &slowadd128;
    slowadd128(@_);
  }
  
  =item * sub128($ipv6naddr1,$ipv6naddr2);
  
  Subtract two 128 bit string variables.
  
    input:	128 bit string var1,
  		128 bit string var2
    returns:  scalar	carry
  	    array	(carry, result)
  
  Note: The carry from this operation is the result of adding the one's
  complement of ARG2 +1 to the ARG1. It is logically
  B<NOT borrow>.
  
  	i.e. 	if ARG1 >= ARG2 then carry = 1
  	or	if ARG1  < ARG2 then carry = 0
  
  =cut
  
  sub sub128 {
    _deadlen(length($_[0]))
  	if length($_[0]) != 16;
    _deadlen(length($_[1]))
  	if length($_[1]) != 16;
    my $a128 = $_[0];
    my $b128 = ~$_[1];
    @_ = ($a128,$b128,1);
  # perl 5.8.4 fails with this operation. see perl bug [ 23429]
  #  goto &slowadd128;
    slowadd128(@_);
  }
  
  =item * ($spurious,$cidr) = notcontiguous($mask128);
  
  This function counts the bit positions remaining in the mask when the
  rightmost '0's are removed.
  
  	input:  128 bit netmask
  	returns true if there are spurious
  		    zero bits remaining in the
  		    mask, false if the mask is
  		    contiguous one's,
  		128 bit cidr
  
  =cut
  
  sub notcontiguous {
    _deadlen(length($_[0]))
  	if length($_[0]) != 16;
    my @ua = unpack('N4', ~$_[0]);
    my $count;
    for ($count = 128;$count > 0; $count--) {
  	last unless $ua[3] & 1;
  	$ua[3] >>= 1;
  	$ua[3] |= 0x80000000 if $ua[2] & 1;
  	$ua[2] >>= 1;
  	$ua[2] |= 0x80000000 if $ua[1] & 1;
  	$ua[1] >>= 1;
  	$ua[1] |= 0x80000000 if $ua[0] & 1;
  	$ua[0] >>= 1;
    }
  
    my $spurious = $ua[0] | $ua[1] | $ua[2] | $ua[3];
    return $spurious unless wantarray;
    return ($spurious,$count);
  }
  
  =item * $ipv6naddr = ipv4to6($netaddr);
  
  Convert an ipv4 network address into an ipv6 network address.
  
    input:	32 bit network address
    returns:	128 bit network address
  
  =cut
  
  sub ipv4to6 {
    _deadlen(length($_[0]),32)
          if length($_[0]) != 4;
  #  return pack('L3H8',0,0,0,unpack('H8',$_[0]));
    return pack('L3a4',0,0,0,$_[0]);
  }
  
  =item * $ipv6naddr = mask4to6($netaddr);
  
  Convert an ipv4 netowrk address into an ipv6 network mask.
  
    input:	32 bit network/mask address
    returns:	128 bit network/mask address
  
  NOTE: returns the high 96 bits as one's
  
  =cut
  
  sub mask4to6 {
    _deadlen(length($_[0]),32)
          if length($_[0]) != 4;
  #  return pack('L3H8',0xffffffff,0xffffffff,0xffffffff,unpack('H8',$_[0]));
    return pack('L3a4',0xffffffff,0xffffffff,0xffffffff,$_[0]);
  }
  
  =item * $ipv6naddr = ipanyto6($netaddr);
  
  Similar to ipv4to6 except that this function takes either an IPv4 or IPv6
  input and always returns a 128 bit IPv6 network address.
  
    input:	32 or 128 bit network address
    returns:	128 bit network address
  
  =cut
  
  sub ipanyto6 {
    my $naddr = shift;
    my $len = length($naddr);
    return $naddr if $len == 16;
  #  return pack('L3H8',0,0,0,unpack('H8',$naddr))
    return pack('L3a4',0,0,0,$naddr)
  	if $len == 4;
    _deadlen($len,'32 or 128');
  }
  
  =item * $ipv6naddr = maskanyto6($netaddr);
  
  Similar to mask4to6 except that this function takes either an IPv4 or IPv6
  netmask and always returns a 128 bit IPv6 netmask.
  
    input:	32 or 128 bit network mask
    returns:	128 bit network mask
  
  =cut
  
  sub maskanyto6 {
    my $naddr = shift;
    my $len = length($naddr);
    return $naddr if $len == 16;
  #  return pack('L3H8',0xffffffff,0xffffffff,0xffffffff,unpack('H8',$naddr))
    return pack('L3a4',0xffffffff,0xffffffff,0xffffffff,$naddr)
  	if $len == 4;
    _deadlen($len,'32 or 128');
  }
  
  =item * $netaddr = ipv6to4($pv6naddr);
  
  Truncate the upper 96 bits of a 128 bit address and return the lower
  32 bits. Returns an IPv4 address as returned by inet_aton.
  
    input:	128 bit network address
    returns:	32 bit inet_aton network address
  
  =cut
  
  sub ipv6to4 {
    my $naddr = shift;
  _deadlen(length($naddr))
  	if length($naddr) != 16;
    @_ = unpack('L3H8',$naddr);
    return pack('H8',@{_}[3..10]);
  }
  
  =item * $bcdtext = bin2bcd($bits128);
  
  Convert a 128 bit binary string into binary coded decimal text digits.
  
    input:	128 bit string variable
    returns:	string of bcd text digits
  
  =cut
  
  sub bin2bcd {
    _deadlen(length($_[0]))
  	if length($_[0]) != 16;
    unpack("H40",&_bin2bcdn) =~ /^0*(.+)/;
    $1;
  }
  
  =item * $bits128 = bcd2bin($bcdtxt);
  
  Convert a bcd text string to 128 bit string variable
  
    input:	string of bcd text digits
    returns:	128 bit string variable
  
  =cut
  
  sub bcd2bin {
    &_bcdcheck;
  # perl 5.8.4 fails with this operation. see perl bug [ 23429]
  #  goto &_bcd2bin;
    &_bcd2bin;
  }
  
  =pod
  
  =back
  
  =cut
  
  #=item * $onescomp = comp128($ipv6addr);
  #
  #This function is for testing, it is more efficient to use perl " ~ "
  #on the bit string directly. This interface to the B<C> routine is published for
  #module testing purposes because it is used internally in the B<sub128> routine. The
  #function is very fast, but calling if from perl directly is very slow. It is almost
  #33% faster to use B<sub128> than to do a 1's comp with perl and then call
  #B<add128>. In the PurePerl version, it is a call to
  #
  #  sub {return ~ $_[0]};
  #
  #=cut
  
  sub comp128 {
    _deadlen(length($_[0]))
  	if length($_[0]) != 16;
    return ~ $_[0];
  }
  
  #=item * $bcdpacked = bin2bcdn($bits128);
  #
  #Convert a 128 bit binary string into binary coded decimal digits.
  #This function is for testing only.
  #
  #  input:	128 bit string variable
  #  returns:	string of packed decimal digits
  #
  #  i.e.	text = unpack("H*", $bcd);
  #
  #=cut
  
  sub bin2bcdn {
    _deadlen(length($_[0]))
  	if length($_[0]) != 16;
  # perl 5.8.4 fails with this operation. see perl bug [ 23429]
  #  goto &_bin2bcdn;
    &_bin2bcdn;
  }
  
  sub _bin2bcdn {
    my($b128) = @_;
    my @binary = unpack('N4',$b128);
    my @nbcd = (0,0,0,0,0);	# 5 - 32 bit registers
    my ($add3, $msk8, $bcd8, $carry, $tmp);
    my $j = 0;
    my $k = -1;
    my $binmsk = 0;
    foreach(0..127) {
      unless ($binmsk) {
        $binmsk = 0x80000000;
        $k++;
      }
      $carry = $binary[$k] & $binmsk;
      $binmsk >>= 1;
      next unless $carry || $j;				# skip leading zeros
      foreach(4,3,2,1,0) {
        $bcd8 = $nbcd[$_];
        $add3 = 3;
        $msk8 = 8;
  
        $j = 0;
        while ($j < 8) {
  	$tmp = $bcd8 + $add3;
  	if ($tmp & $msk8) {
  	  $bcd8 = $tmp;
  	}
  	$add3 <<= 4;
  	$msk8 <<= 4;
  	$j++;
        }
        $tmp = $bcd8 & 0x80000000;	# propagate carry
        $bcd8 <<= 1;			# x2
        if ($carry) {
  	$bcd8 += 1;
        }
        $nbcd[$_] = $bcd8;
        $carry = $tmp;
      }
    }
    pack('N5',@nbcd);
  }
  
  #=item * $bcdtext = bcdn2txt($bcdpacked);
  #
  #Convert a packed bcd string into text digits, suppress the leading zeros.
  #This function is for testing only.
  #
  #  input:	string of packed decimal digits
  #		consisting of exactly 40 digits
  #  returns:	hexdecimal digits
  #
  #Similar to unpack("H*", $bcd);
  #
  #=cut
  
  sub bcdn2txt {
    die "Bad argument length for ".__PACKAGE__.":bcdn2txt, is ".(2 * length($_[0])).", should be exactly 40 digits"
  	if length($_[0]) != 20;
    (unpack('H40',$_[0])) =~ /^0*(.+)/;
    $1;
  }
  
  #=item * $bits128 = bcdn2bin($bcdpacked,$ndigits);
  #
  # Convert a packed bcd string into a 128 bit string variable
  #
  # input:	packed bcd string
  #		number of digits in string
  # returns:	128 bit string variable
  #
  
  sub bcdn2bin {
    my($bcd,$dc) = @_;
    $dc = 0 unless $dc;
    die "Bad argument length for ".__PACKAGE__.":bcdn2txt, is ".(2 * length($bcd)).", should be 1 to 40 digits"
  	if length($bcd) > 20;
    die "Bad digit count for ".__PACKAGE__.":bcdn2bin, is $dc, should be 1 to 40 digits"
  	if $dc < 1 || $dc > 40;
    return _bcd2bin(unpack("H$dc",$bcd));
  }
  
  sub _bcd2bin {
    my @bcd = split('',$_[0]);
    my @hbits = (0,0,0,0);
    my @digit = (0,0,0,0);
    my $found = 0;
    foreach(@bcd) {
      my $bcd = $_ & 0xf;		# just the nibble
      unless ($found) {
        next unless $bcd;		# skip leading zeros
        $found = 1;
        $hbits[3] = $bcd;		# set the first digit, no x10 necessary
        next;
      }
      _128x10(\@hbits);
      $digit[3] = $bcd;
      _sa128(\@hbits,\@digit,0);
    }
    return pack('N4',@hbits);
  }
  
  #=item * $bcdpacked = simple_pack($bcdtext);
  #
  #Convert a numeric string into a packed bcd string, left fill with zeros
  #This function is for testing only.
  #
  #  input:	string of decimal digits
  #  returns:	string of packed decimal digits
  #
  #Similar to pack("H*", $bcdtext);
  #
  sub _bcdcheck {
    my($bcd) = @_;;
    my $sub = (caller(1))[3];
    my $len = length($bcd);
    die "Bad bcd number length $_ ".__PACKAGE__.":simple_pack, should be 1 to 40 digits"
  	if $len > 40 || $len < 1;
    die "Bad character in decimal input string '$1' for ".__PACKAGE__.":simple_pack"
  	if $bcd =~ /(\D)/;
  }
  
  sub simple_pack {
    &_bcdcheck;
    my($bcd) = @_;
    while (length($bcd) < 40) {
      $bcd = '0'. $bcd;
    }
    return pack('H40',$bcd);
  }
  
  
  =head1 EXPORT_OK
  
  	hasbits
  	shiftleft
  	addconst
  	add128
  	sub128
  	notcontiguous
  	ipv4to6
  	mask4to6
  	ipanyto6
  	maskanyto6
  	ipv6to4
  	bin2bcd
  	bcd2bin
  	comp128
  	bin2bcdn
  	bcdn2txt
  	bcdn2bin
  	simple_pack
  	threads
  
  =head1 AUTHOR
  
  Michael Robinton E<lt>michael@bizsystems.comE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2003 - 2012, Michael Robinton E<lt>michael@bizsystems.comE<gt>
  
  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of either:
  
    a) the GNU General Public License as published by the Free
    Software Foundation; either version 2, or (at your option) any
    later version, or
  
    b) the "Artistic License" which comes with this distribution.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See either
  the GNU General Public License or the Artistic License for more details.
  
  You should have received a copy of the Artistic License with this
  distribution, in the file named "Artistic".  If not, I'll be glad to provide
  one.
  
  You should also have received a copy of the GNU General Public License
  along with this program in the file named "Copying". If not, write to the
  
          Free Software Foundation, Inc.,
          51 Franklin Street, Fifth Floor
          Boston, MA 02110-1301 USA
  
  or visit their web page on the internet at:
  
          http://www.gnu.org/copyleft/gpl.html.
  
  =head1 AUTHOR
  
  Michael Robinton <michael@bizsystems.com>
  
  =cut
  
  1;
X86_64-LINUX-THREAD-MULTI_NETADDR_IP_UTILPP

$fatpacked{"x86_64-linux-thread-multi/NetAddr/IP/Util_IS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_NETADDR_IP_UTIL_IS';
  #!/usr/bin/perl
  #
  # DO NOT ALTER THIS FILE
  # IT IS WRITTEN BY Makefile.PL
  # EDIT THAT INSTEAD
  #
  package NetAddr::IP::Util_IS;
  use vars qw($VERSION);
  $VERSION = 1.00;
  
  
  sub pure {
    return 0;
  }
  sub not_pure {
    return 1;
  }
  1;
  __END__
  
  =head1 NAME
  
  NetAddr::IP::Util_IS - Tell about Pure Perl
  
  =head1 SYNOPSIS
  
    use NetAddr::IP::Util_IS;
  
    $rv = NetAddr::IP::Util_IS->pure;
    $rv = NetAddr::IP::Util_IS->not_pure;
  
  =head1 DESCRIPTION
  
  Util_IS indicates whether or not B<NetAddr::IP::Util> was compiled in Pure
  Perl mode.
  
  =over 4
  
  =item * $rv = NetAddr::IP::Util_IS->pure;
  
  Returns true if PurePerl mode, else false.
  
  =item * $rv = NetAddr::IP::Util_IS->not_pure;
  
  Returns true if NOT PurePerl mode, else false
  
  =back
  
  =cut
  
  1;
X86_64-LINUX-THREAD-MULTI_NETADDR_IP_UTIL_IS

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


#PODNAME: nq-comb

use Data::Validate::URI qw/is_web_uri/;

use strict; use warnings;
use feature qw/say/;

# Check for help flags in the arguments
if (grep { $_ eq '-h' || $_ eq '--help' } @ARGV) {
print <<'HELP';
Usage: nq-comb [FILE]

Options:
    -h, --help      Show this help message

Description:
    nq-comb will read the N-Triples/N-Quads lines from FILE or STDIN, and will send to STDOUT the valid triples/quads, and output to STDERR the invalid lines.

Examples:
    nq-comb wordnet.nt
    cat wordnet.nq | nq-comb

HELP
    exit;
}

my $pn_chars_base   = qr/[A-Za-z\x{00C0}-\x{00D6}\x{00D8}-\x{00F6}\x{00F8}-\x{02FF}\x{0370}-\x{037D}\x{037F}-\x{1FFF}\x{200C}-\x{200D}\x{2070}-\x{218F}\x{2C00}-\x{2FEF}\x{3001}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFFD}\x{10000}-\x{EFFFF}]/;
my $pn_chars_u      = qr/$pn_chars_base|_|:/;
my $pn_chars        = qr/$pn_chars_u|[\-0-9\x{00B7}\x{0300}-\x{036F}\x{203F}-\x{2040}]/;
my $echar           = qr/\\[tbnrf"'\\]/;
my $hex             = qr/[0-9A-Fa-f]/;
my $uchar           = qr/\\u$hex{4}|\\U$hex{8}/;
my $strLitQuote     = qr/"(?:[^\x{22}\x{5C}\x{A}\x{D}]|$echar|$uchar)*"/;
my $iriRef          = qr/(?:[^\x{00}-\x{20}<>"{}|^`\\]|$uchar)+/;
my $langTag         = qr/@[a-zA-Z]+(?:-[a-zA-Z0-9]+)*/;
my $lit             = qr/$strLitQuote(?:\^\^<$iriRef>|$langTag)?/;
my $blLabel         = qr/_:(?:$pn_chars_u|[0-9])(?:(?:$pn_chars|\.)*$pn_chars)?/;

my $sub  = qr/<(?<sIri>$iriRef)>|$blLabel/;
my $pred = qr/<(?<pIri>$iriRef)>/;
my $obj  = qr/<(?<oIri>$iriRef)>|$blLabel|$lit/;
my $gLab = qr/<(?<gIri>$iriRef)>|$blLabel/;

my $quad = qr/$sub\s+$pred\s+$obj(?:\s+$gLab)?\s*\./;
my $comment = qr/#.*/;

while(my $line = <>){
    # fix percent signs
    $line =~ s/%([^0-9A-Fa-f])/%25$1/g;

    # fix \r\n
    $line =~ s/\r?\n?$//;

    if($line !~ /^\s*$quad?\s*$comment?$/){
        print STDERR "[Line $. invalid syntax] ";
        say STDERR $line;
        next;
    }

    if ($+{sIri} && !is_web_uri($+{sIri} =~ s/$uchar//gr)){
        print STDERR "[Line $. invalid subject IRI] ";
        say STDERR $+{sIri};
        next;
    }
    if ($+{pIri} && !is_web_uri($+{pIri} =~ s/$uchar//gr)){
        print STDERR "[Line $. invalid predicate IRI] ";
        say STDERR $+{pIri};
        next;
    }
    if ($+{oIri} && !is_web_uri($+{oIri} =~ s/$uchar//gr)){
        print STDERR "[Line $. invalid object IRI] ";
        say STDERR $+{oIri};
        next;
    }
    if ($+{gIri} && !is_web_uri($+{gIri} =~ s/$uchar//gr)){
        print STDERR "[Line $. invalid graph IRI] ";
        say STDERR $+{gIri};
        next;
    }

    say $line;
}


__END__

=head1 NAME

nq-comb - Fast N-Quads parsing tool which filters out quads (or triples)  with invalid syntax


=head1 SYNOPSIS

 nq-comb [FILE]
   Options:
     -h      Show a help message

=head1 DESCRIPTION

nq-comb will read N-Triples/N-Quads lines from a file or STDIN, and will send to STDOUT the valid triples/quads, and output to STDERR the invalid lines.



=head1 AUTHOR

Andre F. Santos, andrefs@andrefs.com

=cut      
__END__
